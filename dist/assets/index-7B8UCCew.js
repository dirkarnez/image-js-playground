(function(){const E=document.createElement("link").relList;if(E&&E.supports&&E.supports("modulepreload"))return;for(const P of document.querySelectorAll('link[rel="modulepreload"]'))C(P);new MutationObserver(P=>{for(const D of P)if(D.type==="childList")for(const U of D.addedNodes)U.tagName==="LINK"&&U.rel==="modulepreload"&&C(U)}).observe(document,{childList:!0,subtree:!0});function A(P){const D={};return P.integrity&&(D.integrity=P.integrity),P.referrerPolicy&&(D.referrerPolicy=P.referrerPolicy),P.crossOrigin==="use-credentials"?D.credentials="include":P.crossOrigin==="anonymous"?D.credentials="omit":D.credentials="same-origin",D}function C(P){if(P.ep)return;P.ep=!0;const D=A(P);fetch(P.href,D)}})();function getDefaultExportFromCjs(_){return _&&_.__esModule&&Object.prototype.hasOwnProperty.call(_,"default")?_.default:_}function getAugmentedNamespace(_){if(Object.prototype.hasOwnProperty.call(_,"__esModule"))return _;var E=_.default;if(typeof E=="function"){var A=function C(){var P=!1;try{P=this instanceof C}catch{}return P?Reflect.construct(E,arguments,this.constructor):E.apply(this,arguments)};A.prototype=E.prototype}else A={};return Object.defineProperty(A,"__esModule",{value:!0}),Object.keys(_).forEach(function(C){var P=Object.getOwnPropertyDescriptor(_,C);Object.defineProperty(A,C,P.get?P:{enumerable:!0,get:function(){return _[C]}})}),A}var matrix$1={};const toString$1=Object.prototype.toString;function isAnyArray(_){const E=toString$1.call(_);return E.endsWith("Array]")&&!E.includes("Big")}const libEsm=Object.freeze(Object.defineProperty({__proto__:null,isAnyArray},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(libEsm);function max$2(_){var E=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray(_))throw new TypeError("input must be an array");if(_.length===0)throw new TypeError("input must not be empty");var A=E.fromIndex,C=A===void 0?0:A,P=E.toIndex,D=P===void 0?_.length:P;if(C<0||C>=_.length||!Number.isInteger(C))throw new Error("fromIndex must be a positive integer smaller than length");if(D<=C||D>_.length||!Number.isInteger(D))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var U=_[C],G=C+1;G<D;G++)_[G]>U&&(U=_[G]);return U}function min$1(_){var E=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray(_))throw new TypeError("input must be an array");if(_.length===0)throw new TypeError("input must not be empty");var A=E.fromIndex,C=A===void 0?0:A,P=E.toIndex,D=P===void 0?_.length:P;if(C<0||C>=_.length||!Number.isInteger(C))throw new Error("fromIndex must be a positive integer smaller than length");if(D<=C||D>_.length||!Number.isInteger(D))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var U=_[C],G=C+1;G<D;G++)_[G]<U&&(U=_[G]);return U}function rescale(_){var E=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(isAnyArray(_)){if(_.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var A;if(E.output!==void 0){if(!isAnyArray(E.output))throw new TypeError("output option must be an array if specified");A=E.output}else A=new Array(_.length);var C=min$1(_),P=max$2(_);if(C===P)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var D=E.min,U=D===void 0?E.autoMinMax?C:0:D,G=E.max,X=G===void 0?E.autoMinMax?P:1:G;if(U>=X)throw new RangeError("min option must be smaller than max option");for(var q=(X-U)/(P-C),Z=0;Z<_.length;Z++)A[Z]=(_[Z]-C)*q+U;return A}const libEs6=Object.freeze(Object.defineProperty({__proto__:null,default:rescale},Symbol.toStringTag,{value:"Module"})),require$$1=getAugmentedNamespace(libEs6);var hasRequiredMatrix;function requireMatrix(){if(hasRequiredMatrix)return matrix$1;hasRequiredMatrix=1,Object.defineProperty(matrix$1,"__esModule",{value:!0});var _=require$$0,E=require$$1;const A=" ".repeat(2),C=" ".repeat(4);function P(){return D(this)}function D(W,O={}){const{maxRows:V=15,maxColumns:B=10,maxNumSize:z=8,padMinus:Y="auto"}=O;return`${W.constructor.name} {
${A}[
${C}${U(W,V,B,z,Y)}
${A}]
${A}rows: ${W.rows}
${A}columns: ${W.columns}
}`}function U(W,O,V,B,z){const{rows:Y,columns:nt}=W,it=Math.min(Y,O),ot=Math.min(nt,V),st=[];if(z==="auto"){z=!1;t:for(let vt=0;vt<it;vt++)for(let ft=0;ft<ot;ft++)if(W.get(vt,ft)<0){z=!0;break t}}for(let vt=0;vt<it;vt++){let ft=[];for(let Rt=0;Rt<ot;Rt++)ft.push(G(W.get(vt,Rt),B,z));st.push(`${ft.join(" ")}`)}return ot!==nt&&(st[st.length-1]+=` ... ${nt-V} more columns`),it!==Y&&st.push(`... ${Y-O} more rows`),st.join(`
${C}`)}function G(W,O,V){return(W>=0&&V?` ${X(W,O-1)}`:X(W,O)).padEnd(O)}function X(W,O){let V=W.toString();if(V.length<=O)return V;let B=W.toFixed(O);if(B.length>O&&(B=W.toFixed(Math.max(0,O-(B.length-O)))),B.length<=O&&!B.startsWith("0.000")&&!B.startsWith("-0.000"))return B;let z=W.toExponential(O);return z.length>O&&(z=W.toExponential(Math.max(0,O-(z.length-O)))),z.slice(0)}function q(W,O){W.prototype.add=function(B){return typeof B=="number"?this.addS(B):this.addM(B)},W.prototype.addS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)+B);return this},W.prototype.addM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)+B.get(z,Y));return this},W.add=function(B,z){return new O(B).add(z)},W.prototype.sub=function(B){return typeof B=="number"?this.subS(B):this.subM(B)},W.prototype.subS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)-B);return this},W.prototype.subM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)-B.get(z,Y));return this},W.sub=function(B,z){return new O(B).sub(z)},W.prototype.subtract=W.prototype.sub,W.prototype.subtractS=W.prototype.subS,W.prototype.subtractM=W.prototype.subM,W.subtract=W.sub,W.prototype.mul=function(B){return typeof B=="number"?this.mulS(B):this.mulM(B)},W.prototype.mulS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)*B);return this},W.prototype.mulM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)*B.get(z,Y));return this},W.mul=function(B,z){return new O(B).mul(z)},W.prototype.multiply=W.prototype.mul,W.prototype.multiplyS=W.prototype.mulS,W.prototype.multiplyM=W.prototype.mulM,W.multiply=W.mul,W.prototype.div=function(B){return typeof B=="number"?this.divS(B):this.divM(B)},W.prototype.divS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)/B);return this},W.prototype.divM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)/B.get(z,Y));return this},W.div=function(B,z){return new O(B).div(z)},W.prototype.divide=W.prototype.div,W.prototype.divideS=W.prototype.divS,W.prototype.divideM=W.prototype.divM,W.divide=W.div,W.prototype.mod=function(B){return typeof B=="number"?this.modS(B):this.modM(B)},W.prototype.modS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)%B);return this},W.prototype.modM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)%B.get(z,Y));return this},W.mod=function(B,z){return new O(B).mod(z)},W.prototype.modulus=W.prototype.mod,W.prototype.modulusS=W.prototype.modS,W.prototype.modulusM=W.prototype.modM,W.modulus=W.mod,W.prototype.and=function(B){return typeof B=="number"?this.andS(B):this.andM(B)},W.prototype.andS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)&B);return this},W.prototype.andM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)&B.get(z,Y));return this},W.and=function(B,z){return new O(B).and(z)},W.prototype.or=function(B){return typeof B=="number"?this.orS(B):this.orM(B)},W.prototype.orS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)|B);return this},W.prototype.orM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)|B.get(z,Y));return this},W.or=function(B,z){return new O(B).or(z)},W.prototype.xor=function(B){return typeof B=="number"?this.xorS(B):this.xorM(B)},W.prototype.xorS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)^B);return this},W.prototype.xorM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)^B.get(z,Y));return this},W.xor=function(B,z){return new O(B).xor(z)},W.prototype.leftShift=function(B){return typeof B=="number"?this.leftShiftS(B):this.leftShiftM(B)},W.prototype.leftShiftS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)<<B);return this},W.prototype.leftShiftM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)<<B.get(z,Y));return this},W.leftShift=function(B,z){return new O(B).leftShift(z)},W.prototype.signPropagatingRightShift=function(B){return typeof B=="number"?this.signPropagatingRightShiftS(B):this.signPropagatingRightShiftM(B)},W.prototype.signPropagatingRightShiftS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)>>B);return this},W.prototype.signPropagatingRightShiftM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)>>B.get(z,Y));return this},W.signPropagatingRightShift=function(B,z){return new O(B).signPropagatingRightShift(z)},W.prototype.rightShift=function(B){return typeof B=="number"?this.rightShiftS(B):this.rightShiftM(B)},W.prototype.rightShiftS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)>>>B);return this},W.prototype.rightShiftM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)>>>B.get(z,Y));return this},W.rightShift=function(B,z){return new O(B).rightShift(z)},W.prototype.zeroFillRightShift=W.prototype.rightShift,W.prototype.zeroFillRightShiftS=W.prototype.rightShiftS,W.prototype.zeroFillRightShiftM=W.prototype.rightShiftM,W.zeroFillRightShift=W.rightShift,W.prototype.not=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,~this.get(B,z));return this},W.not=function(B){return new O(B).not()},W.prototype.abs=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.abs(this.get(B,z)));return this},W.abs=function(B){return new O(B).abs()},W.prototype.acos=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.acos(this.get(B,z)));return this},W.acos=function(B){return new O(B).acos()},W.prototype.acosh=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.acosh(this.get(B,z)));return this},W.acosh=function(B){return new O(B).acosh()},W.prototype.asin=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.asin(this.get(B,z)));return this},W.asin=function(B){return new O(B).asin()},W.prototype.asinh=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.asinh(this.get(B,z)));return this},W.asinh=function(B){return new O(B).asinh()},W.prototype.atan=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.atan(this.get(B,z)));return this},W.atan=function(B){return new O(B).atan()},W.prototype.atanh=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.atanh(this.get(B,z)));return this},W.atanh=function(B){return new O(B).atanh()},W.prototype.cbrt=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.cbrt(this.get(B,z)));return this},W.cbrt=function(B){return new O(B).cbrt()},W.prototype.ceil=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.ceil(this.get(B,z)));return this},W.ceil=function(B){return new O(B).ceil()},W.prototype.clz32=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.clz32(this.get(B,z)));return this},W.clz32=function(B){return new O(B).clz32()},W.prototype.cos=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.cos(this.get(B,z)));return this},W.cos=function(B){return new O(B).cos()},W.prototype.cosh=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.cosh(this.get(B,z)));return this},W.cosh=function(B){return new O(B).cosh()},W.prototype.exp=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.exp(this.get(B,z)));return this},W.exp=function(B){return new O(B).exp()},W.prototype.expm1=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.expm1(this.get(B,z)));return this},W.expm1=function(B){return new O(B).expm1()},W.prototype.floor=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.floor(this.get(B,z)));return this},W.floor=function(B){return new O(B).floor()},W.prototype.fround=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.fround(this.get(B,z)));return this},W.fround=function(B){return new O(B).fround()},W.prototype.log=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.log(this.get(B,z)));return this},W.log=function(B){return new O(B).log()},W.prototype.log1p=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.log1p(this.get(B,z)));return this},W.log1p=function(B){return new O(B).log1p()},W.prototype.log10=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.log10(this.get(B,z)));return this},W.log10=function(B){return new O(B).log10()},W.prototype.log2=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.log2(this.get(B,z)));return this},W.log2=function(B){return new O(B).log2()},W.prototype.round=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.round(this.get(B,z)));return this},W.round=function(B){return new O(B).round()},W.prototype.sign=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.sign(this.get(B,z)));return this},W.sign=function(B){return new O(B).sign()},W.prototype.sin=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.sin(this.get(B,z)));return this},W.sin=function(B){return new O(B).sin()},W.prototype.sinh=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.sinh(this.get(B,z)));return this},W.sinh=function(B){return new O(B).sinh()},W.prototype.sqrt=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.sqrt(this.get(B,z)));return this},W.sqrt=function(B){return new O(B).sqrt()},W.prototype.tan=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.tan(this.get(B,z)));return this},W.tan=function(B){return new O(B).tan()},W.prototype.tanh=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.tanh(this.get(B,z)));return this},W.tanh=function(B){return new O(B).tanh()},W.prototype.trunc=function(){for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.set(B,z,Math.trunc(this.get(B,z)));return this},W.trunc=function(B){return new O(B).trunc()},W.pow=function(B,z){return new O(B).pow(z)},W.prototype.pow=function(B){return typeof B=="number"?this.powS(B):this.powM(B)},W.prototype.powS=function(B){for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)**B);return this},W.prototype.powM=function(B){if(B=O.checkMatrix(B),this.rows!==B.rows||this.columns!==B.columns)throw new RangeError("Matrices dimensions must be equal");for(let z=0;z<this.rows;z++)for(let Y=0;Y<this.columns;Y++)this.set(z,Y,this.get(z,Y)**B.get(z,Y));return this}}function Z(W,O,V){let B=V?W.rows:W.rows-1;if(O<0||O>B)throw new RangeError("Row index out of range")}function K(W,O,V){let B=V?W.columns:W.columns-1;if(O<0||O>B)throw new RangeError("Column index out of range")}function J(W,O){if(O.to1DArray&&(O=O.to1DArray()),O.length!==W.columns)throw new RangeError("vector size must be the same as the number of columns");return O}function Q(W,O){if(O.to1DArray&&(O=O.to1DArray()),O.length!==W.rows)throw new RangeError("vector size must be the same as the number of rows");return O}function ht(W,O){if(!_.isAnyArray(O))throw new TypeError("row indices must be an array");for(let V=0;V<O.length;V++)if(O[V]<0||O[V]>=W.rows)throw new RangeError("row indices are out of range")}function Et(W,O){if(!_.isAnyArray(O))throw new TypeError("column indices must be an array");for(let V=0;V<O.length;V++)if(O[V]<0||O[V]>=W.columns)throw new RangeError("column indices are out of range")}function xt(W,O,V,B,z){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(bt("startRow",O),bt("endRow",V),bt("startColumn",B),bt("endColumn",z),O>V||B>z||O<0||O>=W.rows||V<0||V>=W.rows||B<0||B>=W.columns||z<0||z>=W.columns)throw new RangeError("Submatrix indices are out of range")}function gt(W,O=0){let V=[];for(let B=0;B<W;B++)V.push(O);return V}function bt(W,O){if(typeof O!="number")throw new TypeError(`${W} must be a number`)}function rt(W){if(W.isEmpty())throw new Error("Empty matrix has no elements to index")}function tt(W){let O=gt(W.rows);for(let V=0;V<W.rows;++V)for(let B=0;B<W.columns;++B)O[V]+=W.get(V,B);return O}function at(W){let O=gt(W.columns);for(let V=0;V<W.rows;++V)for(let B=0;B<W.columns;++B)O[B]+=W.get(V,B);return O}function wt(W){let O=0;for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)O+=W.get(V,B);return O}function yt(W){let O=gt(W.rows,1);for(let V=0;V<W.rows;++V)for(let B=0;B<W.columns;++B)O[V]*=W.get(V,B);return O}function lt(W){let O=gt(W.columns,1);for(let V=0;V<W.rows;++V)for(let B=0;B<W.columns;++B)O[B]*=W.get(V,B);return O}function ct(W){let O=1;for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)O*=W.get(V,B);return O}function ut(W,O,V){const B=W.rows,z=W.columns,Y=[];for(let nt=0;nt<B;nt++){let it=0,ot=0,st=0;for(let vt=0;vt<z;vt++)st=W.get(nt,vt)-V[nt],it+=st,ot+=st*st;O?Y.push((ot-it*it/z)/(z-1)):Y.push((ot-it*it/z)/z)}return Y}function dt(W,O,V){const B=W.rows,z=W.columns,Y=[];for(let nt=0;nt<z;nt++){let it=0,ot=0,st=0;for(let vt=0;vt<B;vt++)st=W.get(vt,nt)-V[nt],it+=st,ot+=st*st;O?Y.push((ot-it*it/B)/(B-1)):Y.push((ot-it*it/B)/B)}return Y}function _t(W,O,V){const B=W.rows,z=W.columns,Y=B*z;let nt=0,it=0,ot=0;for(let st=0;st<B;st++)for(let vt=0;vt<z;vt++)ot=W.get(st,vt)-V,nt+=ot,it+=ot*ot;return O?(it-nt*nt/Y)/(Y-1):(it-nt*nt/Y)/Y}function Ft(W,O){for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)W.set(V,B,W.get(V,B)-O[V])}function Pt(W,O){for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)W.set(V,B,W.get(V,B)-O[B])}function Ot(W,O){for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)W.set(V,B,W.get(V,B)-O)}function ne(W){const O=[];for(let V=0;V<W.rows;V++){let B=0;for(let z=0;z<W.columns;z++)B+=W.get(V,z)**2/(W.columns-1);O.push(Math.sqrt(B))}return O}function he(W,O){for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)W.set(V,B,W.get(V,B)/O[V])}function Xt(W){const O=[];for(let V=0;V<W.columns;V++){let B=0;for(let z=0;z<W.rows;z++)B+=W.get(z,V)**2/(W.rows-1);O.push(Math.sqrt(B))}return O}function Wt(W,O){for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)W.set(V,B,W.get(V,B)/O[B])}function Kt(W){const O=W.size-1;let V=0;for(let B=0;B<W.columns;B++)for(let z=0;z<W.rows;z++)V+=W.get(z,B)**2/O;return Math.sqrt(V)}function de(W,O){for(let V=0;V<W.rows;V++)for(let B=0;B<W.columns;B++)W.set(V,B,W.get(V,B)/O)}class Ct{static from1DArray(O,V,B){if(O*V!==B.length)throw new RangeError("data length does not match given dimensions");let Y=new Mt(O,V);for(let nt=0;nt<O;nt++)for(let it=0;it<V;it++)Y.set(nt,it,B[nt*V+it]);return Y}static rowVector(O){let V=new Mt(1,O.length);for(let B=0;B<O.length;B++)V.set(0,B,O[B]);return V}static columnVector(O){let V=new Mt(O.length,1);for(let B=0;B<O.length;B++)V.set(B,0,O[B]);return V}static zeros(O,V){return new Mt(O,V)}static ones(O,V){return new Mt(O,V).fill(1)}static rand(O,V,B={}){if(typeof B!="object")throw new TypeError("options must be an object");const{random:z=Math.random}=B;let Y=new Mt(O,V);for(let nt=0;nt<O;nt++)for(let it=0;it<V;it++)Y.set(nt,it,z());return Y}static randInt(O,V,B={}){if(typeof B!="object")throw new TypeError("options must be an object");const{min:z=0,max:Y=1e3,random:nt=Math.random}=B;if(!Number.isInteger(z))throw new TypeError("min must be an integer");if(!Number.isInteger(Y))throw new TypeError("max must be an integer");if(z>=Y)throw new RangeError("min must be smaller than max");let it=Y-z,ot=new Mt(O,V);for(let st=0;st<O;st++)for(let vt=0;vt<V;vt++){let ft=z+Math.round(nt()*it);ot.set(st,vt,ft)}return ot}static eye(O,V,B){V===void 0&&(V=O),B===void 0&&(B=1);let z=Math.min(O,V),Y=this.zeros(O,V);for(let nt=0;nt<z;nt++)Y.set(nt,nt,B);return Y}static diag(O,V,B){let z=O.length;V===void 0&&(V=z),B===void 0&&(B=V);let Y=Math.min(z,V,B),nt=this.zeros(V,B);for(let it=0;it<Y;it++)nt.set(it,it,O[it]);return nt}static min(O,V){O=this.checkMatrix(O),V=this.checkMatrix(V);let B=O.rows,z=O.columns,Y=new Mt(B,z);for(let nt=0;nt<B;nt++)for(let it=0;it<z;it++)Y.set(nt,it,Math.min(O.get(nt,it),V.get(nt,it)));return Y}static max(O,V){O=this.checkMatrix(O),V=this.checkMatrix(V);let B=O.rows,z=O.columns,Y=new this(B,z);for(let nt=0;nt<B;nt++)for(let it=0;it<z;it++)Y.set(nt,it,Math.max(O.get(nt,it),V.get(nt,it)));return Y}static checkMatrix(O){return Ct.isMatrix(O)?O:new Mt(O)}static isMatrix(O){return O!=null&&O.klass==="Matrix"}get size(){return this.rows*this.columns}apply(O){if(typeof O!="function")throw new TypeError("callback must be a function");for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)O.call(this,V,B);return this}to1DArray(){let O=[];for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)O.push(this.get(V,B));return O}to2DArray(){let O=[];for(let V=0;V<this.rows;V++){O.push([]);for(let B=0;B<this.columns;B++)O[V].push(this.get(V,B))}return O}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let O=0;O<this.rows;O++)for(let V=0;V<=O;V++)if(this.get(O,V)!==this.get(V,O))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let O=0;O<this.rows;O++)if(this.get(O,O)!==0)return!1;return!0}isEchelonForm(){let O=0,V=0,B=-1,z=!0,Y=!1;for(;O<this.rows&&z;){for(V=0,Y=!1;V<this.columns&&Y===!1;)this.get(O,V)===0?V++:this.get(O,V)===1&&V>B?(Y=!0,B=V):(z=!1,Y=!0);O++}return z}isReducedEchelonForm(){let O=0,V=0,B=-1,z=!0,Y=!1;for(;O<this.rows&&z;){for(V=0,Y=!1;V<this.columns&&Y===!1;)this.get(O,V)===0?V++:this.get(O,V)===1&&V>B?(Y=!0,B=V):(z=!1,Y=!0);for(let nt=V+1;nt<this.rows;nt++)this.get(O,nt)!==0&&(z=!1);O++}return z}echelonForm(){let O=this.clone(),V=0,B=0;for(;V<O.rows&&B<O.columns;){let z=V;for(let Y=V;Y<O.rows;Y++)O.get(Y,B)>O.get(z,B)&&(z=Y);if(O.get(z,B)===0)B++;else{O.swapRows(V,z);let Y=O.get(V,B);for(let nt=B;nt<O.columns;nt++)O.set(V,nt,O.get(V,nt)/Y);for(let nt=V+1;nt<O.rows;nt++){let it=O.get(nt,B)/O.get(V,B);O.set(nt,B,0);for(let ot=B+1;ot<O.columns;ot++)O.set(nt,ot,O.get(nt,ot)-O.get(V,ot)*it)}V++,B++}}return O}reducedEchelonForm(){let O=this.echelonForm(),V=O.columns,B=O.rows,z=B-1;for(;z>=0;)if(O.maxRow(z)===0)z--;else{let Y=0,nt=!1;for(;Y<B&&nt===!1;)O.get(z,Y)===1?nt=!0:Y++;for(let it=0;it<z;it++){let ot=O.get(it,Y);for(let st=Y;st<V;st++){let vt=O.get(it,st)-ot*O.get(z,st);O.set(it,st,vt)}}z--}return O}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(O={}){if(typeof O!="object")throw new TypeError("options must be an object");const{rows:V=1,columns:B=1}=O;if(!Number.isInteger(V)||V<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(B)||B<=0)throw new TypeError("columns must be a positive integer");let z=new Mt(this.rows*V,this.columns*B);for(let Y=0;Y<V;Y++)for(let nt=0;nt<B;nt++)z.setSubMatrix(this,this.rows*Y,this.columns*nt);return z}fill(O){for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,O);return this}neg(){return this.mulS(-1)}getRow(O){Z(this,O);let V=[];for(let B=0;B<this.columns;B++)V.push(this.get(O,B));return V}getRowVector(O){return Mt.rowVector(this.getRow(O))}setRow(O,V){Z(this,O),V=J(this,V);for(let B=0;B<this.columns;B++)this.set(O,B,V[B]);return this}swapRows(O,V){Z(this,O),Z(this,V);for(let B=0;B<this.columns;B++){let z=this.get(O,B);this.set(O,B,this.get(V,B)),this.set(V,B,z)}return this}getColumn(O){K(this,O);let V=[];for(let B=0;B<this.rows;B++)V.push(this.get(B,O));return V}getColumnVector(O){return Mt.columnVector(this.getColumn(O))}setColumn(O,V){K(this,O),V=Q(this,V);for(let B=0;B<this.rows;B++)this.set(B,O,V[B]);return this}swapColumns(O,V){K(this,O),K(this,V);for(let B=0;B<this.rows;B++){let z=this.get(B,O);this.set(B,O,this.get(B,V)),this.set(B,V,z)}return this}addRowVector(O){O=J(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)+O[B]);return this}subRowVector(O){O=J(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)-O[B]);return this}mulRowVector(O){O=J(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)*O[B]);return this}divRowVector(O){O=J(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)/O[B]);return this}addColumnVector(O){O=Q(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)+O[V]);return this}subColumnVector(O){O=Q(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)-O[V]);return this}mulColumnVector(O){O=Q(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)*O[V]);return this}divColumnVector(O){O=Q(this,O);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)this.set(V,B,this.get(V,B)/O[V]);return this}mulRow(O,V){Z(this,O);for(let B=0;B<this.columns;B++)this.set(O,B,this.get(O,B)*V);return this}mulColumn(O,V){K(this,O);for(let B=0;B<this.rows;B++)this.set(B,O,this.get(B,O)*V);return this}max(O){if(this.isEmpty())return NaN;switch(O){case"row":{const V=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)>V[B]&&(V[B]=this.get(B,z));return V}case"column":{const V=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)>V[z]&&(V[z]=this.get(B,z));return V}case void 0:{let V=this.get(0,0);for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)>V&&(V=this.get(B,z));return V}default:throw new Error(`invalid option: ${O}`)}}maxIndex(){rt(this);let O=this.get(0,0),V=[0,0];for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)>O&&(O=this.get(B,z),V[0]=B,V[1]=z);return V}min(O){if(this.isEmpty())return NaN;switch(O){case"row":{const V=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)<V[B]&&(V[B]=this.get(B,z));return V}case"column":{const V=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)<V[z]&&(V[z]=this.get(B,z));return V}case void 0:{let V=this.get(0,0);for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)<V&&(V=this.get(B,z));return V}default:throw new Error(`invalid option: ${O}`)}}minIndex(){rt(this);let O=this.get(0,0),V=[0,0];for(let B=0;B<this.rows;B++)for(let z=0;z<this.columns;z++)this.get(B,z)<O&&(O=this.get(B,z),V[0]=B,V[1]=z);return V}maxRow(O){if(Z(this,O),this.isEmpty())return NaN;let V=this.get(O,0);for(let B=1;B<this.columns;B++)this.get(O,B)>V&&(V=this.get(O,B));return V}maxRowIndex(O){Z(this,O),rt(this);let V=this.get(O,0),B=[O,0];for(let z=1;z<this.columns;z++)this.get(O,z)>V&&(V=this.get(O,z),B[1]=z);return B}minRow(O){if(Z(this,O),this.isEmpty())return NaN;let V=this.get(O,0);for(let B=1;B<this.columns;B++)this.get(O,B)<V&&(V=this.get(O,B));return V}minRowIndex(O){Z(this,O),rt(this);let V=this.get(O,0),B=[O,0];for(let z=1;z<this.columns;z++)this.get(O,z)<V&&(V=this.get(O,z),B[1]=z);return B}maxColumn(O){if(K(this,O),this.isEmpty())return NaN;let V=this.get(0,O);for(let B=1;B<this.rows;B++)this.get(B,O)>V&&(V=this.get(B,O));return V}maxColumnIndex(O){K(this,O),rt(this);let V=this.get(0,O),B=[0,O];for(let z=1;z<this.rows;z++)this.get(z,O)>V&&(V=this.get(z,O),B[0]=z);return B}minColumn(O){if(K(this,O),this.isEmpty())return NaN;let V=this.get(0,O);for(let B=1;B<this.rows;B++)this.get(B,O)<V&&(V=this.get(B,O));return V}minColumnIndex(O){K(this,O),rt(this);let V=this.get(0,O),B=[0,O];for(let z=1;z<this.rows;z++)this.get(z,O)<V&&(V=this.get(z,O),B[0]=z);return B}diag(){let O=Math.min(this.rows,this.columns),V=[];for(let B=0;B<O;B++)V.push(this.get(B,B));return V}norm(O="frobenius"){switch(O){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${O}`)}}cumulativeSum(){let O=0;for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)O+=this.get(V,B),this.set(V,B,O);return this}dot(O){Ct.isMatrix(O)&&(O=O.to1DArray());let V=this.to1DArray();if(V.length!==O.length)throw new RangeError("vectors do not have the same size");let B=0;for(let z=0;z<V.length;z++)B+=V[z]*O[z];return B}mmul(O){O=Mt.checkMatrix(O);let V=this.rows,B=this.columns,z=O.columns,Y=new Mt(V,z),nt=new Float64Array(B);for(let it=0;it<z;it++){for(let ot=0;ot<B;ot++)nt[ot]=O.get(ot,it);for(let ot=0;ot<V;ot++){let st=0;for(let vt=0;vt<B;vt++)st+=this.get(ot,vt)*nt[vt];Y.set(ot,it,st)}}return Y}mpow(O){if(!this.isSquare())throw new RangeError("Matrix must be square");if(!Number.isInteger(O)||O<0)throw new RangeError("Exponent must be a non-negative integer");let V=Mt.eye(this.rows),B=this;for(let z=O;z>=1;z/=2)(z&1)!==0&&(V=V.mmul(B)),B=B.mmul(B);return V}strassen2x2(O){O=Mt.checkMatrix(O);let V=new Mt(2,2);const B=this.get(0,0),z=O.get(0,0),Y=this.get(0,1),nt=O.get(0,1),it=this.get(1,0),ot=O.get(1,0),st=this.get(1,1),vt=O.get(1,1),ft=(B+st)*(z+vt),Rt=(it+st)*z,Bt=B*(nt-vt),St=st*(ot-z),kt=(B+Y)*vt,Nt=(it-B)*(z+nt),pt=(Y-st)*(ot+vt),$t=ft+St-kt+pt,Lt=Bt+kt,ie=Rt+St,le=ft-Rt+Bt+Nt;return V.set(0,0,$t),V.set(0,1,Lt),V.set(1,0,ie),V.set(1,1,le),V}strassen3x3(O){O=Mt.checkMatrix(O);let V=new Mt(3,3);const B=this.get(0,0),z=this.get(0,1),Y=this.get(0,2),nt=this.get(1,0),it=this.get(1,1),ot=this.get(1,2),st=this.get(2,0),vt=this.get(2,1),ft=this.get(2,2),Rt=O.get(0,0),Bt=O.get(0,1),St=O.get(0,2),kt=O.get(1,0),Nt=O.get(1,1),pt=O.get(1,2),$t=O.get(2,0),Lt=O.get(2,1),ie=O.get(2,2),le=(B+z+Y-nt-it-vt-ft)*Nt,Ae=(B-nt)*(-Bt+Nt),Ht=it*(-Rt+Bt+kt-Nt-pt-$t+ie),ee=(-B+nt+it)*(Rt-Bt+Nt),ke=(nt+it)*(-Rt+Bt),mt=B*Rt,Tt=(-B+st+vt)*(Rt-St+pt),Vt=(-B+st)*(St-pt),At=(st+vt)*(-Rt+St),Ce=(B+z+Y-it-ot-st-vt)*pt,Te=vt*(-Rt+St+kt-Nt-pt-$t+Lt),$e=(-Y+vt+ft)*(Nt+$t-Lt),Pe=(Y-ft)*(Nt-Lt),Ne=Y*$t,Ge=(vt+ft)*(-$t+Lt),Fe=(-Y+it+ot)*(pt+$t-ie),qe=(Y-ot)*(pt-ie),Xe=(it+ot)*(-$t+ie),Se=z*kt,Ve=ot*Lt,Ue=nt*St,je=st*Bt,Oe=ft*ie,We=mt+Ne+Se,Ke=le+ee+ke+mt+$e+Ne+Ge,Qe=mt+Tt+At+Ce+Ne+Fe+Xe,Je=Ae+Ht+ee+mt+Ne+Fe+qe,He=Ae+ee+ke+mt+Ve,tr=Ne+Fe+qe+Xe+Ue,er=mt+Tt+Vt+Te+$e+Pe+Ne,rr=$e+Pe+Ne+Ge+je,nr=mt+Tt+Vt+At+Oe;return V.set(0,0,We),V.set(0,1,Ke),V.set(0,2,Qe),V.set(1,0,Je),V.set(1,1,He),V.set(1,2,tr),V.set(2,0,er),V.set(2,1,rr),V.set(2,2,nr),V}mmulStrassen(O){O=Mt.checkMatrix(O);let V=this.clone(),B=V.rows,z=V.columns,Y=O.rows,nt=O.columns;z!==Y&&console.warn(`Multiplying ${B} x ${z} and ${Y} x ${nt} matrix: dimensions do not match.`);function it(ft,Rt,Bt){let St=ft.rows,kt=ft.columns;if(St===Rt&&kt===Bt)return ft;{let Nt=Ct.zeros(Rt,Bt);return Nt=Nt.setSubMatrix(ft,0,0),Nt}}let ot=Math.max(B,Y),st=Math.max(z,nt);V=it(V,ot,st),O=it(O,ot,st);function vt(ft,Rt,Bt,St){if(Bt<=512||St<=512)return ft.mmul(Rt);Bt%2===1&&St%2===1?(ft=it(ft,Bt+1,St+1),Rt=it(Rt,Bt+1,St+1)):Bt%2===1?(ft=it(ft,Bt+1,St),Rt=it(Rt,Bt+1,St)):St%2===1&&(ft=it(ft,Bt,St+1),Rt=it(Rt,Bt,St+1));let kt=parseInt(ft.rows/2,10),Nt=parseInt(ft.columns/2,10),pt=ft.subMatrix(0,kt-1,0,Nt-1),$t=Rt.subMatrix(0,kt-1,0,Nt-1),Lt=ft.subMatrix(0,kt-1,Nt,ft.columns-1),ie=Rt.subMatrix(0,kt-1,Nt,Rt.columns-1),le=ft.subMatrix(kt,ft.rows-1,0,Nt-1),Ae=Rt.subMatrix(kt,Rt.rows-1,0,Nt-1),Ht=ft.subMatrix(kt,ft.rows-1,Nt,ft.columns-1),ee=Rt.subMatrix(kt,Rt.rows-1,Nt,Rt.columns-1),ke=vt(Ct.add(pt,Ht),Ct.add($t,ee),kt,Nt),mt=vt(Ct.add(le,Ht),$t,kt,Nt),Tt=vt(pt,Ct.sub(ie,ee),kt,Nt),Vt=vt(Ht,Ct.sub(Ae,$t),kt,Nt),At=vt(Ct.add(pt,Lt),ee,kt,Nt),Ce=vt(Ct.sub(le,pt),Ct.add($t,ie),kt,Nt),Te=vt(Ct.sub(Lt,Ht),Ct.add(Ae,ee),kt,Nt),$e=Ct.add(ke,Vt);$e.sub(At),$e.add(Te);let Pe=Ct.add(Tt,At),Ne=Ct.add(mt,Vt),Ge=Ct.sub(ke,mt);Ge.add(Tt),Ge.add(Ce);let Fe=Ct.zeros(2*$e.rows,2*$e.columns);return Fe=Fe.setSubMatrix($e,0,0),Fe=Fe.setSubMatrix(Pe,$e.rows,0),Fe=Fe.setSubMatrix(Ne,0,$e.columns),Fe=Fe.setSubMatrix(Ge,$e.rows,$e.columns),Fe.subMatrix(0,Bt-1,0,St-1)}return vt(V,O,ot,st)}scaleRows(O={}){if(typeof O!="object")throw new TypeError("options must be an object");const{min:V=0,max:B=1}=O;if(!Number.isFinite(V))throw new TypeError("min must be a number");if(!Number.isFinite(B))throw new TypeError("max must be a number");if(V>=B)throw new RangeError("min must be smaller than max");let z=new Mt(this.rows,this.columns);for(let Y=0;Y<this.rows;Y++){const nt=this.getRow(Y);nt.length>0&&E(nt,{min:V,max:B,output:nt}),z.setRow(Y,nt)}return z}scaleColumns(O={}){if(typeof O!="object")throw new TypeError("options must be an object");const{min:V=0,max:B=1}=O;if(!Number.isFinite(V))throw new TypeError("min must be a number");if(!Number.isFinite(B))throw new TypeError("max must be a number");if(V>=B)throw new RangeError("min must be smaller than max");let z=new Mt(this.rows,this.columns);for(let Y=0;Y<this.columns;Y++){const nt=this.getColumn(Y);nt.length&&E(nt,{min:V,max:B,output:nt}),z.setColumn(Y,nt)}return z}flipRows(){const O=Math.ceil(this.columns/2);for(let V=0;V<this.rows;V++)for(let B=0;B<O;B++){let z=this.get(V,B),Y=this.get(V,this.columns-1-B);this.set(V,B,Y),this.set(V,this.columns-1-B,z)}return this}flipColumns(){const O=Math.ceil(this.rows/2);for(let V=0;V<this.columns;V++)for(let B=0;B<O;B++){let z=this.get(B,V),Y=this.get(this.rows-1-B,V);this.set(B,V,Y),this.set(this.rows-1-B,V,z)}return this}kroneckerProduct(O){O=Mt.checkMatrix(O);let V=this.rows,B=this.columns,z=O.rows,Y=O.columns,nt=new Mt(V*z,B*Y);for(let it=0;it<V;it++)for(let ot=0;ot<B;ot++)for(let st=0;st<z;st++)for(let vt=0;vt<Y;vt++)nt.set(z*it+st,Y*ot+vt,this.get(it,ot)*O.get(st,vt));return nt}kroneckerSum(O){if(O=Mt.checkMatrix(O),!this.isSquare()||!O.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let V=this.rows,B=O.rows,z=this.kroneckerProduct(Mt.eye(B,B)),Y=Mt.eye(V,V).kroneckerProduct(O);return z.add(Y)}transpose(){let O=new Mt(this.columns,this.rows);for(let V=0;V<this.rows;V++)for(let B=0;B<this.columns;B++)O.set(B,V,this.get(V,B));return O}sortRows(O=te){for(let V=0;V<this.rows;V++)this.setRow(V,this.getRow(V).sort(O));return this}sortColumns(O=te){for(let V=0;V<this.columns;V++)this.setColumn(V,this.getColumn(V).sort(O));return this}subMatrix(O,V,B,z){xt(this,O,V,B,z);let Y=new Mt(V-O+1,z-B+1);for(let nt=O;nt<=V;nt++)for(let it=B;it<=z;it++)Y.set(nt-O,it-B,this.get(nt,it));return Y}subMatrixRow(O,V,B){if(V===void 0&&(V=0),B===void 0&&(B=this.columns-1),V>B||V<0||V>=this.columns||B<0||B>=this.columns)throw new RangeError("Argument out of range");let z=new Mt(O.length,B-V+1);for(let Y=0;Y<O.length;Y++)for(let nt=V;nt<=B;nt++){if(O[Y]<0||O[Y]>=this.rows)throw new RangeError(`Row index out of range: ${O[Y]}`);z.set(Y,nt-V,this.get(O[Y],nt))}return z}subMatrixColumn(O,V,B){if(V===void 0&&(V=0),B===void 0&&(B=this.rows-1),V>B||V<0||V>=this.rows||B<0||B>=this.rows)throw new RangeError("Argument out of range");let z=new Mt(B-V+1,O.length);for(let Y=0;Y<O.length;Y++)for(let nt=V;nt<=B;nt++){if(O[Y]<0||O[Y]>=this.columns)throw new RangeError(`Column index out of range: ${O[Y]}`);z.set(nt-V,Y,this.get(nt,O[Y]))}return z}setSubMatrix(O,V,B){if(O=Mt.checkMatrix(O),O.isEmpty())return this;let z=V+O.rows-1,Y=B+O.columns-1;xt(this,V,z,B,Y);for(let nt=0;nt<O.rows;nt++)for(let it=0;it<O.columns;it++)this.set(V+nt,B+it,O.get(nt,it));return this}selection(O,V){ht(this,O),Et(this,V);let B=new Mt(O.length,V.length);for(let z=0;z<O.length;z++){let Y=O[z];for(let nt=0;nt<V.length;nt++){let it=V[nt];B.set(z,nt,this.get(Y,it))}}return B}trace(){let O=Math.min(this.rows,this.columns),V=0;for(let B=0;B<O;B++)V+=this.get(B,B);return V}clone(){return this.constructor.copy(this,new Mt(this.rows,this.columns))}static copy(O,V){for(const[B,z,Y]of O.entries())V.set(B,z,Y);return V}sum(O){switch(O){case"row":return tt(this);case"column":return at(this);case void 0:return wt(this);default:throw new Error(`invalid option: ${O}`)}}product(O){switch(O){case"row":return yt(this);case"column":return lt(this);case void 0:return ct(this);default:throw new Error(`invalid option: ${O}`)}}mean(O){const V=this.sum(O);switch(O){case"row":{for(let B=0;B<this.rows;B++)V[B]/=this.columns;return V}case"column":{for(let B=0;B<this.columns;B++)V[B]/=this.rows;return V}case void 0:return V/this.size;default:throw new Error(`invalid option: ${O}`)}}variance(O,V={}){if(typeof O=="object"&&(V=O,O=void 0),typeof V!="object")throw new TypeError("options must be an object");const{unbiased:B=!0,mean:z=this.mean(O)}=V;if(typeof B!="boolean")throw new TypeError("unbiased must be a boolean");switch(O){case"row":{if(!_.isAnyArray(z))throw new TypeError("mean must be an array");return ut(this,B,z)}case"column":{if(!_.isAnyArray(z))throw new TypeError("mean must be an array");return dt(this,B,z)}case void 0:{if(typeof z!="number")throw new TypeError("mean must be a number");return _t(this,B,z)}default:throw new Error(`invalid option: ${O}`)}}standardDeviation(O,V){typeof O=="object"&&(V=O,O=void 0);const B=this.variance(O,V);if(O===void 0)return Math.sqrt(B);for(let z=0;z<B.length;z++)B[z]=Math.sqrt(B[z]);return B}center(O,V={}){if(typeof O=="object"&&(V=O,O=void 0),typeof V!="object")throw new TypeError("options must be an object");const{center:B=this.mean(O)}=V;switch(O){case"row":{if(!_.isAnyArray(B))throw new TypeError("center must be an array");return Ft(this,B),this}case"column":{if(!_.isAnyArray(B))throw new TypeError("center must be an array");return Pt(this,B),this}case void 0:{if(typeof B!="number")throw new TypeError("center must be a number");return Ot(this,B),this}default:throw new Error(`invalid option: ${O}`)}}scale(O,V={}){if(typeof O=="object"&&(V=O,O=void 0),typeof V!="object")throw new TypeError("options must be an object");let B=V.scale;switch(O){case"row":{if(B===void 0)B=ne(this);else if(!_.isAnyArray(B))throw new TypeError("scale must be an array");return he(this,B),this}case"column":{if(B===void 0)B=Xt(this);else if(!_.isAnyArray(B))throw new TypeError("scale must be an array");return Wt(this,B),this}case void 0:{if(B===void 0)B=Kt(this);else if(typeof B!="number")throw new TypeError("scale must be a number");return de(this,B),this}default:throw new Error(`invalid option: ${O}`)}}toString(O){return D(this,O)}[Symbol.iterator](){return this.entries()}*entries(){for(let O=0;O<this.rows;O++)for(let V=0;V<this.columns;V++)yield[O,V,this.get(O,V)]}*values(){for(let O=0;O<this.rows;O++)for(let V=0;V<this.columns;V++)yield this.get(O,V)}}Ct.prototype.klass="Matrix",typeof Symbol<"u"&&(Ct.prototype[Symbol.for("nodejs.util.inspect.custom")]=P);function te(W,O){return W-O}function jt(W){return W.every(O=>typeof O=="number")}Ct.random=Ct.rand,Ct.randomInt=Ct.randInt,Ct.diagonal=Ct.diag,Ct.prototype.diagonal=Ct.prototype.diag,Ct.identity=Ct.eye,Ct.prototype.negate=Ct.prototype.neg,Ct.prototype.tensorProduct=Ct.prototype.kroneckerProduct;class Mt extends Ct{data;#t(O,V){if(this.data=[],Number.isInteger(V)&&V>=0)for(let B=0;B<O;B++)this.data.push(new Float64Array(V));else throw new TypeError("nColumns must be a positive integer");this.rows=O,this.columns=V}constructor(O,V){if(super(),Mt.isMatrix(O))this.#t(O.rows,O.columns),Mt.copy(O,this);else if(Number.isInteger(O)&&O>=0)this.#t(O,V);else if(_.isAnyArray(O)){const B=O;if(O=B.length,V=O?B[0].length:0,typeof V!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let z=0;z<O;z++){if(B[z].length!==V)throw new RangeError("Inconsistent array dimensions");if(!jt(B[z]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(B[z]))}this.rows=O,this.columns=V}else throw new TypeError("First argument must be a positive number or an array")}set(O,V,B){return this.data[O][V]=B,this}get(O,V){return this.data[O][V]}removeRow(O){return Z(this,O),this.data.splice(O,1),this.rows-=1,this}addRow(O,V){return V===void 0&&(V=O,O=this.rows),Z(this,O,!0),V=Float64Array.from(J(this,V)),this.data.splice(O,0,V),this.rows+=1,this}removeColumn(O){K(this,O);for(let V=0;V<this.rows;V++){const B=new Float64Array(this.columns-1);for(let z=0;z<O;z++)B[z]=this.data[V][z];for(let z=O+1;z<this.columns;z++)B[z-1]=this.data[V][z];this.data[V]=B}return this.columns-=1,this}addColumn(O,V){typeof V>"u"&&(V=O,O=this.columns),K(this,O,!0),V=Q(this,V);for(let B=0;B<this.rows;B++){const z=new Float64Array(this.columns+1);let Y=0;for(;Y<O;Y++)z[Y]=this.data[B][Y];for(z[Y++]=V[B];Y<this.columns+1;Y++)z[Y]=this.data[B][Y-1];this.data[B]=z}return this.columns+=1,this}}q(Ct,Mt);class qt extends Ct{#t;get size(){return this.#t.size}get rows(){return this.#t.rows}get columns(){return this.#t.columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(O){return Mt.isMatrix(O)&&O.klassType==="SymmetricMatrix"}static zeros(O){return new this(O)}static ones(O){return new this(O).fill(1)}constructor(O){if(super(),Mt.isMatrix(O)){if(!O.isSymmetric())throw new TypeError("not symmetric data");this.#t=Mt.copy(O,new Mt(O.rows,O.rows))}else if(Number.isInteger(O)&&O>=0)this.#t=new Mt(O,O);else if(this.#t=new Mt(O),!this.isSymmetric())throw new TypeError("not symmetric data")}clone(){const O=new qt(this.diagonalSize);for(const[V,B,z]of this.upperRightEntries())O.set(V,B,z);return O}toMatrix(){return new Mt(this)}get(O,V){return this.#t.get(O,V)}set(O,V,B){return this.#t.set(O,V,B),this.#t.set(V,O,B),this}removeCross(O){return this.#t.removeRow(O),this.#t.removeColumn(O),this}addCross(O,V){V===void 0&&(V=O,O=this.diagonalSize);const B=V.slice();return B.splice(O,1),this.#t.addRow(O,B),this.#t.addColumn(O,V),this}applyMask(O){if(O.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");const V=[];for(const[B,z]of O.entries())z||V.push(B);V.reverse();for(const B of V)this.removeCross(B);return this}toCompact(){const{diagonalSize:O}=this,V=new Array(O*(O+1)/2);for(let B=0,z=0,Y=0;Y<V.length;Y++)V[Y]=this.get(z,B),++B>=O&&(B=++z);return V}static fromCompact(O){const V=O.length,B=(Math.sqrt(8*V+1)-1)/2;if(!Number.isInteger(B))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(O)}`);const z=new qt(B);for(let Y=0,nt=0,it=0;it<V;it++)z.set(Y,nt,O[it]),++Y>=B&&(Y=++nt);return z}*upperRightEntries(){for(let O=0,V=0;O<this.diagonalSize;void 0){const B=this.get(O,V);yield[O,V,B],++V>=this.diagonalSize&&(V=++O)}}*upperRightValues(){for(let O=0,V=0;O<this.diagonalSize;void 0)yield this.get(O,V),++V>=this.diagonalSize&&(V=++O)}}qt.prototype.klassType="SymmetricMatrix";class oe extends qt{static isDistanceMatrix(O){return qt.isSymmetricMatrix(O)&&O.klassSubType==="DistanceMatrix"}constructor(O){if(super(O),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(O,V,B){return O===V&&(B=0),super.set(O,V,B)}addCross(O,V){return V===void 0&&(V=O,O=this.diagonalSize),V=V.slice(),V[O]=0,super.addCross(O,V)}toSymmetricMatrix(){return new qt(this)}clone(){const O=new oe(this.diagonalSize);for(const[V,B,z]of this.upperRightEntries())V!==B&&O.set(V,B,z);return O}toCompact(){const{diagonalSize:O}=this,V=(O-1)*O/2,B=new Array(V);for(let z=1,Y=0,nt=0;nt<B.length;nt++)B[nt]=this.get(Y,z),++z>=O&&(z=++Y+1);return B}static fromCompact(O){const V=O.length;if(V===0)return new this(0);const B=(Math.sqrt(8*V+1)+1)/2;if(!Number.isInteger(B))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(O)}`);const z=new this(B);for(let Y=1,nt=0,it=0;it<V;it++)z.set(Y,nt,O[it]),++Y>=B&&(Y=++nt+1);return z}}oe.prototype.klassSubType="DistanceMatrix";class se extends Ct{constructor(O,V,B){super(),this.matrix=O,this.rows=V,this.columns=B}}class ue extends se{constructor(O,V){K(O,V),super(O,O.rows,1),this.column=V}set(O,V,B){return this.matrix.set(O,this.column,B),this}get(O){return this.matrix.get(O,this.column)}}class ye extends se{constructor(O,V){Et(O,V),super(O,O.rows,V.length),this.columnIndices=V}set(O,V,B){return this.matrix.set(O,this.columnIndices[V],B),this}get(O,V){return this.matrix.get(O,this.columnIndices[V])}}class pe extends se{constructor(O){super(O,O.rows,O.columns)}set(O,V,B){return this.matrix.set(O,this.columns-V-1,B),this}get(O,V){return this.matrix.get(O,this.columns-V-1)}}class Ee extends se{constructor(O){super(O,O.rows,O.columns)}set(O,V,B){return this.matrix.set(this.rows-O-1,V,B),this}get(O,V){return this.matrix.get(this.rows-O-1,V)}}class we extends se{constructor(O,V){Z(O,V),super(O,1,O.columns),this.row=V}set(O,V,B){return this.matrix.set(this.row,V,B),this}get(O,V){return this.matrix.get(this.row,V)}}class zt extends se{constructor(O,V){ht(O,V),super(O,V.length,O.columns),this.rowIndices=V}set(O,V,B){return this.matrix.set(this.rowIndices[O],V,B),this}get(O,V){return this.matrix.get(this.rowIndices[O],V)}}class Dt extends se{constructor(O,V,B){ht(O,V),Et(O,B),super(O,V.length,B.length),this.rowIndices=V,this.columnIndices=B}set(O,V,B){return this.matrix.set(this.rowIndices[O],this.columnIndices[V],B),this}get(O,V){return this.matrix.get(this.rowIndices[O],this.columnIndices[V])}}class be extends se{constructor(O,V,B,z,Y){xt(O,V,B,z,Y),super(O,B-V+1,Y-z+1),this.startRow=V,this.startColumn=z}set(O,V,B){return this.matrix.set(this.startRow+O,this.startColumn+V,B),this}get(O,V){return this.matrix.get(this.startRow+O,this.startColumn+V)}}class ae extends se{constructor(O){super(O,O.columns,O.rows)}set(O,V,B){return this.matrix.set(V,O,B),this}get(O,V){return this.matrix.get(V,O)}}class ce extends Ct{constructor(O,V={}){const{rows:B=1}=V;if(O.length%B!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=B,this.columns=O.length/B,this.data=O}set(O,V,B){let z=this._calculateIndex(O,V);return this.data[z]=B,this}get(O,V){let B=this._calculateIndex(O,V);return this.data[B]}_calculateIndex(O,V){return O*this.columns+V}}class It extends Ct{constructor(O){super(),this.data=O,this.rows=O.length,this.columns=O[0].length}set(O,V,B){return this.data[O][V]=B,this}get(O,V){return this.data[O][V]}}function Qt(W,O){if(_.isAnyArray(W))return W[0]&&_.isAnyArray(W[0])?new It(W):new ce(W,O);throw new Error("the argument is not an array")}class Zt{constructor(O){O=It.checkMatrix(O);let V=O.clone(),B=V.rows,z=V.columns,Y=new Float64Array(B),nt=1,it,ot,st,vt,ft,Rt,Bt,St,kt;for(it=0;it<B;it++)Y[it]=it;for(St=new Float64Array(B),ot=0;ot<z;ot++){for(it=0;it<B;it++)St[it]=V.get(it,ot);for(it=0;it<B;it++){for(kt=Math.min(it,ot),ft=0,st=0;st<kt;st++)ft+=V.get(it,st)*St[st];St[it]-=ft,V.set(it,ot,St[it])}for(vt=ot,it=ot+1;it<B;it++)Math.abs(St[it])>Math.abs(St[vt])&&(vt=it);if(vt!==ot){for(st=0;st<z;st++)Rt=V.get(vt,st),V.set(vt,st,V.get(ot,st)),V.set(ot,st,Rt);Bt=Y[vt],Y[vt]=Y[ot],Y[ot]=Bt,nt=-nt}if(ot<B&&V.get(ot,ot)!==0)for(it=ot+1;it<B;it++)V.set(it,ot,V.get(it,ot)/V.get(ot,ot))}this.LU=V,this.pivotVector=Y,this.pivotSign=nt}isSingular(){let O=this.LU,V=O.columns;for(let B=0;B<V;B++)if(O.get(B,B)===0)return!0;return!1}solve(O){O=Mt.checkMatrix(O);let V=this.LU;if(V.rows!==O.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let z=O.columns,Y=O.subMatrixRow(this.pivotVector,0,z-1),nt=V.columns,it,ot,st;for(st=0;st<nt;st++)for(it=st+1;it<nt;it++)for(ot=0;ot<z;ot++)Y.set(it,ot,Y.get(it,ot)-Y.get(st,ot)*V.get(it,st));for(st=nt-1;st>=0;st--){for(ot=0;ot<z;ot++)Y.set(st,ot,Y.get(st,ot)/V.get(st,st));for(it=0;it<st;it++)for(ot=0;ot<z;ot++)Y.set(it,ot,Y.get(it,ot)-Y.get(st,ot)*V.get(it,st))}return Y}get determinant(){let O=this.LU;if(!O.isSquare())throw new Error("Matrix must be square");let V=this.pivotSign,B=O.columns;for(let z=0;z<B;z++)V*=O.get(z,z);return V}get lowerTriangularMatrix(){let O=this.LU,V=O.rows,B=O.columns,z=new Mt(V,B);for(let Y=0;Y<V;Y++)for(let nt=0;nt<B;nt++)Y>nt?z.set(Y,nt,O.get(Y,nt)):Y===nt?z.set(Y,nt,1):z.set(Y,nt,0);return z}get upperTriangularMatrix(){let O=this.LU,V=O.rows,B=O.columns,z=new Mt(V,B);for(let Y=0;Y<V;Y++)for(let nt=0;nt<B;nt++)Y<=nt?z.set(Y,nt,O.get(Y,nt)):z.set(Y,nt,0);return z}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function Jt(W,O){let V=0;return Math.abs(W)>Math.abs(O)?(V=O/W,Math.abs(W)*Math.sqrt(1+V*V)):O!==0?(V=W/O,Math.abs(O)*Math.sqrt(1+V*V)):0}class ge{constructor(O){O=It.checkMatrix(O);let V=O.clone(),B=O.rows,z=O.columns,Y=new Float64Array(z),nt,it,ot,st;for(ot=0;ot<z;ot++){let vt=0;for(nt=ot;nt<B;nt++)vt=Jt(vt,V.get(nt,ot));if(vt!==0){for(V.get(ot,ot)<0&&(vt=-vt),nt=ot;nt<B;nt++)V.set(nt,ot,V.get(nt,ot)/vt);for(V.set(ot,ot,V.get(ot,ot)+1),it=ot+1;it<z;it++){for(st=0,nt=ot;nt<B;nt++)st+=V.get(nt,ot)*V.get(nt,it);for(st=-st/V.get(ot,ot),nt=ot;nt<B;nt++)V.set(nt,it,V.get(nt,it)+st*V.get(nt,ot))}}Y[ot]=-vt}this.QR=V,this.Rdiag=Y}solve(O){O=Mt.checkMatrix(O);let V=this.QR,B=V.rows;if(O.rows!==B)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let z=O.columns,Y=O.clone(),nt=V.columns,it,ot,st,vt;for(st=0;st<nt;st++)for(ot=0;ot<z;ot++){for(vt=0,it=st;it<B;it++)vt+=V.get(it,st)*Y.get(it,ot);for(vt=-vt/V.get(st,st),it=st;it<B;it++)Y.set(it,ot,Y.get(it,ot)+vt*V.get(it,st))}for(st=nt-1;st>=0;st--){for(ot=0;ot<z;ot++)Y.set(st,ot,Y.get(st,ot)/this.Rdiag[st]);for(it=0;it<st;it++)for(ot=0;ot<z;ot++)Y.set(it,ot,Y.get(it,ot)-Y.get(st,ot)*V.get(it,st))}return Y.subMatrix(0,nt-1,0,z-1)}isFullRank(){let O=this.QR.columns;for(let V=0;V<O;V++)if(this.Rdiag[V]===0)return!1;return!0}get upperTriangularMatrix(){let O=this.QR,V=O.columns,B=new Mt(V,V),z,Y;for(z=0;z<V;z++)for(Y=0;Y<V;Y++)z<Y?B.set(z,Y,O.get(z,Y)):z===Y?B.set(z,Y,this.Rdiag[z]):B.set(z,Y,0);return B}get orthogonalMatrix(){let O=this.QR,V=O.rows,B=O.columns,z=new Mt(V,B),Y,nt,it,ot;for(it=B-1;it>=0;it--){for(Y=0;Y<V;Y++)z.set(Y,it,0);for(z.set(it,it,1),nt=it;nt<B;nt++)if(O.get(it,it)!==0){for(ot=0,Y=it;Y<V;Y++)ot+=O.get(Y,it)*z.get(Y,nt);for(ot=-ot/O.get(it,it),Y=it;Y<V;Y++)z.set(Y,nt,z.get(Y,nt)+ot*O.get(Y,it))}}return z}}class me{constructor(O,V={}){if(O=It.checkMatrix(O),O.isEmpty())throw new Error("Matrix must be non-empty");let B=O.rows,z=O.columns;const{computeLeftSingularVectors:Y=!0,computeRightSingularVectors:nt=!0,autoTranspose:it=!1}=V;let ot=!!Y,st=!!nt,vt=!1,ft;if(B<z)if(!it)ft=O.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{ft=O.transpose(),B=ft.rows,z=ft.columns,vt=!0;let mt=ot;ot=st,st=mt}else ft=O.clone();let Rt=Math.min(B,z),Bt=Math.min(B+1,z),St=new Float64Array(Bt),kt=new Mt(B,Rt),Nt=new Mt(z,z),pt=new Float64Array(z),$t=new Float64Array(B),Lt=new Float64Array(Bt);for(let mt=0;mt<Bt;mt++)Lt[mt]=mt;let ie=Math.min(B-1,z),le=Math.max(0,Math.min(z-2,B)),Ae=Math.max(ie,le);for(let mt=0;mt<Ae;mt++){if(mt<ie){St[mt]=0;for(let Tt=mt;Tt<B;Tt++)St[mt]=Jt(St[mt],ft.get(Tt,mt));if(St[mt]!==0){ft.get(mt,mt)<0&&(St[mt]=-St[mt]);for(let Tt=mt;Tt<B;Tt++)ft.set(Tt,mt,ft.get(Tt,mt)/St[mt]);ft.set(mt,mt,ft.get(mt,mt)+1)}St[mt]=-St[mt]}for(let Tt=mt+1;Tt<z;Tt++){if(mt<ie&&St[mt]!==0){let Vt=0;for(let At=mt;At<B;At++)Vt+=ft.get(At,mt)*ft.get(At,Tt);Vt=-Vt/ft.get(mt,mt);for(let At=mt;At<B;At++)ft.set(At,Tt,ft.get(At,Tt)+Vt*ft.get(At,mt))}pt[Tt]=ft.get(mt,Tt)}if(ot&&mt<ie)for(let Tt=mt;Tt<B;Tt++)kt.set(Tt,mt,ft.get(Tt,mt));if(mt<le){pt[mt]=0;for(let Tt=mt+1;Tt<z;Tt++)pt[mt]=Jt(pt[mt],pt[Tt]);if(pt[mt]!==0){pt[mt+1]<0&&(pt[mt]=0-pt[mt]);for(let Tt=mt+1;Tt<z;Tt++)pt[Tt]/=pt[mt];pt[mt+1]+=1}if(pt[mt]=-pt[mt],mt+1<B&&pt[mt]!==0){for(let Tt=mt+1;Tt<B;Tt++)$t[Tt]=0;for(let Tt=mt+1;Tt<B;Tt++)for(let Vt=mt+1;Vt<z;Vt++)$t[Tt]+=pt[Vt]*ft.get(Tt,Vt);for(let Tt=mt+1;Tt<z;Tt++){let Vt=-pt[Tt]/pt[mt+1];for(let At=mt+1;At<B;At++)ft.set(At,Tt,ft.get(At,Tt)+Vt*$t[At])}}if(st)for(let Tt=mt+1;Tt<z;Tt++)Nt.set(Tt,mt,pt[Tt])}}let Ht=Math.min(z,B+1);if(ie<z&&(St[ie]=ft.get(ie,ie)),B<Ht&&(St[Ht-1]=0),le+1<Ht&&(pt[le]=ft.get(le,Ht-1)),pt[Ht-1]=0,ot){for(let mt=ie;mt<Rt;mt++){for(let Tt=0;Tt<B;Tt++)kt.set(Tt,mt,0);kt.set(mt,mt,1)}for(let mt=ie-1;mt>=0;mt--)if(St[mt]!==0){for(let Tt=mt+1;Tt<Rt;Tt++){let Vt=0;for(let At=mt;At<B;At++)Vt+=kt.get(At,mt)*kt.get(At,Tt);Vt=-Vt/kt.get(mt,mt);for(let At=mt;At<B;At++)kt.set(At,Tt,kt.get(At,Tt)+Vt*kt.get(At,mt))}for(let Tt=mt;Tt<B;Tt++)kt.set(Tt,mt,-kt.get(Tt,mt));kt.set(mt,mt,1+kt.get(mt,mt));for(let Tt=0;Tt<mt-1;Tt++)kt.set(Tt,mt,0)}else{for(let Tt=0;Tt<B;Tt++)kt.set(Tt,mt,0);kt.set(mt,mt,1)}}if(st)for(let mt=z-1;mt>=0;mt--){if(mt<le&&pt[mt]!==0)for(let Tt=mt+1;Tt<z;Tt++){let Vt=0;for(let At=mt+1;At<z;At++)Vt+=Nt.get(At,mt)*Nt.get(At,Tt);Vt=-Vt/Nt.get(mt+1,mt);for(let At=mt+1;At<z;At++)Nt.set(At,Tt,Nt.get(At,Tt)+Vt*Nt.get(At,mt))}for(let Tt=0;Tt<z;Tt++)Nt.set(Tt,mt,0);Nt.set(mt,mt,1)}let ee=Ht-1,ke=Number.EPSILON;for(;Ht>0;){let mt,Tt;for(mt=Ht-2;mt>=-1&&mt!==-1;mt--){const Vt=Number.MIN_VALUE+ke*Math.abs(St[mt]+Math.abs(St[mt+1]));if(Math.abs(pt[mt])<=Vt||Number.isNaN(pt[mt])){pt[mt]=0;break}}if(mt===Ht-2)Tt=4;else{let Vt;for(Vt=Ht-1;Vt>=mt&&Vt!==mt;Vt--){let At=(Vt!==Ht?Math.abs(pt[Vt]):0)+(Vt!==mt+1?Math.abs(pt[Vt-1]):0);if(Math.abs(St[Vt])<=ke*At){St[Vt]=0;break}}Vt===mt?Tt=3:Vt===Ht-1?Tt=1:(Tt=2,mt=Vt)}switch(mt++,Tt){case 1:{let Vt=pt[Ht-2];pt[Ht-2]=0;for(let At=Ht-2;At>=mt;At--){let Ce=Jt(St[At],Vt),Te=St[At]/Ce,$e=Vt/Ce;if(St[At]=Ce,At!==mt&&(Vt=-$e*pt[At-1],pt[At-1]=Te*pt[At-1]),st)for(let Pe=0;Pe<z;Pe++)Ce=Te*Nt.get(Pe,At)+$e*Nt.get(Pe,Ht-1),Nt.set(Pe,Ht-1,-$e*Nt.get(Pe,At)+Te*Nt.get(Pe,Ht-1)),Nt.set(Pe,At,Ce)}break}case 2:{let Vt=pt[mt-1];pt[mt-1]=0;for(let At=mt;At<Ht;At++){let Ce=Jt(St[At],Vt),Te=St[At]/Ce,$e=Vt/Ce;if(St[At]=Ce,Vt=-$e*pt[At],pt[At]=Te*pt[At],ot)for(let Pe=0;Pe<B;Pe++)Ce=Te*kt.get(Pe,At)+$e*kt.get(Pe,mt-1),kt.set(Pe,mt-1,-$e*kt.get(Pe,At)+Te*kt.get(Pe,mt-1)),kt.set(Pe,At,Ce)}break}case 3:{const Vt=Math.max(Math.abs(St[Ht-1]),Math.abs(St[Ht-2]),Math.abs(pt[Ht-2]),Math.abs(St[mt]),Math.abs(pt[mt])),At=St[Ht-1]/Vt,Ce=St[Ht-2]/Vt,Te=pt[Ht-2]/Vt,$e=St[mt]/Vt,Pe=pt[mt]/Vt,Ne=((Ce+At)*(Ce-At)+Te*Te)/2,Ge=At*Te*(At*Te);let Fe=0;(Ne!==0||Ge!==0)&&(Ne<0?Fe=0-Math.sqrt(Ne*Ne+Ge):Fe=Math.sqrt(Ne*Ne+Ge),Fe=Ge/(Ne+Fe));let qe=($e+At)*($e-At)+Fe,Xe=$e*Pe;for(let Se=mt;Se<Ht-1;Se++){let Ve=Jt(qe,Xe);Ve===0&&(Ve=Number.MIN_VALUE);let Ue=qe/Ve,je=Xe/Ve;if(Se!==mt&&(pt[Se-1]=Ve),qe=Ue*St[Se]+je*pt[Se],pt[Se]=Ue*pt[Se]-je*St[Se],Xe=je*St[Se+1],St[Se+1]=Ue*St[Se+1],st)for(let Oe=0;Oe<z;Oe++)Ve=Ue*Nt.get(Oe,Se)+je*Nt.get(Oe,Se+1),Nt.set(Oe,Se+1,-je*Nt.get(Oe,Se)+Ue*Nt.get(Oe,Se+1)),Nt.set(Oe,Se,Ve);if(Ve=Jt(qe,Xe),Ve===0&&(Ve=Number.MIN_VALUE),Ue=qe/Ve,je=Xe/Ve,St[Se]=Ve,qe=Ue*pt[Se]+je*St[Se+1],St[Se+1]=-je*pt[Se]+Ue*St[Se+1],Xe=je*pt[Se+1],pt[Se+1]=Ue*pt[Se+1],ot&&Se<B-1)for(let Oe=0;Oe<B;Oe++)Ve=Ue*kt.get(Oe,Se)+je*kt.get(Oe,Se+1),kt.set(Oe,Se+1,-je*kt.get(Oe,Se)+Ue*kt.get(Oe,Se+1)),kt.set(Oe,Se,Ve)}pt[Ht-2]=qe;break}case 4:{if(St[mt]<=0&&(St[mt]=St[mt]<0?-St[mt]:0,st))for(let Vt=0;Vt<=ee;Vt++)Nt.set(Vt,mt,-Nt.get(Vt,mt));for(;mt<ee&&!(St[mt]>=St[mt+1]);){let Vt=St[mt];if(St[mt]=St[mt+1],St[mt+1]=Vt,st&&mt<z-1)for(let At=0;At<z;At++)Vt=Nt.get(At,mt+1),Nt.set(At,mt+1,Nt.get(At,mt)),Nt.set(At,mt,Vt);if(ot&&mt<B-1)for(let At=0;At<B;At++)Vt=kt.get(At,mt+1),kt.set(At,mt+1,kt.get(At,mt)),kt.set(At,mt,Vt);mt++}Ht--;break}}}if(vt){let mt=Nt;Nt=kt,kt=mt}this.m=B,this.n=z,this.s=St,this.U=kt,this.V=Nt}solve(O){let V=O,B=this.threshold,z=this.s.length,Y=Mt.zeros(z,z);for(let Rt=0;Rt<z;Rt++)Math.abs(this.s[Rt])<=B?Y.set(Rt,Rt,0):Y.set(Rt,Rt,1/this.s[Rt]);let nt=this.U,it=this.rightSingularVectors,ot=it.mmul(Y),st=it.rows,vt=nt.rows,ft=Mt.zeros(st,vt);for(let Rt=0;Rt<st;Rt++)for(let Bt=0;Bt<vt;Bt++){let St=0;for(let kt=0;kt<z;kt++)St+=ot.get(Rt,kt)*nt.get(Bt,kt);ft.set(Rt,Bt,St)}return ft.mmul(V)}solveForDiagonal(O){return this.solve(Mt.diag(O))}inverse(){let O=this.V,V=this.threshold,B=O.rows,z=O.columns,Y=new Mt(B,this.s.length);for(let vt=0;vt<B;vt++)for(let ft=0;ft<z;ft++)Math.abs(this.s[ft])>V&&Y.set(vt,ft,O.get(vt,ft)/this.s[ft]);let nt=this.U,it=nt.rows,ot=nt.columns,st=new Mt(B,it);for(let vt=0;vt<B;vt++)for(let ft=0;ft<it;ft++){let Rt=0;for(let Bt=0;Bt<ot;Bt++)Rt+=Y.get(vt,Bt)*nt.get(ft,Bt);st.set(vt,ft,Rt)}return st}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let O=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,V=0,B=this.s;for(let z=0,Y=B.length;z<Y;z++)B[z]>O&&V++;return V}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Mt.diag(this.s)}}function Me(W,O=!1){return W=It.checkMatrix(W),O?new me(W).inverse():Ut(W,Mt.eye(W.rows))}function Ut(W,O,V=!1){return W=It.checkMatrix(W),O=It.checkMatrix(O),V?new me(W).solve(O):W.isSquare()?new Zt(W).solve(O):new ge(W).solve(O)}function Yt(W){if(W=Mt.checkMatrix(W),W.isSquare()){if(W.columns===0)return 1;let O,V,B,z;if(W.columns===2)return O=W.get(0,0),V=W.get(0,1),B=W.get(1,0),z=W.get(1,1),O*z-V*B;if(W.columns===3){let Y,nt,it;return Y=new Dt(W,[1,2],[1,2]),nt=new Dt(W,[1,2],[0,2]),it=new Dt(W,[1,2],[0,1]),O=W.get(0,0),V=W.get(0,1),B=W.get(0,2),O*Yt(Y)-V*Yt(nt)+B*Yt(it)}else return new Zt(W).determinant}else throw Error("determinant can only be calculated for a square matrix")}function re(W,O){let V=[];for(let B=0;B<W;B++)B!==O&&V.push(B);return V}function Gt(W,O,V,B=1e-9,z=1e-9){if(W>z)return new Array(O.rows+1).fill(0);{let Y=O.addRow(V,[0]);for(let nt=0;nt<Y.rows;nt++)Math.abs(Y.get(nt,0))<B&&Y.set(nt,0,0);return Y.to1DArray()}}function xe(W,O={}){const{thresholdValue:V=1e-9,thresholdError:B=1e-9}=O;W=Mt.checkMatrix(W);let z=W.rows,Y=new Mt(z,z);for(let nt=0;nt<z;nt++){let it=Mt.columnVector(W.getRow(nt)),ot=W.subMatrixRow(re(z,nt)).transpose(),vt=new me(ot).solve(it),ft=Mt.sub(it,ot.mmul(vt)).abs().max();Y.setRow(nt,Gt(ft,vt,nt,V,B))}return Y}function Ie(W,O=Number.EPSILON){if(W=Mt.checkMatrix(W),W.isEmpty())return W.transpose();let V=new me(W,{autoTranspose:!0}),B=V.leftSingularVectors,z=V.rightSingularVectors,Y=V.diagonal;for(let nt=0;nt<Y.length;nt++)Math.abs(Y[nt])>O?Y[nt]=1/Y[nt]:Y[nt]=0;return z.mmul(Mt.diag(Y).mmul(B.transpose()))}function fe(W,O=W,V={}){W=new Mt(W);let B=!1;if(typeof O=="object"&&!Mt.isMatrix(O)&&!_.isAnyArray(O)?(V=O,O=W,B=!0):O=new Mt(O),W.rows!==O.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:z=!0}=V;z&&(W=W.center("column"),B||(O=O.center("column")));const Y=W.transpose().mmul(O);for(let nt=0;nt<Y.rows;nt++)for(let it=0;it<Y.columns;it++)Y.set(nt,it,Y.get(nt,it)*(1/(W.rows-1)));return Y}function _e(W,O=W,V={}){W=new Mt(W);let B=!1;if(typeof O=="object"&&!Mt.isMatrix(O)&&!_.isAnyArray(O)?(V=O,O=W,B=!0):O=new Mt(O),W.rows!==O.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:z=!0,scale:Y=!0}=V;z&&(W.center("column"),B||O.center("column")),Y&&(W.scale("column"),B||O.scale("column"));const nt=W.standardDeviation("column",{unbiased:!0}),it=B?nt:O.standardDeviation("column",{unbiased:!0}),ot=W.transpose().mmul(O);for(let st=0;st<ot.rows;st++)for(let vt=0;vt<ot.columns;vt++)ot.set(st,vt,ot.get(st,vt)*(1/(nt[st]*it[vt]))*(1/(W.rows-1)));return ot}class ve{constructor(O,V={}){const{assumeSymmetric:B=!1}=V;if(O=It.checkMatrix(O),!O.isSquare())throw new Error("Matrix is not a square matrix");if(O.isEmpty())throw new Error("Matrix must be non-empty");let z=O.columns,Y=new Mt(z,z),nt=new Float64Array(z),it=new Float64Array(z),ot=O,st,vt,ft=!1;if(B?ft=!0:ft=O.isSymmetric(),ft){for(st=0;st<z;st++)for(vt=0;vt<z;vt++)Y.set(st,vt,ot.get(st,vt));Re(z,it,nt,Y),Be(z,it,nt,Y)}else{let Rt=new Mt(z,z),Bt=new Float64Array(z);for(vt=0;vt<z;vt++)for(st=0;st<z;st++)Rt.set(st,vt,ot.get(st,vt));De(z,Rt,Bt,Y),Le(z,it,nt,Y,Rt)}this.n=z,this.e=it,this.d=nt,this.V=Y}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let O=this.n,V=this.e,B=this.d,z=new Mt(O,O),Y,nt;for(Y=0;Y<O;Y++){for(nt=0;nt<O;nt++)z.set(Y,nt,0);z.set(Y,Y,B[Y]),V[Y]>0?z.set(Y,Y+1,V[Y]):V[Y]<0&&z.set(Y,Y-1,V[Y])}return z}}function Re(W,O,V,B){let z,Y,nt,it,ot,st,vt,ft;for(ot=0;ot<W;ot++)V[ot]=B.get(W-1,ot);for(it=W-1;it>0;it--){for(ft=0,nt=0,st=0;st<it;st++)ft=ft+Math.abs(V[st]);if(ft===0)for(O[it]=V[it-1],ot=0;ot<it;ot++)V[ot]=B.get(it-1,ot),B.set(it,ot,0),B.set(ot,it,0);else{for(st=0;st<it;st++)V[st]/=ft,nt+=V[st]*V[st];for(z=V[it-1],Y=Math.sqrt(nt),z>0&&(Y=-Y),O[it]=ft*Y,nt=nt-z*Y,V[it-1]=z-Y,ot=0;ot<it;ot++)O[ot]=0;for(ot=0;ot<it;ot++){for(z=V[ot],B.set(ot,it,z),Y=O[ot]+B.get(ot,ot)*z,st=ot+1;st<=it-1;st++)Y+=B.get(st,ot)*V[st],O[st]+=B.get(st,ot)*z;O[ot]=Y}for(z=0,ot=0;ot<it;ot++)O[ot]/=nt,z+=O[ot]*V[ot];for(vt=z/(nt+nt),ot=0;ot<it;ot++)O[ot]-=vt*V[ot];for(ot=0;ot<it;ot++){for(z=V[ot],Y=O[ot],st=ot;st<=it-1;st++)B.set(st,ot,B.get(st,ot)-(z*O[st]+Y*V[st]));V[ot]=B.get(it-1,ot),B.set(it,ot,0)}}V[it]=nt}for(it=0;it<W-1;it++){if(B.set(W-1,it,B.get(it,it)),B.set(it,it,1),nt=V[it+1],nt!==0){for(st=0;st<=it;st++)V[st]=B.get(st,it+1)/nt;for(ot=0;ot<=it;ot++){for(Y=0,st=0;st<=it;st++)Y+=B.get(st,it+1)*B.get(st,ot);for(st=0;st<=it;st++)B.set(st,ot,B.get(st,ot)-Y*V[st])}}for(st=0;st<=it;st++)B.set(st,it+1,0)}for(ot=0;ot<W;ot++)V[ot]=B.get(W-1,ot),B.set(W-1,ot,0);B.set(W-1,W-1,1),O[0]=0}function Be(W,O,V,B){let z,Y,nt,it,ot,st,vt,ft,Rt,Bt,St,kt,Nt,pt,$t,Lt;for(nt=1;nt<W;nt++)O[nt-1]=O[nt];O[W-1]=0;let ie=0,le=0,Ae=Number.EPSILON;for(st=0;st<W;st++){for(le=Math.max(le,Math.abs(V[st])+Math.abs(O[st])),vt=st;vt<W&&!(Math.abs(O[vt])<=Ae*le);)vt++;if(vt>st)do{for(z=V[st],ft=(V[st+1]-z)/(2*O[st]),Rt=Jt(ft,1),ft<0&&(Rt=-Rt),V[st]=O[st]/(ft+Rt),V[st+1]=O[st]*(ft+Rt),Bt=V[st+1],Y=z-V[st],nt=st+2;nt<W;nt++)V[nt]-=Y;for(ie=ie+Y,ft=V[vt],St=1,kt=St,Nt=St,pt=O[st+1],$t=0,Lt=0,nt=vt-1;nt>=st;nt--)for(Nt=kt,kt=St,Lt=$t,z=St*O[nt],Y=St*ft,Rt=Jt(ft,O[nt]),O[nt+1]=$t*Rt,$t=O[nt]/Rt,St=ft/Rt,ft=St*V[nt]-$t*z,V[nt+1]=Y+$t*(St*z+$t*V[nt]),ot=0;ot<W;ot++)Y=B.get(ot,nt+1),B.set(ot,nt+1,$t*B.get(ot,nt)+St*Y),B.set(ot,nt,St*B.get(ot,nt)-$t*Y);ft=-$t*Lt*Nt*pt*O[st]/Bt,O[st]=$t*ft,V[st]=St*ft}while(Math.abs(O[st])>Ae*le);V[st]=V[st]+ie,O[st]=0}for(nt=0;nt<W-1;nt++){for(ot=nt,ft=V[nt],it=nt+1;it<W;it++)V[it]<ft&&(ot=it,ft=V[it]);if(ot!==nt)for(V[ot]=V[nt],V[nt]=ft,it=0;it<W;it++)ft=B.get(it,nt),B.set(it,nt,B.get(it,ot)),B.set(it,ot,ft)}}function De(W,O,V,B){let z=0,Y=W-1,nt,it,ot,st,vt,ft,Rt;for(ft=z+1;ft<=Y-1;ft++){for(Rt=0,st=ft;st<=Y;st++)Rt=Rt+Math.abs(O.get(st,ft-1));if(Rt!==0){for(ot=0,st=Y;st>=ft;st--)V[st]=O.get(st,ft-1)/Rt,ot+=V[st]*V[st];for(it=Math.sqrt(ot),V[ft]>0&&(it=-it),ot=ot-V[ft]*it,V[ft]=V[ft]-it,vt=ft;vt<W;vt++){for(nt=0,st=Y;st>=ft;st--)nt+=V[st]*O.get(st,vt);for(nt=nt/ot,st=ft;st<=Y;st++)O.set(st,vt,O.get(st,vt)-nt*V[st])}for(st=0;st<=Y;st++){for(nt=0,vt=Y;vt>=ft;vt--)nt+=V[vt]*O.get(st,vt);for(nt=nt/ot,vt=ft;vt<=Y;vt++)O.set(st,vt,O.get(st,vt)-nt*V[vt])}V[ft]=Rt*V[ft],O.set(ft,ft-1,Rt*it)}}for(st=0;st<W;st++)for(vt=0;vt<W;vt++)B.set(st,vt,st===vt?1:0);for(ft=Y-1;ft>=z+1;ft--)if(O.get(ft,ft-1)!==0){for(st=ft+1;st<=Y;st++)V[st]=O.get(st,ft-1);for(vt=ft;vt<=Y;vt++){for(it=0,st=ft;st<=Y;st++)it+=V[st]*B.get(st,vt);for(it=it/V[ft]/O.get(ft,ft-1),st=ft;st<=Y;st++)B.set(st,vt,B.get(st,vt)+it*V[st])}}}function Le(W,O,V,B,z){let Y=W-1,nt=0,it=W-1,ot=Number.EPSILON,st=0,vt=0,ft=0,Rt=0,Bt=0,St=0,kt=0,Nt=0,pt,$t,Lt,ie,le,Ae,Ht,ee,ke,mt,Tt,Vt,At,Ce,Te;for(pt=0;pt<W;pt++)for((pt<nt||pt>it)&&(V[pt]=z.get(pt,pt),O[pt]=0),$t=Math.max(pt-1,0);$t<W;$t++)vt=vt+Math.abs(z.get(pt,$t));for(;Y>=nt;){for(ie=Y;ie>nt&&(St=Math.abs(z.get(ie-1,ie-1))+Math.abs(z.get(ie,ie)),St===0&&(St=vt),!(Math.abs(z.get(ie,ie-1))<ot*St));)ie--;if(ie===Y)z.set(Y,Y,z.get(Y,Y)+st),V[Y]=z.get(Y,Y),O[Y]=0,Y--,Nt=0;else if(ie===Y-1){if(Ht=z.get(Y,Y-1)*z.get(Y-1,Y),ft=(z.get(Y-1,Y-1)-z.get(Y,Y))/2,Rt=ft*ft+Ht,kt=Math.sqrt(Math.abs(Rt)),z.set(Y,Y,z.get(Y,Y)+st),z.set(Y-1,Y-1,z.get(Y-1,Y-1)+st),ee=z.get(Y,Y),Rt>=0){for(kt=ft>=0?ft+kt:ft-kt,V[Y-1]=ee+kt,V[Y]=V[Y-1],kt!==0&&(V[Y]=ee-Ht/kt),O[Y-1]=0,O[Y]=0,ee=z.get(Y,Y-1),St=Math.abs(ee)+Math.abs(kt),ft=ee/St,Rt=kt/St,Bt=Math.sqrt(ft*ft+Rt*Rt),ft=ft/Bt,Rt=Rt/Bt,$t=Y-1;$t<W;$t++)kt=z.get(Y-1,$t),z.set(Y-1,$t,Rt*kt+ft*z.get(Y,$t)),z.set(Y,$t,Rt*z.get(Y,$t)-ft*kt);for(pt=0;pt<=Y;pt++)kt=z.get(pt,Y-1),z.set(pt,Y-1,Rt*kt+ft*z.get(pt,Y)),z.set(pt,Y,Rt*z.get(pt,Y)-ft*kt);for(pt=nt;pt<=it;pt++)kt=B.get(pt,Y-1),B.set(pt,Y-1,Rt*kt+ft*B.get(pt,Y)),B.set(pt,Y,Rt*B.get(pt,Y)-ft*kt)}else V[Y-1]=ee+ft,V[Y]=ee+ft,O[Y-1]=kt,O[Y]=-kt;Y=Y-2,Nt=0}else{if(ee=z.get(Y,Y),ke=0,Ht=0,ie<Y&&(ke=z.get(Y-1,Y-1),Ht=z.get(Y,Y-1)*z.get(Y-1,Y)),Nt===10){for(st+=ee,pt=nt;pt<=Y;pt++)z.set(pt,pt,z.get(pt,pt)-ee);St=Math.abs(z.get(Y,Y-1))+Math.abs(z.get(Y-1,Y-2)),ee=ke=.75*St,Ht=-.4375*St*St}if(Nt===30&&(St=(ke-ee)/2,St=St*St+Ht,St>0)){for(St=Math.sqrt(St),ke<ee&&(St=-St),St=ee-Ht/((ke-ee)/2+St),pt=nt;pt<=Y;pt++)z.set(pt,pt,z.get(pt,pt)-St);st+=St,ee=ke=Ht=.964}for(Nt=Nt+1,le=Y-2;le>=ie&&(kt=z.get(le,le),Bt=ee-kt,St=ke-kt,ft=(Bt*St-Ht)/z.get(le+1,le)+z.get(le,le+1),Rt=z.get(le+1,le+1)-kt-Bt-St,Bt=z.get(le+2,le+1),St=Math.abs(ft)+Math.abs(Rt)+Math.abs(Bt),ft=ft/St,Rt=Rt/St,Bt=Bt/St,!(le===ie||Math.abs(z.get(le,le-1))*(Math.abs(Rt)+Math.abs(Bt))<ot*(Math.abs(ft)*(Math.abs(z.get(le-1,le-1))+Math.abs(kt)+Math.abs(z.get(le+1,le+1))))));)le--;for(pt=le+2;pt<=Y;pt++)z.set(pt,pt-2,0),pt>le+2&&z.set(pt,pt-3,0);for(Lt=le;Lt<=Y-1&&(Ce=Lt!==Y-1,Lt!==le&&(ft=z.get(Lt,Lt-1),Rt=z.get(Lt+1,Lt-1),Bt=Ce?z.get(Lt+2,Lt-1):0,ee=Math.abs(ft)+Math.abs(Rt)+Math.abs(Bt),ee!==0&&(ft=ft/ee,Rt=Rt/ee,Bt=Bt/ee)),ee!==0);Lt++)if(St=Math.sqrt(ft*ft+Rt*Rt+Bt*Bt),ft<0&&(St=-St),St!==0){for(Lt!==le?z.set(Lt,Lt-1,-St*ee):ie!==le&&z.set(Lt,Lt-1,-z.get(Lt,Lt-1)),ft=ft+St,ee=ft/St,ke=Rt/St,kt=Bt/St,Rt=Rt/ft,Bt=Bt/ft,$t=Lt;$t<W;$t++)ft=z.get(Lt,$t)+Rt*z.get(Lt+1,$t),Ce&&(ft=ft+Bt*z.get(Lt+2,$t),z.set(Lt+2,$t,z.get(Lt+2,$t)-ft*kt)),z.set(Lt,$t,z.get(Lt,$t)-ft*ee),z.set(Lt+1,$t,z.get(Lt+1,$t)-ft*ke);for(pt=0;pt<=Math.min(Y,Lt+3);pt++)ft=ee*z.get(pt,Lt)+ke*z.get(pt,Lt+1),Ce&&(ft=ft+kt*z.get(pt,Lt+2),z.set(pt,Lt+2,z.get(pt,Lt+2)-ft*Bt)),z.set(pt,Lt,z.get(pt,Lt)-ft),z.set(pt,Lt+1,z.get(pt,Lt+1)-ft*Rt);for(pt=nt;pt<=it;pt++)ft=ee*B.get(pt,Lt)+ke*B.get(pt,Lt+1),Ce&&(ft=ft+kt*B.get(pt,Lt+2),B.set(pt,Lt+2,B.get(pt,Lt+2)-ft*Bt)),B.set(pt,Lt,B.get(pt,Lt)-ft),B.set(pt,Lt+1,B.get(pt,Lt+1)-ft*Rt)}}}if(vt!==0){for(Y=W-1;Y>=0;Y--)if(ft=V[Y],Rt=O[Y],Rt===0)for(ie=Y,z.set(Y,Y,1),pt=Y-1;pt>=0;pt--){for(Ht=z.get(pt,pt)-ft,Bt=0,$t=ie;$t<=Y;$t++)Bt=Bt+z.get(pt,$t)*z.get($t,Y);if(O[pt]<0)kt=Ht,St=Bt;else if(ie=pt,O[pt]===0?z.set(pt,Y,Ht!==0?-Bt/Ht:-Bt/(ot*vt)):(ee=z.get(pt,pt+1),ke=z.get(pt+1,pt),Rt=(V[pt]-ft)*(V[pt]-ft)+O[pt]*O[pt],Ae=(ee*St-kt*Bt)/Rt,z.set(pt,Y,Ae),z.set(pt+1,Y,Math.abs(ee)>Math.abs(kt)?(-Bt-Ht*Ae)/ee:(-St-ke*Ae)/kt)),Ae=Math.abs(z.get(pt,Y)),ot*Ae*Ae>1)for($t=pt;$t<=Y;$t++)z.set($t,Y,z.get($t,Y)/Ae)}else if(Rt<0)for(ie=Y-1,Math.abs(z.get(Y,Y-1))>Math.abs(z.get(Y-1,Y))?(z.set(Y-1,Y-1,Rt/z.get(Y,Y-1)),z.set(Y-1,Y,-(z.get(Y,Y)-ft)/z.get(Y,Y-1))):(Te=Ye(0,-z.get(Y-1,Y),z.get(Y-1,Y-1)-ft,Rt),z.set(Y-1,Y-1,Te[0]),z.set(Y-1,Y,Te[1])),z.set(Y,Y-1,0),z.set(Y,Y,1),pt=Y-2;pt>=0;pt--){for(mt=0,Tt=0,$t=ie;$t<=Y;$t++)mt=mt+z.get(pt,$t)*z.get($t,Y-1),Tt=Tt+z.get(pt,$t)*z.get($t,Y);if(Ht=z.get(pt,pt)-ft,O[pt]<0)kt=Ht,Bt=mt,St=Tt;else if(ie=pt,O[pt]===0?(Te=Ye(-mt,-Tt,Ht,Rt),z.set(pt,Y-1,Te[0]),z.set(pt,Y,Te[1])):(ee=z.get(pt,pt+1),ke=z.get(pt+1,pt),Vt=(V[pt]-ft)*(V[pt]-ft)+O[pt]*O[pt]-Rt*Rt,At=(V[pt]-ft)*2*Rt,Vt===0&&At===0&&(Vt=ot*vt*(Math.abs(Ht)+Math.abs(Rt)+Math.abs(ee)+Math.abs(ke)+Math.abs(kt))),Te=Ye(ee*Bt-kt*mt+Rt*Tt,ee*St-kt*Tt-Rt*mt,Vt,At),z.set(pt,Y-1,Te[0]),z.set(pt,Y,Te[1]),Math.abs(ee)>Math.abs(kt)+Math.abs(Rt)?(z.set(pt+1,Y-1,(-mt-Ht*z.get(pt,Y-1)+Rt*z.get(pt,Y))/ee),z.set(pt+1,Y,(-Tt-Ht*z.get(pt,Y)-Rt*z.get(pt,Y-1))/ee)):(Te=Ye(-Bt-ke*z.get(pt,Y-1),-St-ke*z.get(pt,Y),kt,Rt),z.set(pt+1,Y-1,Te[0]),z.set(pt+1,Y,Te[1]))),Ae=Math.max(Math.abs(z.get(pt,Y-1)),Math.abs(z.get(pt,Y))),ot*Ae*Ae>1)for($t=pt;$t<=Y;$t++)z.set($t,Y-1,z.get($t,Y-1)/Ae),z.set($t,Y,z.get($t,Y)/Ae)}for(pt=0;pt<W;pt++)if(pt<nt||pt>it)for($t=pt;$t<W;$t++)B.set(pt,$t,z.get(pt,$t));for($t=W-1;$t>=nt;$t--)for(pt=nt;pt<=it;pt++){for(kt=0,Lt=nt;Lt<=Math.min($t,it);Lt++)kt=kt+B.get(pt,Lt)*z.get(Lt,$t);B.set(pt,$t,kt)}}}function Ye(W,O,V,B){let z,Y;return Math.abs(V)>Math.abs(B)?(z=B/V,Y=V+z*B,[(W+z*O)/Y,(O-z*W)/Y]):(z=V/B,Y=B+z*V,[(z*W+O)/Y,(z*O-W)/Y])}class Ze{constructor(O){if(O=It.checkMatrix(O),!O.isSymmetric())throw new Error("Matrix is not symmetric");let V=O,B=V.rows,z=new Mt(B,B),Y=!0,nt,it,ot;for(it=0;it<B;it++){let st=0;for(ot=0;ot<it;ot++){let vt=0;for(nt=0;nt<ot;nt++)vt+=z.get(ot,nt)*z.get(it,nt);vt=(V.get(it,ot)-vt)/z.get(ot,ot),z.set(it,ot,vt),st=st+vt*vt}for(st=V.get(it,it)-st,Y&&=st>0,z.set(it,it,Math.sqrt(Math.max(st,0))),ot=it+1;ot<B;ot++)z.set(it,ot,0)}this.L=z,this.positiveDefinite=Y}isPositiveDefinite(){return this.positiveDefinite}solve(O){O=It.checkMatrix(O);let V=this.L,B=V.rows;if(O.rows!==B)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let z=O.columns,Y=O.clone(),nt,it,ot;for(ot=0;ot<B;ot++)for(it=0;it<z;it++){for(nt=0;nt<ot;nt++)Y.set(ot,it,Y.get(ot,it)-Y.get(nt,it)*V.get(ot,nt));Y.set(ot,it,Y.get(ot,it)/V.get(ot,ot))}for(ot=B-1;ot>=0;ot--)for(it=0;it<z;it++){for(nt=ot+1;nt<B;nt++)Y.set(ot,it,Y.get(ot,it)-Y.get(nt,it)*V.get(nt,ot));Y.set(ot,it,Y.get(ot,it)/V.get(ot,ot))}return Y}get lowerTriangularMatrix(){return this.L}}class ze{constructor(O,V={}){O=It.checkMatrix(O);let{Y:B}=V;const{scaleScores:z=!1,maxIterations:Y=1e3,terminationCriteria:nt=1e-10}=V;let it;if(B){if(_.isAnyArray(B)&&typeof B[0]=="number"?B=Mt.columnVector(B):B=It.checkMatrix(B),B.rows!==O.rows)throw new Error("Y should have the same number of rows as X");it=B.getColumnVector(0)}else it=O.getColumnVector(0);let ot=1,st,vt,ft,Rt;for(let Bt=0;Bt<Y&&ot>nt;Bt++)ft=O.transpose().mmul(it).div(it.transpose().mmul(it).get(0,0)),ft=ft.div(ft.norm()),st=O.mmul(ft).div(ft.transpose().mmul(ft).get(0,0)),Bt>0&&(ot=st.clone().sub(Rt).pow(2).sum()),Rt=st.clone(),B?(vt=B.transpose().mmul(st).div(st.transpose().mmul(st).get(0,0)),vt=vt.div(vt.norm()),it=B.mmul(vt).div(vt.transpose().mmul(vt).get(0,0))):it=st;if(B){let Bt=O.transpose().mmul(st).div(st.transpose().mmul(st).get(0,0));Bt=Bt.div(Bt.norm());let St=O.clone().sub(st.clone().mmul(Bt.transpose())),kt=it.transpose().mmul(st).div(st.transpose().mmul(st).get(0,0)),Nt=B.clone().sub(st.clone().mulS(kt.get(0,0)).mmul(vt.transpose()));this.t=st,this.p=Bt.transpose(),this.w=ft.transpose(),this.q=vt,this.u=it,this.s=st.transpose().mmul(st),this.xResidual=St,this.yResidual=Nt,this.betas=kt}else this.w=ft.transpose(),this.s=st.transpose().mmul(st).sqrt(),z?this.t=st.clone().div(this.s.get(0,0)):this.t=st,this.xResidual=O.sub(st.mmul(ft.transpose()))}}return matrix$1.AbstractMatrix=Ct,matrix$1.CHO=Ze,matrix$1.CholeskyDecomposition=Ze,matrix$1.DistanceMatrix=oe,matrix$1.EVD=ve,matrix$1.EigenvalueDecomposition=ve,matrix$1.LU=Zt,matrix$1.LuDecomposition=Zt,matrix$1.Matrix=Mt,matrix$1.MatrixColumnSelectionView=ye,matrix$1.MatrixColumnView=ue,matrix$1.MatrixFlipColumnView=pe,matrix$1.MatrixFlipRowView=Ee,matrix$1.MatrixRowSelectionView=zt,matrix$1.MatrixRowView=we,matrix$1.MatrixSelectionView=Dt,matrix$1.MatrixSubView=be,matrix$1.MatrixTransposeView=ae,matrix$1.NIPALS=ze,matrix$1.Nipals=ze,matrix$1.QR=ge,matrix$1.QrDecomposition=ge,matrix$1.SVD=me,matrix$1.SingularValueDecomposition=me,matrix$1.SymmetricMatrix=qt,matrix$1.WrapperMatrix1D=ce,matrix$1.WrapperMatrix2D=It,matrix$1.correlation=_e,matrix$1.covariance=fe,matrix$1.default=Mt,matrix$1.determinant=Yt,matrix$1.inverse=Me,matrix$1.linearDependencies=xe,matrix$1.pseudoInverse=Ie,matrix$1.solve=Ut,matrix$1.wrap=Qt,matrix$1}var matrixExports=requireMatrix();const matrix=getDefaultExportFromCjs(matrixExports),Matrix=matrixExports.Matrix,SVD=matrixExports.SVD;matrix.Matrix?matrix.Matrix:matrixExports.Matrix;const inverse=matrixExports.inverse,pseudoInverse=matrixExports.pseudoInverse;var medianQuickselect_min={exports:{}},hasRequiredMedianQuickselect_min;function requireMedianQuickselect_min(){return hasRequiredMedianQuickselect_min||(hasRequiredMedianQuickselect_min=1,(function(_){(function(){function E(P){for(var D=0,U=P.length-1,G=void 0,X=void 0,q=void 0,Z=C(D,U);;){if(U<=D)return P[Z];if(U==D+1)return P[D]>P[U]&&A(P,D,U),P[Z];for(G=C(D,U),P[G]>P[U]&&A(P,G,U),P[D]>P[U]&&A(P,D,U),P[G]>P[D]&&A(P,G,D),A(P,G,D+1),X=D+1,q=U;;){do X++;while(P[D]>P[X]);do q--;while(P[q]>P[D]);if(q<X)break;A(P,X,q)}A(P,D,q),q<=Z&&(D=X),q>=Z&&(U=q-1)}}var A=function(D,U,G){var X;return X=[D[G],D[U]],D[U]=X[0],D[G]=X[1],X},C=function(D,U){return~~((D+U)/2)};_.exports?_.exports=E:window.median=E})()})(medianQuickselect_min)),medianQuickselect_min.exports}var medianQuickselect_minExports=requireMedianQuickselect_min();const quickMedian=getDefaultExportFromCjs(medianQuickselect_minExports);function difference(_,E){return{column:_.column-E.column,row:_.row-E.row}}function normalize(_){const E=Math.hypot(_.column,_.row);return{column:_.column/E,row:_.row/E}}function rotate$1(_,E){const A=[],C=Math.cos(_),P=Math.sin(_);for(const D of E)A.push({column:C*D.column-P*D.row,row:P*D.column+C*D.row});return A}function getAngle(_,E){const A=difference(E,_),C=normalize(A),P=Math.acos(C.column);return C.row<0?-P:P}function toDegrees(_){return _*180/Math.PI}function getRadius(_){if(_%2!==1||_<0)throw new RangeError("size must be positive and odd");return(_-1)/2}const t$2=Symbol.for("@ts-pattern/matcher"),e$2=Symbol.for("@ts-pattern/isVariadic"),n$2="@ts-pattern/anonymous-select-key",r$2=_=>!!(_&&typeof _=="object"),i$3=_=>_&&!!_[t$2],o$2=(_,E,A)=>{if(i$3(_)){const C=_[t$2](),{matched:P,selections:D}=C.match(E);return P&&D&&Object.keys(D).forEach(U=>A(U,D[U])),P}if(r$2(_)){if(!r$2(E))return!1;if(Array.isArray(_)){if(!Array.isArray(E))return!1;let C=[],P=[],D=[];for(const U of _.keys()){const G=_[U];i$3(G)&&G[e$2]?D.push(G):D.length?P.push(G):C.push(G)}if(D.length){if(D.length>1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(E.length<C.length+P.length)return!1;const U=E.slice(0,C.length),G=P.length===0?[]:E.slice(-P.length),X=E.slice(C.length,P.length===0?1/0:-P.length);return C.every((q,Z)=>o$2(q,U[Z],A))&&P.every((q,Z)=>o$2(q,G[Z],A))&&(D.length===0||o$2(D[0],X,A))}return _.length===E.length&&_.every((U,G)=>o$2(U,E[G],A))}return Reflect.ownKeys(_).every(C=>{const P=_[C];return(C in E||i$3(D=P)&&D[t$2]().matcherType==="optional")&&o$2(P,E[C],A);var D})}return Object.is(E,_)},s$1=_=>{var E,A,C;return r$2(_)?i$3(_)?(E=(A=(C=_[t$2]()).getSelectionKeys)==null?void 0:A.call(C))!=null?E:[]:Array.isArray(_)?c$1(_,s$1):c$1(Object.values(_),s$1):[]},c$1=(_,E)=>_.reduce((A,C)=>A.concat(E(C)),[]);function a$2(_){return Object.assign(_,{optional:()=>h$2(_),and:E=>d$1(_,E),or:E=>y$1(_,E),select:E=>E===void 0?v$1(_):v$1(E,_)})}function h$2(_){return a$2({[t$2]:()=>({match:E=>{let A={};const C=(P,D)=>{A[P]=D};return E===void 0?(s$1(_).forEach(P=>C(P,void 0)),{matched:!0,selections:A}):{matched:o$2(_,E,C),selections:A}},getSelectionKeys:()=>s$1(_),matcherType:"optional"})})}function d$1(..._){return a$2({[t$2]:()=>({match:E=>{let A={};const C=(P,D)=>{A[P]=D};return{matched:_.every(P=>o$2(P,E,C)),selections:A}},getSelectionKeys:()=>c$1(_,s$1),matcherType:"and"})})}function y$1(..._){return a$2({[t$2]:()=>({match:E=>{let A={};const C=(P,D)=>{A[P]=D};return c$1(_,s$1).forEach(P=>C(P,void 0)),{matched:_.some(P=>o$2(P,E,C)),selections:A}},getSelectionKeys:()=>c$1(_,s$1),matcherType:"or"})})}function p$2(_){return{[t$2]:()=>({match:E=>({matched:!!_(E)})})}}function v$1(..._){const E=typeof _[0]=="string"?_[0]:void 0,A=_.length===2?_[1]:typeof _[0]=="string"?void 0:_[0];return a$2({[t$2]:()=>({match:C=>{let P={[E??n$2]:C};return{matched:A===void 0||o$2(A,C,(D,U)=>{P[D]=U}),selections:P}},getSelectionKeys:()=>[E??n$2].concat(A===void 0?[]:s$1(A))})})}function b$2(_){return!0}function w$2(_){return typeof _=="number"}function S$1(_){return typeof _=="string"}function j$1(_){return typeof _=="bigint"}a$2(p$2(b$2));a$2(p$2(b$2));const x$3=_=>Object.assign(a$2(_),{startsWith:E=>{return x$3(d$1(_,(A=E,p$2(C=>S$1(C)&&C.startsWith(A)))));var A},endsWith:E=>{return x$3(d$1(_,(A=E,p$2(C=>S$1(C)&&C.endsWith(A)))));var A},minLength:E=>x$3(d$1(_,(A=>p$2(C=>S$1(C)&&C.length>=A))(E))),length:E=>x$3(d$1(_,(A=>p$2(C=>S$1(C)&&C.length===A))(E))),maxLength:E=>x$3(d$1(_,(A=>p$2(C=>S$1(C)&&C.length<=A))(E))),includes:E=>{return x$3(d$1(_,(A=E,p$2(C=>S$1(C)&&C.includes(A)))));var A},regex:E=>{return x$3(d$1(_,(A=E,p$2(C=>S$1(C)&&!!C.match(A)))));var A}});x$3(p$2(S$1));const N$1=_=>Object.assign(a$2(_),{between:(E,A)=>N$1(d$1(_,((C,P)=>p$2(D=>w$2(D)&&C<=D&&P>=D))(E,A))),lt:E=>N$1(d$1(_,(A=>p$2(C=>w$2(C)&&C<A))(E))),gt:E=>N$1(d$1(_,(A=>p$2(C=>w$2(C)&&C>A))(E))),lte:E=>N$1(d$1(_,(A=>p$2(C=>w$2(C)&&C<=A))(E))),gte:E=>N$1(d$1(_,(A=>p$2(C=>w$2(C)&&C>=A))(E))),int:()=>N$1(d$1(_,p$2(E=>w$2(E)&&Number.isInteger(E)))),finite:()=>N$1(d$1(_,p$2(E=>w$2(E)&&Number.isFinite(E)))),positive:()=>N$1(d$1(_,p$2(E=>w$2(E)&&E>0))),negative:()=>N$1(d$1(_,p$2(E=>w$2(E)&&E<0)))});N$1(p$2(w$2));const k$1=_=>Object.assign(a$2(_),{between:(E,A)=>k$1(d$1(_,((C,P)=>p$2(D=>j$1(D)&&C<=D&&P>=D))(E,A))),lt:E=>k$1(d$1(_,(A=>p$2(C=>j$1(C)&&C<A))(E))),gt:E=>k$1(d$1(_,(A=>p$2(C=>j$1(C)&&C>A))(E))),lte:E=>k$1(d$1(_,(A=>p$2(C=>j$1(C)&&C<=A))(E))),gte:E=>k$1(d$1(_,(A=>p$2(C=>j$1(C)&&C>=A))(E))),positive:()=>k$1(d$1(_,p$2(E=>j$1(E)&&E>0))),negative:()=>k$1(d$1(_,p$2(E=>j$1(E)&&E<0)))});k$1(p$2(j$1));a$2(p$2(function(_){return typeof _=="boolean"}));a$2(p$2(function(_){return typeof _=="symbol"}));a$2(p$2(function(_){return _==null}));a$2(p$2(function(_){return _!=null}));class I extends Error{constructor(E){let A;try{A=JSON.stringify(E)}catch{A=E}super(`Pattern matching error: no pattern matches value ${A}`),this.input=void 0,this.input=E}}const L={matched:!1,value:void 0};function M$2(_){return new R(_,L)}class R{constructor(E,A){this.input=void 0,this.state=void 0,this.input=E,this.state=A}with(...E){if(this.state.matched)return this;const A=E[E.length-1],C=[E[0]];let P;E.length===3&&typeof E[1]=="function"?P=E[1]:E.length>2&&C.push(...E.slice(1,E.length-1));let D=!1,U={};const G=(q,Z)=>{D=!0,U[q]=Z},X=!C.some(q=>o$2(q,this.input,G))||P&&!P(this.input)?L:{matched:!0,value:A(D?n$2 in U?U[n$2]:U:this.input,this.input)};return new R(this.input,X)}when(E,A){if(this.state.matched)return this;const C=!!E(this.input);return new R(this.input,C?{matched:!0,value:A(this.input,this.input)}:L)}otherwise(E){return this.state.matched?this.state.value:E(this.input)}exhaustive(E=F){return this.state.matched?this.state.value:E(this.input)}run(){return this.exhaustive()}returnType(){return this}narrow(){return this}}function F(_){throw new I(_)}function T(_,E,A,C,P){const D=Math.abs(A-_),U=_<A?1:-1,G=-Math.abs(C-E),X=E<C?1:-1;let q=D+G,Z;for(;;){if(P(_,E),Z=2*q,Z>=G){if(_===A)break;q+=G,_+=U}if(Z<=D){if(E===C)break;q+=D,E+=X}}}function x$2(_,E,A,C){var P=-A,D=0,U=2-2*A;do C(_-P,E+D),C(_-D,E-P),C(_+P,E-D),C(_+D,E+P),A=U,A<=D&&(U+=++D*2+1),(A>P||U>D)&&(U+=++P*2+1);while(P<0)}function deleteDuplicates(_){const E=[];for(let A=0;A<_.length;A++)_[A].column===_[(A+1)%_.length].column&&_[A].row===_[(A+1)%_.length].row||E.push(_[A]);return E}function getIndex(_,E,A,C=0){return(E*A.width+_)*A.channels+C}const formatter=new Intl.ListFormat("en",{type:"disjunction"});function checkProcessable(_,E={}){let{bitDepth:A,alpha:C,colorModel:P,components:D,channels:U}=E;if(A&&(Array.isArray(A)||(A=[A]),!A.includes(_.bitDepth)))throw new RangeError(`image bitDepth must be ${format(A)} to apply this algorithm`);if(C&&(Array.isArray(C)||(C=[C]),!C.includes(_.alpha)))throw new RangeError(`image alpha must be ${format(C)} to apply this algorithm`);if(P&&(Array.isArray(P)||(P=[P]),!P.includes(_.colorModel)))throw new RangeError(`image colorModel must be ${format(P)} to apply this algorithm`);if(D&&(Array.isArray(D)||(D=[D]),!D.includes(_.components))){const G=`image components must be ${format(D)} to apply this algorithm`;throw D.length===1&&D[0]===1?new RangeError(`${G}. The image can be converted using "image.grey()"`):new RangeError(G)}if(U&&(Array.isArray(U)||(U=[U]),!U.includes(_.channels)))throw new RangeError(`image channels must be ${format(U)} to apply this algorithm`)}function format(_){return formatter.format(_.map(String))}const SOBEL_X=[[-1,0,1],[-2,0,2],[-1,0,1]],SOBEL_Y=[[-1,-2,-1],[0,0,0],[1,2,1]],SCHARR_X=[[3,0,-3],[10,0,-10],[3,0,-3]],SCHARR_Y=[[3,10,3],[0,0,0],[-3,-10,-3]],PREWITT_X=[[1,0,-1],[1,0,-1],[1,0,-1]],PREWITT_Y=[[1,1,1],[0,0,0],[-1,-1,-1]];function xMedian(_,E={}){if(!isAnyArray(_))throw new TypeError("input must be an array");if(_.length===0)throw new TypeError("input must not be empty");const{exact:A=!1}=E||{},C=_.slice(),P=calcMiddle(0,C.length-1),D=quickSelect(C,P);if(C.length%2===1||!A)return D;const U=quickSelect(C,P+1);return(D+U)/2}function quickSelect(_,E){let A=0,C=_.length-1,P=0,D=0,U=0;for(;;){if(C<=A)return _[E];if(C===A+1)return _[A]>_[C]&&swap(_,A,C),_[E];for(P=calcMiddle(A,C),_[P]>_[C]&&swap(_,P,C),_[A]>_[C]&&swap(_,A,C),_[P]>_[A]&&swap(_,P,A),swap(_,P,A+1),D=A+1,U=C;;){do D++;while(_[A]>_[D]);do U--;while(_[U]>_[A]);if(U<D)break;swap(_,D,U)}swap(_,A,U),U<=E&&(A=D),U>=E&&(C=U-1)}}function swap(_,E,A){const C=_[A];_[A]=_[E],_[E]=C}function calcMiddle(_,E){return Math.floor((_+E)/2)}var fft,hasRequiredFft;function requireFft(){if(hasRequiredFft)return fft;hasRequiredFft=1;function _(E){if(this.size=E|0,this.size<=1||(this.size&this.size-1)!==0)throw new Error("FFT size must be a power of two and bigger than 1");this._csize=E<<1;for(var A=new Array(this.size*2),C=0;C<A.length;C+=2){const q=Math.PI*C/this.size;A[C]=Math.cos(q),A[C+1]=-Math.sin(q)}this.table=A;for(var P=0,D=1;this.size>D;D<<=1)P++;this._width=P%2===0?P-1:P,this._bitrev=new Array(1<<this._width);for(var U=0;U<this._bitrev.length;U++){this._bitrev[U]=0;for(var G=0;G<this._width;G+=2){var X=this._width-G-2;this._bitrev[U]|=(U>>>G&3)<<X}}this._out=null,this._data=null,this._inv=0}return fft=_,_.prototype.fromComplexArray=function(A,C){for(var P=C||new Array(A.length>>>1),D=0;D<A.length;D+=2)P[D>>>1]=A[D];return P},_.prototype.createComplexArray=function(){const A=new Array(this._csize);for(var C=0;C<A.length;C++)A[C]=0;return A},_.prototype.toComplexArray=function(A,C){for(var P=C||this.createComplexArray(),D=0;D<P.length;D+=2)P[D]=A[D>>>1],P[D+1]=0;return P},_.prototype.completeSpectrum=function(A){for(var C=this._csize,P=C>>>1,D=2;D<P;D+=2)A[C-D]=A[D],A[C-D+1]=-A[D+1]},_.prototype.transform=function(A,C){if(A===C)throw new Error("Input and output buffers must be different");this._out=A,this._data=C,this._inv=0,this._transform4(),this._out=null,this._data=null},_.prototype.realTransform=function(A,C){if(A===C)throw new Error("Input and output buffers must be different");this._out=A,this._data=C,this._inv=0,this._realTransform4(),this._out=null,this._data=null},_.prototype.inverseTransform=function(A,C){if(A===C)throw new Error("Input and output buffers must be different");this._out=A,this._data=C,this._inv=1,this._transform4();for(var P=0;P<A.length;P++)A[P]/=this.size;this._out=null,this._data=null},_.prototype._transform4=function(){var A=this._out,C=this._csize,P=this._width,D=1<<P,U=C/D<<1,G,X,q=this._bitrev;if(U===4)for(G=0,X=0;G<C;G+=U,X++){const xt=q[X];this._singleTransform2(G,xt,D)}else for(G=0,X=0;G<C;G+=U,X++){const xt=q[X];this._singleTransform4(G,xt,D)}var Z=this._inv?-1:1,K=this.table;for(D>>=2;D>=2;D>>=2){U=C/D<<1;var J=U>>>2;for(G=0;G<C;G+=U)for(var Q=G+J,ht=G,Et=0;ht<Q;ht+=2,Et+=D){const xt=ht,gt=xt+J,bt=gt+J,rt=bt+J,tt=A[xt],at=A[xt+1],wt=A[gt],yt=A[gt+1],lt=A[bt],ct=A[bt+1],ut=A[rt],dt=A[rt+1],_t=tt,Ft=at,Pt=K[Et],Ot=Z*K[Et+1],ne=wt*Pt-yt*Ot,he=wt*Ot+yt*Pt,Xt=K[2*Et],Wt=Z*K[2*Et+1],Kt=lt*Xt-ct*Wt,de=lt*Wt+ct*Xt,Ct=K[3*Et],te=Z*K[3*Et+1],jt=ut*Ct-dt*te,Mt=ut*te+dt*Ct,qt=_t+Kt,oe=Ft+de,se=_t-Kt,ue=Ft-de,ye=ne+jt,pe=he+Mt,Ee=Z*(ne-jt),we=Z*(he-Mt),zt=qt+ye,Dt=oe+pe,be=qt-ye,ae=oe-pe,ce=se+we,It=ue-Ee,Qt=se-we,Zt=ue+Ee;A[xt]=zt,A[xt+1]=Dt,A[gt]=ce,A[gt+1]=It,A[bt]=be,A[bt+1]=ae,A[rt]=Qt,A[rt+1]=Zt}}},_.prototype._singleTransform2=function(A,C,P){const D=this._out,U=this._data,G=U[C],X=U[C+1],q=U[C+P],Z=U[C+P+1],K=G+q,J=X+Z,Q=G-q,ht=X-Z;D[A]=K,D[A+1]=J,D[A+2]=Q,D[A+3]=ht},_.prototype._singleTransform4=function(A,C,P){const D=this._out,U=this._data,G=this._inv?-1:1,X=P*2,q=P*3,Z=U[C],K=U[C+1],J=U[C+P],Q=U[C+P+1],ht=U[C+X],Et=U[C+X+1],xt=U[C+q],gt=U[C+q+1],bt=Z+ht,rt=K+Et,tt=Z-ht,at=K-Et,wt=J+xt,yt=Q+gt,lt=G*(J-xt),ct=G*(Q-gt),ut=bt+wt,dt=rt+yt,_t=tt+ct,Ft=at-lt,Pt=bt-wt,Ot=rt-yt,ne=tt-ct,he=at+lt;D[A]=ut,D[A+1]=dt,D[A+2]=_t,D[A+3]=Ft,D[A+4]=Pt,D[A+5]=Ot,D[A+6]=ne,D[A+7]=he},_.prototype._realTransform4=function(){var A=this._out,C=this._csize,P=this._width,D=1<<P,U=C/D<<1,G,X,q=this._bitrev;if(U===4)for(G=0,X=0;G<C;G+=U,X++){const Re=q[X];this._singleRealTransform2(G,Re>>>1,D>>>1)}else for(G=0,X=0;G<C;G+=U,X++){const Re=q[X];this._singleRealTransform4(G,Re>>>1,D>>>1)}var Z=this._inv?-1:1,K=this.table;for(D>>=2;D>=2;D>>=2){U=C/D<<1;var J=U>>>1,Q=J>>>1,ht=Q>>>1;for(G=0;G<C;G+=U)for(var Et=0,xt=0;Et<=ht;Et+=2,xt+=D){var gt=G+Et,bt=gt+Q,rt=bt+Q,tt=rt+Q,at=A[gt],wt=A[gt+1],yt=A[bt],lt=A[bt+1],ct=A[rt],ut=A[rt+1],dt=A[tt],_t=A[tt+1],Ft=at,Pt=wt,Ot=K[xt],ne=Z*K[xt+1],he=yt*Ot-lt*ne,Xt=yt*ne+lt*Ot,Wt=K[2*xt],Kt=Z*K[2*xt+1],de=ct*Wt-ut*Kt,Ct=ct*Kt+ut*Wt,te=K[3*xt],jt=Z*K[3*xt+1],Mt=dt*te-_t*jt,qt=dt*jt+_t*te,oe=Ft+de,se=Pt+Ct,ue=Ft-de,ye=Pt-Ct,pe=he+Mt,Ee=Xt+qt,we=Z*(he-Mt),zt=Z*(Xt-qt),Dt=oe+pe,be=se+Ee,ae=ue+zt,ce=ye-we;if(A[gt]=Dt,A[gt+1]=be,A[bt]=ae,A[bt+1]=ce,Et===0){var It=oe-pe,Qt=se-Ee;A[rt]=It,A[rt+1]=Qt;continue}if(Et!==ht){var Zt=ue,Jt=-ye,ge=oe,me=-se,Me=-Z*zt,Ut=-Z*we,Yt=-Z*Ee,re=-Z*pe,Gt=Zt+Me,xe=Jt+Ut,Ie=ge+re,fe=me-Yt,_e=G+Q-Et,ve=G+J-Et;A[_e]=Gt,A[_e+1]=xe,A[ve]=Ie,A[ve+1]=fe}}}},_.prototype._singleRealTransform2=function(A,C,P){const D=this._out,U=this._data,G=U[C],X=U[C+P],q=G+X,Z=G-X;D[A]=q,D[A+1]=0,D[A+2]=Z,D[A+3]=0},_.prototype._singleRealTransform4=function(A,C,P){const D=this._out,U=this._data,G=this._inv?-1:1,X=P*2,q=P*3,Z=U[C],K=U[C+P],J=U[C+X],Q=U[C+q],ht=Z+J,Et=Z-J,xt=K+Q,gt=G*(K-Q),bt=ht+xt,rt=Et,tt=-gt,at=ht-xt,wt=Et,yt=gt;D[A]=bt,D[A+1]=0,D[A+2]=rt,D[A+3]=tt,D[A+4]=at,D[A+5]=0,D[A+6]=wt,D[A+7]=yt},fft}requireFft();function assert(_,E){if(!_)throw new Error(E||"unreachable")}function assertUnreachable(_){throw new Error(`unreachable: ${String(_)}`)}function getClamp(_){return _.maxValue===255?clamp255:(assert(_.maxValue===65535),clamp65535)}function clamp255(_){return Math.min(Math.max(_,0),255)}function clamp65535(_){return Math.min(Math.max(_,0),65535)}function validateChannels(_,E){for(const A of _)validateChannel(A,E)}function validateChannel(_,E){if(!Number.isInteger(_)||_>=E.channels||_<0)throw new RangeError(`invalid channel: ${_}. It must be a positive integer smaller than ${E.channels}`)}function validateValues(_,E){for(const A of _)validateValue(A,E)}function validateValue(_,E){if(_>E.maxValue||_<0)throw new RangeError(`invalid value: ${_}. It must be a positive value smaller than ${E.maxValue+1}`)}function validateForComparison(_,E){if(_.width!==E.width||_.height!==E.height)throw new RangeError("both images must have the same size");if(_.alpha!==E.alpha||_.bitDepth!==E.bitDepth)throw new RangeError("both images must have the same alpha and bitDepth");if(_.channels!==E.channels)throw new RangeError("both images must have the same number of channels")}function validateColor(_,E){validateChannel(_.length-1,E),validateValues(_,E)}function divide(_,E,A={}){const{channels:C=new Array(_.channels).fill(0).map((D,U)=>U)}=A;if(validateChannels(C,_),E===0)throw new TypeError("Cannot divide by 0");const P=getOutputImage(_,A,{clone:!0});if(C.length===0)return P;for(const D of C)for(let U=0;U<P.height;U++)for(let G=0;G<P.width;G++){const X=P.getValue(G,U,D)/E;P.setClampedValue(G,U,D,X)}return P}function getDefaultColor(_){return M$2(_.colorModel).with("GREY",()=>[0]).with("GREYA",()=>[0,_.maxValue]).with("RGB",()=>[0,0,0]).with("RGBA",()=>[0,0,0,_.maxValue]).with("BINARY",()=>[1]).exhaustive()}function setBlendedPixel(_,E,A,C){if(C=C??getDefaultColor(_),!_.alpha)_.setPixel(E,A,C);else{assert(_ instanceof Image);const P=C.at(-1);if(P===_.maxValue){_.setPixel(E,A,C);return}const D=_.getValue(E,A,_.channels-1),U=P+D*(1-P/_.maxValue);_.setValue(E,A,_.channels-1,U);for(let G=0;G<_.components;G++){const X=C[G],q=_.getValue(E,A,G),Z=(X*P+q*D*(1-P/_.maxValue))/U;_.setValue(E,A,G,Z)}}}function setBlendedVisiblePixel(_,E,A,C){E>=0&&E<_.width&&A>=0&&A<_.height&&setBlendedPixel(_,E,A,C)}function roundPoint(_){return{row:Math.round(_.row),column:Math.round(_.column)}}function drawCircleOnImage(_,E,A,C={}){const P=getOutputImage(_,C,{clone:!0}),{strokeColor:D=getDefaultColor(P),fillColor:U}=C;if(validateColor(D,P),checkProcessable(P,{bitDepth:[8,16]}),A<0)throw new RangeError("circle radius must be positive");if(E=roundPoint(E),A=Math.round(A),A===0)return setBlendedVisiblePixel(P,E.column,E.row,D),P;if(!U)x$2(E.column,E.row,A,(G,X)=>{setBlendedVisiblePixel(P,G,X,D)});else{A===1&&setBlendedVisiblePixel(P,E.column,E.row,U);let G=E.row+A,X=0;x$2(E.column,E.row,A,(q,Z)=>{setBlendedVisiblePixel(P,q,Z,D),X===0&&P.drawLine({row:Z,column:q-1},{row:Z,column:E.column-(q-E.column-1)},{strokeColor:U,out:P}),X%4===1&&G!==Z&&(P.drawLine({row:Z,column:q+1},{row:Z,column:E.column-(q-E.column+1)},{strokeColor:U,out:P}),G=Z,P.drawLine({row:E.row-(Z-E.row),column:q+1},{row:E.row-(Z-E.row),column:E.column-(q-E.column+1)},{strokeColor:U,out:P})),X++})}return P}function drawLineOnImage(_,E,A,C={}){const P=getOutputImage(_,C,{clone:!0}),{strokeColor:D=getDefaultColor(P),origin:U={column:0,row:0}}=C;return validateColor(D,P),checkProcessable(P,{bitDepth:[8,16]}),T(Math.round(U.column+E.column),Math.round(U.row+E.row),Math.round(U.column+A.column),Math.round(U.row+A.row),(G,X)=>{setBlendedVisiblePixel(P,G,X,D)}),P}function drawLineOnMask(_,E,A,C={}){const{origin:P={column:0,row:0}}=C,D=maskToOutputMask(_,C,{clone:!0});return T(Math.round(P.column+E.column),Math.round(P.row+E.row),Math.round(P.column+A.column),Math.round(P.row+A.row),(U,G)=>{D.setVisiblePixel(U,G,[1])}),D}function drawPolylineOnImage(_,E,A={}){const{strokeColor:C=getDefaultColor(_),origin:P={column:0,row:0}}=A;checkProcessable(_,{bitDepth:[8,16]});const D=getOutputImage(_,A,{clone:!0});validateColor(C,D);for(let U=0;U<E.length-1;U++){const G=E[U],X=E[U+1];D.drawLine(G,X,{out:D,strokeColor:C,origin:P})}return D}function drawPolylineOnMask(_,E,A={}){const C=maskToOutputMask(_,A,{clone:!0});for(let P=0;P<E.length-1;P++){const D=E[P],U=E[P+1];C.drawLine(D,U,{out:C,origin:A.origin})}return C}var orientation={exports:{}},twoProduct_1,hasRequiredTwoProduct;function requireTwoProduct(){if(hasRequiredTwoProduct)return twoProduct_1;hasRequiredTwoProduct=1,twoProduct_1=E;var _=+(Math.pow(2,27)+1);function E(A,C,P){var D=A*C,U=_*A,G=U-A,X=U-G,q=A-X,Z=_*C,K=Z-C,J=Z-K,Q=C-J,ht=D-X*J,Et=ht-q*J,xt=Et-X*Q,gt=q*Q-xt;return P?(P[0]=gt,P[1]=D,P):[gt,D]}return twoProduct_1}var robustSum,hasRequiredRobustSum;function requireRobustSum(){if(hasRequiredRobustSum)return robustSum;hasRequiredRobustSum=1,robustSum=E;function _(A,C){var P=A+C,D=P-A,U=P-D,G=C-D,X=A-U,q=X+G;return q?[q,P]:[P]}function E(A,C){var P=A.length|0,D=C.length|0;if(P===1&&D===1)return _(A[0],C[0]);var U=P+D,G=new Array(U),X=0,q=0,Z=0,K=Math.abs,J=A[q],Q=K(J),ht=C[Z],Et=K(ht),xt,gt;Q<Et?(gt=J,q+=1,q<P&&(J=A[q],Q=K(J))):(gt=ht,Z+=1,Z<D&&(ht=C[Z],Et=K(ht))),q<P&&Q<Et||Z>=D?(xt=J,q+=1,q<P&&(J=A[q],Q=K(J))):(xt=ht,Z+=1,Z<D&&(ht=C[Z],Et=K(ht)));for(var bt=xt+gt,rt=bt-xt,tt=gt-rt,at=tt,wt=bt,yt,lt,ct,ut,dt;q<P&&Z<D;)Q<Et?(xt=J,q+=1,q<P&&(J=A[q],Q=K(J))):(xt=ht,Z+=1,Z<D&&(ht=C[Z],Et=K(ht))),gt=at,bt=xt+gt,rt=bt-xt,tt=gt-rt,tt&&(G[X++]=tt),yt=wt+bt,lt=yt-wt,ct=yt-lt,ut=bt-lt,dt=wt-ct,at=dt+ut,wt=yt;for(;q<P;)xt=J,gt=at,bt=xt+gt,rt=bt-xt,tt=gt-rt,tt&&(G[X++]=tt),yt=wt+bt,lt=yt-wt,ct=yt-lt,ut=bt-lt,dt=wt-ct,at=dt+ut,wt=yt,q+=1,q<P&&(J=A[q]);for(;Z<D;)xt=ht,gt=at,bt=xt+gt,rt=bt-xt,tt=gt-rt,tt&&(G[X++]=tt),yt=wt+bt,lt=yt-wt,ct=yt-lt,ut=bt-lt,dt=wt-ct,at=dt+ut,wt=yt,Z+=1,Z<D&&(ht=C[Z]);return at&&(G[X++]=at),wt&&(G[X++]=wt),X||(G[X++]=0),G.length=X,G}return robustSum}var twoSum,hasRequiredTwoSum;function requireTwoSum(){if(hasRequiredTwoSum)return twoSum;hasRequiredTwoSum=1,twoSum=_;function _(E,A,C){var P=E+A,D=P-E,U=P-D,G=A-D,X=E-U;return C?(C[0]=X+G,C[1]=P,C):[X+G,P]}return twoSum}var robustScale,hasRequiredRobustScale;function requireRobustScale(){if(hasRequiredRobustScale)return robustScale;hasRequiredRobustScale=1;var _=requireTwoProduct(),E=requireTwoSum();robustScale=A;function A(C,P){var D=C.length;if(D===1){var U=_(C[0],P);return U[0]?U:[U[1]]}var G=new Array(2*D),X=[.1,.1],q=[.1,.1],Z=0;_(C[0],P,X),X[0]&&(G[Z++]=X[0]);for(var K=1;K<D;++K){_(C[K],P,q);var J=X[1];E(J,q[0],X),X[0]&&(G[Z++]=X[0]);var Q=q[1],ht=X[1],Et=Q+ht,xt=Et-Q,gt=ht-xt;X[1]=Et,gt&&(G[Z++]=gt)}return X[1]&&(G[Z++]=X[1]),Z===0&&(G[Z++]=0),G.length=Z,G}return robustScale}var robustDiff,hasRequiredRobustDiff;function requireRobustDiff(){if(hasRequiredRobustDiff)return robustDiff;hasRequiredRobustDiff=1,robustDiff=E;function _(A,C){var P=A+C,D=P-A,U=P-D,G=C-D,X=A-U,q=X+G;return q?[q,P]:[P]}function E(A,C){var P=A.length|0,D=C.length|0;if(P===1&&D===1)return _(A[0],-C[0]);var U=P+D,G=new Array(U),X=0,q=0,Z=0,K=Math.abs,J=A[q],Q=K(J),ht=-C[Z],Et=K(ht),xt,gt;Q<Et?(gt=J,q+=1,q<P&&(J=A[q],Q=K(J))):(gt=ht,Z+=1,Z<D&&(ht=-C[Z],Et=K(ht))),q<P&&Q<Et||Z>=D?(xt=J,q+=1,q<P&&(J=A[q],Q=K(J))):(xt=ht,Z+=1,Z<D&&(ht=-C[Z],Et=K(ht)));for(var bt=xt+gt,rt=bt-xt,tt=gt-rt,at=tt,wt=bt,yt,lt,ct,ut,dt;q<P&&Z<D;)Q<Et?(xt=J,q+=1,q<P&&(J=A[q],Q=K(J))):(xt=ht,Z+=1,Z<D&&(ht=-C[Z],Et=K(ht))),gt=at,bt=xt+gt,rt=bt-xt,tt=gt-rt,tt&&(G[X++]=tt),yt=wt+bt,lt=yt-wt,ct=yt-lt,ut=bt-lt,dt=wt-ct,at=dt+ut,wt=yt;for(;q<P;)xt=J,gt=at,bt=xt+gt,rt=bt-xt,tt=gt-rt,tt&&(G[X++]=tt),yt=wt+bt,lt=yt-wt,ct=yt-lt,ut=bt-lt,dt=wt-ct,at=dt+ut,wt=yt,q+=1,q<P&&(J=A[q]);for(;Z<D;)xt=ht,gt=at,bt=xt+gt,rt=bt-xt,tt=gt-rt,tt&&(G[X++]=tt),yt=wt+bt,lt=yt-wt,ct=yt-lt,ut=bt-lt,dt=wt-ct,at=dt+ut,wt=yt,Z+=1,Z<D&&(ht=-C[Z]);return at&&(G[X++]=at),wt&&(G[X++]=wt),X||(G[X++]=0),G.length=X,G}return robustDiff}var hasRequiredOrientation;function requireOrientation(){return hasRequiredOrientation||(hasRequiredOrientation=1,(function(_){var E=requireTwoProduct(),A=requireRobustSum(),C=requireRobustScale(),P=requireRobustDiff(),D=5,U=11102230246251565e-32,G=(3+16*U)*U,X=(7+56*U)*U;function q(rt,tt,at,wt){return function(lt,ct,ut){var dt=rt(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0]))),_t=rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),Ft=wt(dt,_t);return Ft[Ft.length-1]}}function Z(rt,tt,at,wt){return function(lt,ct,ut,dt){var _t=rt(rt(at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),ct[2]),rt(at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),-ut[2]),at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),dt[2]))),rt(at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),dt[2])))),Ft=rt(rt(at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),lt[2]),rt(at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),-ut[2]),at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),dt[2]))),rt(at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),ut[2])))),Pt=wt(_t,Ft);return Pt[Pt.length-1]}}function K(rt,tt,at,wt){return function(lt,ct,ut,dt,_t){var Ft=rt(rt(rt(at(rt(at(rt(tt(dt[1],_t[0]),tt(-_t[1],dt[0])),ut[2]),rt(at(rt(tt(ut[1],_t[0]),tt(-_t[1],ut[0])),-dt[2]),at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),_t[2]))),ct[3]),rt(at(rt(at(rt(tt(dt[1],_t[0]),tt(-_t[1],dt[0])),ct[2]),rt(at(rt(tt(ct[1],_t[0]),tt(-_t[1],ct[0])),-dt[2]),at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),_t[2]))),-ut[3]),at(rt(at(rt(tt(ut[1],_t[0]),tt(-_t[1],ut[0])),ct[2]),rt(at(rt(tt(ct[1],_t[0]),tt(-_t[1],ct[0])),-ut[2]),at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),_t[2]))),dt[3]))),rt(at(rt(at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),ct[2]),rt(at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),-ut[2]),at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),dt[2]))),-_t[3]),rt(at(rt(at(rt(tt(dt[1],_t[0]),tt(-_t[1],dt[0])),ct[2]),rt(at(rt(tt(ct[1],_t[0]),tt(-_t[1],ct[0])),-dt[2]),at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),_t[2]))),lt[3]),at(rt(at(rt(tt(dt[1],_t[0]),tt(-_t[1],dt[0])),lt[2]),rt(at(rt(tt(lt[1],_t[0]),tt(-_t[1],lt[0])),-dt[2]),at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),_t[2]))),-ct[3])))),rt(rt(at(rt(at(rt(tt(ct[1],_t[0]),tt(-_t[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],_t[0]),tt(-_t[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),_t[2]))),dt[3]),rt(at(rt(at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),dt[2]))),-_t[3]),at(rt(at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),ct[2]),rt(at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),-ut[2]),at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),dt[2]))),lt[3]))),rt(at(rt(at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),lt[2]),rt(at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),-ut[2]),at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),dt[2]))),-ct[3]),rt(at(rt(at(rt(tt(ct[1],dt[0]),tt(-dt[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),dt[2]))),ut[3]),at(rt(at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),ut[2]))),-dt[3]))))),Pt=rt(rt(rt(at(rt(at(rt(tt(dt[1],_t[0]),tt(-_t[1],dt[0])),ut[2]),rt(at(rt(tt(ut[1],_t[0]),tt(-_t[1],ut[0])),-dt[2]),at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),_t[2]))),lt[3]),at(rt(at(rt(tt(dt[1],_t[0]),tt(-_t[1],dt[0])),lt[2]),rt(at(rt(tt(lt[1],_t[0]),tt(-_t[1],lt[0])),-dt[2]),at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),_t[2]))),-ut[3])),rt(at(rt(at(rt(tt(ut[1],_t[0]),tt(-_t[1],ut[0])),lt[2]),rt(at(rt(tt(lt[1],_t[0]),tt(-_t[1],lt[0])),-ut[2]),at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),_t[2]))),dt[3]),at(rt(at(rt(tt(ut[1],dt[0]),tt(-dt[1],ut[0])),lt[2]),rt(at(rt(tt(lt[1],dt[0]),tt(-dt[1],lt[0])),-ut[2]),at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),dt[2]))),-_t[3]))),rt(rt(at(rt(at(rt(tt(ut[1],_t[0]),tt(-_t[1],ut[0])),ct[2]),rt(at(rt(tt(ct[1],_t[0]),tt(-_t[1],ct[0])),-ut[2]),at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),_t[2]))),lt[3]),at(rt(at(rt(tt(ut[1],_t[0]),tt(-_t[1],ut[0])),lt[2]),rt(at(rt(tt(lt[1],_t[0]),tt(-_t[1],lt[0])),-ut[2]),at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),_t[2]))),-ct[3])),rt(at(rt(at(rt(tt(ct[1],_t[0]),tt(-_t[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],_t[0]),tt(-_t[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),_t[2]))),ut[3]),at(rt(at(rt(tt(ct[1],ut[0]),tt(-ut[1],ct[0])),lt[2]),rt(at(rt(tt(lt[1],ut[0]),tt(-ut[1],lt[0])),-ct[2]),at(rt(tt(lt[1],ct[0]),tt(-ct[1],lt[0])),ut[2]))),-_t[3])))),Ot=wt(Ft,Pt);return Ot[Ot.length-1]}}function J(rt){var tt=rt===3?q:rt===4?Z:K;return tt(A,E,C,P)}var Q=J(3),ht=J(4),Et=[function(){return 0},function(){return 0},function(tt,at){return at[0]-tt[0]},function(tt,at,wt){var yt=(tt[1]-wt[1])*(at[0]-wt[0]),lt=(tt[0]-wt[0])*(at[1]-wt[1]),ct=yt-lt,ut;if(yt>0){if(lt<=0)return ct;ut=yt+lt}else if(yt<0){if(lt>=0)return ct;ut=-(yt+lt)}else return ct;var dt=G*ut;return ct>=dt||ct<=-dt?ct:Q(tt,at,wt)},function(tt,at,wt,yt){var lt=tt[0]-yt[0],ct=at[0]-yt[0],ut=wt[0]-yt[0],dt=tt[1]-yt[1],_t=at[1]-yt[1],Ft=wt[1]-yt[1],Pt=tt[2]-yt[2],Ot=at[2]-yt[2],ne=wt[2]-yt[2],he=ct*Ft,Xt=ut*_t,Wt=ut*dt,Kt=lt*Ft,de=lt*_t,Ct=ct*dt,te=Pt*(he-Xt)+Ot*(Wt-Kt)+ne*(de-Ct),jt=(Math.abs(he)+Math.abs(Xt))*Math.abs(Pt)+(Math.abs(Wt)+Math.abs(Kt))*Math.abs(Ot)+(Math.abs(de)+Math.abs(Ct))*Math.abs(ne),Mt=X*jt;return te>Mt||-te>Mt?te:ht(tt,at,wt,yt)}];function xt(rt){var tt=Et[rt.length];return tt||(tt=Et[rt.length]=J(rt.length)),tt.apply(void 0,rt)}function gt(rt,tt,at,wt,yt,lt,ct){return function(dt,_t,Ft,Pt,Ot){switch(arguments.length){case 0:case 1:return 0;case 2:return wt(dt,_t);case 3:return yt(dt,_t,Ft);case 4:return lt(dt,_t,Ft,Pt);case 5:return ct(dt,_t,Ft,Pt,Ot)}for(var ne=new Array(arguments.length),he=0;he<arguments.length;++he)ne[he]=arguments[he];return rt(ne)}}function bt(){for(;Et.length<=D;)Et.push(J(Et.length));_.exports=gt.apply(void 0,[xt].concat(Et));for(var rt=0;rt<=D;++rt)_.exports[rt]=Et[rt]}bt()})(orientation)),orientation.exports}var robustPnp,hasRequiredRobustPnp;function requireRobustPnp(){if(hasRequiredRobustPnp)return robustPnp;hasRequiredRobustPnp=1,robustPnp=E;var _=requireOrientation();function E(A,C){for(var P=C[0],D=C[1],U=A.length,G=1,X=U,q=0,Z=U-1;q<X;Z=q++){var K=A[q],J=A[Z],Q=K[1],ht=J[1];if(ht<Q){if(ht<D&&D<Q){var Et=_(K,J,C);if(Et===0)return 0;G^=0<Et|0}else if(D===Q){var xt=A[(q+1)%U],gt=xt[1];if(Q<gt){var Et=_(K,J,C);if(Et===0)return 0;G^=0<Et|0}}}else if(Q<ht){if(Q<D&&D<ht){var Et=_(K,J,C);if(Et===0)return 0;G^=Et<0|0}else if(D===Q){var xt=A[(q+1)%U],gt=xt[1];if(gt<Q){var Et=_(K,J,C);if(Et===0)return 0;G^=Et<0|0}}}else if(D===Q){var bt=Math.min(K[0],J[0]),rt=Math.max(K[0],J[0]);if(q===0){for(;Z>0;){var tt=(Z+U-1)%U,at=A[tt];if(at[1]!==D)break;var wt=at[0];bt=Math.min(bt,wt),rt=Math.max(rt,wt),Z=tt}if(Z===0)return bt<=P&&P<=rt?0:1;X=Z+1}for(var yt=A[(Z+U-1)%U][1];q+1<X;){var at=A[q+1];if(at[1]!==D)break;var wt=at[0];bt=Math.min(bt,wt),rt=Math.max(rt,wt),q+=1}if(bt<=P&&P<=rt)return 0;var lt=A[(q+1)%U][1];P<bt&&yt<D!=lt<D&&(G^=1)}}return 2*G-1}return robustPnp}var robustPnpExports=requireRobustPnp();const robustPointInPolygon=getDefaultExportFromCjs(robustPnpExports);function arrayPointsToObjects(_){const E=[];for(const A of _)E.push([A.column,A.row]);return E}function drawPolygonOnImage(_,E,A={}){const{fillColor:C,origin:P={column:0,row:0},...D}=A;checkProcessable(_,{bitDepth:[8,16]});const U=getOutputImage(_,A,{clone:!0});if(C===void 0)return U.drawPolyline([...E,E[0]],{origin:P,...D});{validateColor(C,U);const G=deleteDuplicates(E),X=arrayPointsToObjects(G);for(let q=0;q<U.height;q++)for(let Z=0;Z<U.width;Z++)robustPointInPolygon(X,[Z,q])===-1&&setBlendedVisiblePixel(U,Math.round(P.column)+Z,Math.round(P.row)+q,C)}return U.drawPolyline([...E,E[0]],{origin:P,...D})}function drawPolygonOnMask(_,E,A={}){const{filled:C=!1,origin:P={column:0,row:0},...D}=A,U=maskToOutputMask(_,A,{clone:!0});if(!C)return U.drawPolyline([...E,E[0]],{origin:P,...D});const G=deleteDuplicates(E),X=arrayPointsToObjects(G);for(let q=0;q<U.height;q++)for(let Z=0;Z<U.width;Z++)robustPointInPolygon(X,[Z,q])===-1&&U.setBit(Math.round(P.column)+Z,Math.round(P.row)+q,1);return U.drawPolyline([...E,E[0]],{origin:P,...D})}function drawRectangle(_,E={}){const{width:A=_.width,height:C=_.height,origin:P={column:0,row:0},strokeColor:D=getDefaultColor(_),fillColor:U}=E,G=Math.round(A),X=Math.round(C),q=Math.round(P.column),Z=Math.round(P.row);let K;_ instanceof Image?(checkProcessable(_,{bitDepth:[8,16]}),validateColor(D,_),U&&validateColor(U,_),K=getOutputImage(_,E,{clone:!0})):K=maskToOutputMask(_,E,{clone:!0});for(let J=q;J<q+G;J++)setBlendedVisiblePixel(K,J,Z,D),setBlendedVisiblePixel(K,J,Z+X-1,D);for(let J=Z+1;J<Z+X-1;J++)setBlendedVisiblePixel(K,q,J,D),setBlendedVisiblePixel(K,q+G-1,J,D);if(U)for(let J=Z+1;J<Z+X-1;J++)for(let Q=q+1;Q<q+G-1;Q++)setBlendedVisiblePixel(K,Q,J,U);return K}function drawPoints(_,E,A={}){const{color:C=getDefaultColor(_),origin:P={row:0,column:0}}=A;let D;_ instanceof Image?(D=getOutputImage(_,A,{clone:!0}),validateColor(C,D)):D=maskToOutputMask(_,A,{clone:!0}),checkProcessable(D,{bitDepth:[1,8,16]});for(const U of E)setBlendedVisiblePixel(D,Math.round(P.column+U.column),Math.round(P.row+U.row),C);return D}function drawMarker(_,E,A){const C=getOutputImage(_,A,{clone:!0}),{strokeColor:P=getDefaultColor(C),fillColor:D,shape:U="cross",size:G=1}=A,X=Math.round(G);if(validateColor(P,C),D&&validateColor(D,C),checkProcessable(C,{bitDepth:[8,16]}),U==="circle"&&C.drawCircle(E,X,{strokeColor:P,fillColor:D,out:C}),U==="triangle"){const q=[{row:E.row-X,column:E.column},{row:E.row,column:E.column+X},{row:E.row,column:E.column-X}];C.drawPolygon(q,{strokeColor:P,fillColor:D,out:C})}if(U==="cross"&&(C.drawLine({row:E.row-X,column:E.column},{row:E.row+X,column:E.column},{strokeColor:P,out:C}),C.drawLine({row:E.row,column:E.column-X},{row:E.row,column:E.column+X},{strokeColor:P,out:C})),U==="square"){const q={row:E.row-(X-1)/2,column:E.column-(X-1)/2};C.drawRectangle({origin:q,width:X,height:X,strokeColor:P,fillColor:D,out:C})}return C}function drawMarkers(_,E,A={}){const C=getOutputImage(_,A,{clone:!0});for(const P of E)drawMarker(C,P,{...A,out:C});return C}function and(_,E,A){const C=maskToOutputMask(_,A);if(_.width!==E.width||_.height!==E.height)throw new RangeError("both masks must have the same size");for(let P=0;P<C.size;P++)_.getBitByIndex(P)&&E.getBitByIndex(P)?C.setBitByIndex(P,1):C.setBitByIndex(P,0);return C}function checkSize(_){if(!Number.isInteger(_)||_<1)throw new TypeError(`size must be a positive integer. Got ${_}`)}function checkKernel$1(_){if(_.length===0||_.length%2!==1)throw new RangeError(`kernel must have an odd positive length. Got ${_.length}`)}function checkBorderType(_){if(_!=="CONSTANT"&&_!=="CUT")throw new RangeError(`unexpected border type: ${_}`)}function checkInputLength(_,E){if(_!==E)throw new RangeError(`input length (${_}) does not match setup size (${E})`)}function createArray(_){const E=[];for(var A=0;A<_;A++)E.push(0);return E}class DirectConvolution{constructor(E,A,C="CONSTANT"){checkSize(E),checkKernel$1(A),checkBorderType(C),this.size=E,this.kernelOffset=(A.length-1)/2,this.outputSize=C==="CONSTANT"?E:E-2*this.kernelOffset,this.output=createArray(this.outputSize),this.kernel=A,this.kernelSize=A.length,this.borderType=C}convolve(E){return checkInputLength(E.length,this.size),this.output.fill(0),this.borderType==="CONSTANT"?this._convolutionBorder0(E):this._convolutionBorderCut(E),this.output}_convolutionBorder0(E){for(let A=0;A<this.size;A++)for(let C=0;C<this.kernelSize;C++)this.output[A]+=interpolateInput(E,A-this.kernelOffset+C)*this.kernel[C]}_convolutionBorderCut(E){for(let A=this.kernelOffset;A<this.size-this.kernelOffset;A++){const C=A-this.kernelOffset;for(let P=0;P<this.kernelSize;P++)this.output[C]+=E[C+P]*this.kernel[P]}}}function interpolateInput(_,E){return E<0||E>=_.length?0:_[E]}const BorderType={CUT:"CUT"};function getBorderInterpolation(_,E){return M$2(_).with("constant",()=>getInterpolateConstant(E)).with("replicate",()=>interpolateReplicate).with("reflect",()=>interpolateReflect).with("reflect101",()=>interpolateReflect101).with("wrap",()=>interpolateWrap).exhaustive()}function checkRange(_,E){if(_<=0-E||_>=E+E-1)throw new RangeError("border must be smaller than the original image")}function getInterpolateConstant(_){return function(A,C,P,D){const U=interpolateConstantPoint(A,D.width),G=interpolateConstantPoint(C,D.height);return U===-1||G===-1?_:D.getValue(U,G,P)}}function interpolateConstantPoint(_,E){return _>=0&&_<E?_:-1}function interpolateReplicate(_,E,A,C){return C.getValue(interpolateReplicatePoint(_,C.width),interpolateReplicatePoint(E,C.height),A)}function interpolateReplicatePoint(_,E){return _>=0&&_<E?_:(checkRange(_,E),_<0?0:E-1)}function interpolateReflect(_,E,A,C){return C.getValue(interpolateReflectPoint(_,C.width),interpolateReflectPoint(E,C.height),A)}function interpolateReflectPoint(_,E){return _>=0&&_<E?_:(checkRange(_,E),_<0?-1-_:E+E-1-_)}function interpolateWrap(_,E,A,C){return C.getValue(interpolateWrapPoint(_,C.width),interpolateWrapPoint(E,C.height),A)}function interpolateWrapPoint(_,E){return _>=0&&_<E?_:(checkRange(_,E),_<0?E+_:_-E)}function interpolateReflect101(_,E,A,C){return C.getValue(interpolateReflect101Point(_,C.width),interpolateReflect101Point(E,C.height),A)}function interpolateReflect101Point(_,E){return _>=0&&_<E?_:(checkRange(_,E),_<0?0-_:E+E-2-_)}function extendBorders(_,E){const{horizontal:A,vertical:C,borderType:P="reflect101",borderValue:D=0}=E,U=getBorderInterpolation(P,D),G=Image.createFrom(_,{width:_.width+2*A,height:_.height+2*C});_.copyTo(G,{origin:{column:A,row:C},out:G});for(let X=0;X<C;X++)for(let q=0;q<G.width;q++)for(let Z=0;Z<_.channels;Z++){const K=U(q-A,X-C,Z,_);G.setValue(q,X,Z,K)}for(let X=G.height-C;X<G.height;X++)for(let q=0;q<G.width;q++)for(let Z=0;Z<_.channels;Z++){const K=U(q-A,X-C,Z,_);G.setValue(q,X,Z,K)}for(let X=C;X<G.height-C;X++)for(let q=0;q<A;q++)for(let Z=0;Z<_.channels;Z++){const K=U(q-A,X-C,Z,_);G.setValue(q,X,Z,K)}for(let X=C;X<G.height-C;X++)for(let q=G.width-A;q<G.width;q++)for(let Z=0;Z<_.channels;Z++){const K=U(q-A,X-C,Z,_);G.setValue(q,X,Z,K)}return G}function round(_){const E=Math.trunc(_),A=_-E;return A<.5?E:A>.5?E+1:E%2===0?E:E+1}function directConvolution(_,E,A={}){const{borderType:C="reflect101",borderValue:P=0}=A,D=rawDirectConvolution(_,E,{borderType:C,borderValue:P}),U=getOutputImage(_,A),G=getClamp(U);for(let X=0;X<_.size;X++)for(let q=0;q<_.channels;q++){const Z=X*_.channels+q,K=round(G(D[Z]));U.setValueByIndex(X,q,K)}return U}function rawDirectConvolution(_,E,A={}){const{borderType:C="reflect101",borderValue:P=0}=A,D=getBorderInterpolation(C,P),U=new Float64Array(_.size*_.channels);for(let G=0;G<_.channels;G++)for(let X=0;X<_.height;X++)for(let q=0;q<_.width;q++){const Z=getIndex(q,X,_,G);U[Z]=computeConvolutionValue(q,X,G,_,E,D,{returnRawValue:!0})}return U}function separableConvolution(_,E,A,C={}){const{normalize:P,borderType:D="reflect101",borderValue:U=0}=C;P&&([E,A]=normalizeSeparatedKernel(E,A));const X=(E.length-1)/2,Z=(A.length-1)/2,K=extendBorders(_,{horizontal:X,vertical:Z,borderType:D,borderValue:U}),J=Image.createFrom(_),Q=getClamp(J),ht=new DirectConvolution(K.width,E,BorderType.CUT),Et=new DirectConvolution(K.height,A,BorderType.CUT),xt=new Float64Array(K.width),gt=new Float64Array(K.height),bt=new Float64Array(_.width*K.height);for(let rt=0;rt<K.channels;rt++){for(let tt=0;tt<K.height;tt++){for(let wt=0;wt<K.width;wt++)xt[wt]=K.getValue(wt,tt,rt);const at=ht.convolve(xt);for(let wt=0;wt<_.width;wt++)bt[tt*_.width+wt]=at[wt]}for(let tt=0;tt<_.width;tt++){for(let wt=0;wt<K.height;wt++)gt[wt]=bt[wt*_.width+tt];const at=Et.convolve(gt);for(let wt=0;wt<_.height;wt++)J.setValue(tt,wt,rt,round(Q(at[wt])))}}return J}function computeConvolutionValue(_,E,A,C,P,D,U={}){let{clamp:G}=U;const{returnRawValue:X=!1}=U;X&&(G=void 0);let q=0;const Z=P[0].length,K=P.length,J=(Z-1)/2,Q=(K-1)/2;for(let ht=0;ht<K;ht++)for(let Et=0;Et<Z;Et++){const xt=P[ht][Et];q+=xt*D(_+Et-J,E+ht-Q,A,C)}return G?round(G(q)):q}function normalizeSeparatedKernel(_,E){const A=_.reduce((U,G)=>U+G,0),C=E.reduce((U,G)=>U+G,0),P=A*C;if(P<0)throw new RangeError("this separated kernel cannot be normalized");const D=1/Math.sqrt(Math.abs(P));return[_.map(U=>U*D),E.map(U=>U*D)]}function blur(_,E){const{width:A,height:C}=E;if(A<1||A%2===0)throw new RangeError(`Invalid property "width". Must be an odd number greater than 0. Received ${A}.`);if(C<1||C%2===0)throw new RangeError(`Invalid property "height". Must be an odd number greater than 0. Received ${C}.`);const P=new Array(A).fill(1),D=new Array(C).fill(1);return separableConvolution(_,P,D,{normalize:!0,...E})}function derivativeFilter(_,E={}){const{filter:A="sobel"}=E,C=M$2(A).with("sobel",()=>({kernelX:SOBEL_X,kernelY:SOBEL_Y})).with("scharr",()=>({kernelX:SCHARR_X,kernelY:SCHARR_Y})).with("prewitt",()=>({kernelX:PREWITT_X,kernelY:PREWITT_Y})).exhaustive();return _.gradientFilter({...C,...E})}const ImageColorModel={GREYA:"GREYA",RGBA:"RGBA"},colorModels={GREY:{components:1,alpha:!1,channels:1},GREYA:{components:1,alpha:!0,channels:2},RGB:{components:3,alpha:!1,channels:3},RGBA:{components:3,alpha:!0,channels:4},BINARY:{components:1,alpha:!1,channels:1}};function increaseContrast(_,E={}){const{uniform:A=!1}=E;checkProcessable(_,{bitDepth:[8,16]});const C=_.minMax();let P=C.min,D=C.max;if(A){let G=-1,X=-1;for(let q=0;q<C.max.length;q++){const Z=C.max[q]-C.min[q];Z>X&&(G=q,X=Z)}P=C.min[G],D=C.max[G]}let U=new Array(_.components).fill(0).map((G,X)=>X);return _.colorModel===ImageColorModel.GREYA?U=[0]:_.colorModel===ImageColorModel.RGBA&&(U=[0,1,2]),_.level({inputMin:P,inputMax:D,outputMin:0,outputMax:_.maxValue,channels:U,...E})}function gaussianBlur(_,E){if("sigma"in E){const{sigma:A,size:C=getSize$1(A),borderType:P}=E,D=getRadius(C),U=getKernel(D,A);return separableConvolution(_,U,U,{borderType:P})}else if("sigmaX"in E&&"sigmaY"in E){const{sigmaX:A,sigmaY:C,sizeX:P=getSize$1(A),sizeY:D=getSize$1(C),borderType:U}=E,G=getRadius(P),X=getRadius(D),q=getKernel(G,A),Z=getKernel(X,C);return separableConvolution(_,q,Z,{borderType:U})}else throw new TypeError("you must either define sigma or sigmaX and sigmaY in the options argument")}function getKernel(_,E){const A=_*2+1,C=new Array(A),P=E||((A-1)*.5-1)*.3+.8,D=-.5/(P*P);let U=0;for(let G=0;G<A;G++){const X=G-_,q=Math.exp(D*X*X);C[G]=q,U+=q}for(let G=0;G<A;G++)C[G]/=U;return C}function getSize$1(_){return 2*Math.ceil(2*_)+1}function gradientFilter(_,E){const{borderType:A="replicate",borderValue:C=0}=E;if(checkProcessable(_,{bitDepth:[8,16],colorModel:"GREY"}),"kernelX"in E&&"kernelY"in E){const{kernelX:P,kernelY:D}=E,U=_.rawDirectConvolution(P,{borderType:A,borderValue:C}),G=_.rawDirectConvolution(D,{borderType:A,borderValue:C}),X=new Image(_.width,_.height,{colorModel:"GREY"});for(let q=0;q<_.size;q++)X.setValueByIndex(q,0,Math.hypot(U[q],G[q]));return X}else{if("kernelX"in E)return _.directConvolution(E.kernelX,{borderType:A,borderValue:C});if("kernelY"in E)return _.directConvolution(E.kernelY,{borderType:A,borderValue:C});throw new TypeError("kernelX and KernelY are not defined")}}function hypotenuse(_,E,A={}){const{channels:C=new Array(_.components).fill(0).map((D,U)=>U)}=A;if(checkProcessable(_,{bitDepth:[8,16]}),_.width!==E.width||_.height!==E.height)throw new RangeError("both images must have the same size");if(_.alpha!==E.alpha||_.bitDepth!==E.bitDepth)throw new RangeError("both images must have the same alpha and bitDepth");if(_.channels!==E.channels)throw new RangeError("both images must have the same number of channels");validateChannels(C,_);const P=getOutputImage(_,{},{clone:!0});for(const D of C)for(let U=0;U<_.size;U++){const G=Math.hypot(_.getValueByIndex(U,D),E.getValueByIndex(U,D));P.setValueByIndex(U,D,Math.min(G,P.maxValue))}return P}function convertColor(_,E,A={}){const C=new Map([["GREY",["GREYA","RGB","RGBA"]],["GREYA",["GREY","RGB","RGBA"]],["RGB",["GREY","GREYA","RGBA"]],["RGBA",["GREY","GREYA","RGB"]],["BINARY",["GREY","RGB","RGBA"]]]);if(_.colorModel===E&&E!=="BINARY")return getOutputImage(_,{out:A.out},{clone:!0});if(!C.get(_.colorModel)?.includes(E))throw new RangeError(`conversion from ${_.colorModel} to ${E} not implemented`);if(_ instanceof Image){const D=getOutputImage(_,A,{newParameters:{colorModel:E}});return(_.colorModel==="GREY"||_.colorModel==="GREYA")&&convertGreyToAny(_,D),(_.colorModel==="RGB"||_.colorModel==="RGBA")&&(E==="RGB"||E==="RGBA"?convertRgbToRgb(_,D):convertRgbToGrey(_,D)),!_.alpha&&D.alpha&&D.fillAlpha(D.maxValue),_.alpha&&D.alpha&&copyAlpha(_,D),D}else if(E==="GREY"){const D=maskToOutputImage(_,A);return convertBinaryToGrey(_,D),D}else{const D=new Image(_.width,_.height,{colorModel:E});return convertBinaryToRgb(_,D),D}}function copyAlpha(_,E){if(_.size!==E.size)throw new RangeError("source and destination have different sizes");if(!_.alpha)throw new RangeError("source image does not have alpha");if(!E.alpha)throw new RangeError("destination does not have alpha");for(let A=0;A<E.size;A++)E.setValueByIndex(A,E.channels-1,_.getValueByIndex(A,_.channels-1))}function convertGreyToAny(_,E){for(let A=0;A<_.size;A++)for(let C=0;C<E.components;C++)E.setValueByIndex(A,C,_.getValueByIndex(A,0))}function convertRgbToRgb(_,E){for(let A=0;A<_.size;A++)for(let C=0;C<3;C++)E.setValueByIndex(A,C,_.getValueByIndex(A,C))}function convertRgbToGrey(_,E){for(let A=0;A<_.size;A++){const C=_.getValueByIndex(A,0),P=_.getValueByIndex(A,1),D=_.getValueByIndex(A,2);E.setValueByIndex(A,0,Math.round(.299*C+.587*P+.114*D))}}function convertBinaryToGrey(_,E){for(let A=0;A<_.size;A++)E.setValueByIndex(A,0,_.getBitByIndex(A)?E.maxValue:0)}function convertBinaryToRgb(_,E){const A=new Array(E.components).fill(0),C=new Array(E.components).fill(E.maxValue);E.alpha&&(A.push(E.maxValue),C.push(E.maxValue));for(let P=0;P<_.size;P++)E.setPixelByIndex(P,_.getBitByIndex(P)?C:A)}function convertBitDepth(_,E,A={}){if(_.bitDepth===E)return getOutputImage(_,A,{clone:!0});if(E!==8&&E!==16)throw new RangeError(`This image bit depth is not supported: ${E}`);const C=getOutputImage(_,A,{clone:!1,newParameters:{bitDepth:E,colorModel:_.colorModel}});return E===8?convertToUint8(_,C):convertToUint16(_,C)}function convertToUint16(_,E){for(let A=0;A<_.size;A++)for(let C=0;C<E.channels;C++)E.setValueByIndex(A,C,_.getValueByIndex(A,C)<<8);return E}function convertToUint8(_,E){for(let A=0;A<_.size;A++)for(let C=0;C<E.channels;C++)E.setValueByIndex(A,C,_.getValueByIndex(A,C)>>8);return E}function checkPointIsInteger(_,E="Point"){if(!Number.isInteger(_.row)||!Number.isInteger(_.column))throw new TypeError(`${E} row and column must be integers`)}function extract(_,E,A={}){const{origin:C={row:0,column:0}}=A,{row:P,column:D}=C;assert(P<_.height&&D<_.width&&P+E.width>0&&D+E.height>0,"extract: image and mask have no overlap"),checkPointIsInteger(C,"Origin");const U=Math.min(_.width,E.width+D)-Math.max(0,D),G=Math.min(_.height,E.height+P)-Math.max(0,P);let X=new Image(U,G,{colorModel:_.colorModel,origin:C});X.alpha&&(X=X.fillAlpha(0));const q=Math.max(0,P),Z=Math.max(0,D),K=P<0?-P:0,J=D<0?-D:0;for(let Q=0;Q<G;Q++)for(let ht=0;ht<U;ht++)E.getBit(J+ht,K+Q)&&X.setPixel(ht,Q,_.getPixel(Z+ht,q+Q));return X}function split(_){const E=[];for(let A=0;A<_.channels;A++){const C=Image.createFrom(_,{colorModel:"GREY"});for(let P=0;P<C.size;P++)C.setValueByIndex(P,0,_.getValueByIndex(P,A));E.push(C)}return E}function huang(_){let E=0;for(let Z=0;Z<_.length;Z++)if(_[Z]!==0){E=Z;break}let A=_.length-1;for(let Z=_.length-1;Z>=E;Z--)if(_[Z]!==0){A=Z;break}const C=1/(A-E),P=new Array(_.length);let D=0,U=0;for(let Z=E;Z<_.length;Z++)D+=Z*_[Z],U+=_[Z],P[Z]=D/U;const G=new Array(_.length);D=0,U=0;for(let Z=A;Z>0;Z--)D+=Z*_[Z],U+=_[Z],G[Z-1]=D/U;let X=-1,q=Number.MAX_VALUE;for(let Z=0;Z<_.length;Z++){let K=0,J;for(let Q=0;Q<=Z;Q++)J=1/(1+C*Math.abs(Q-P[Z])),J<1e-6||J>.999999||(K+=_[Q]*(-J*Math.log(J)-(1-J)*Math.log(1-J)));for(let Q=Z+1;Q<_.length;Q++)J=1/(1+C*Math.abs(Q-G[Z])),J<1e-6||J>.999999||(K+=_[Q]*(-J*Math.log(J)-(1-J)*Math.log(1-J)));K<q&&(q=K,X=Z)}return X}function intermodes(_){const E=_.slice();let A=0;for(;!bimodalTest$1(E);){let P=0,D=0,U=E[0];for(let G=0;G<_.length-1;G++)P=D,D=U,U=E[G+1],E[G]=(P+D+U)/3;E[_.length-1]=(D+U)/3,A++,assert(A<1e3,"Intermodes threshold not found after 1000 iterations")}let C=0;for(let P=1;P<_.length-1;P++)E[P-1]<E[P]&&E[P+1]<E[P]&&(C+=P);return Math.floor(C/2)}function bimodalTest$1(_){let E=!1,A=0;for(let C=1;C<_.length-1;C++)if(_[C-1]<_[C]&&_[C+1]<_[C]&&(A++,A>2))return!1;return A===2&&(E=!0),E}function isodata(_){let E,A,C,P,D=0;for(let U=1;U<_.length;U++)if(_[U]>0){D=U+1;break}for(;;){E=0,C=0;for(let U=0;U<D;U++)C=C+_[U],E=E+_[U]*U;P=0,A=0;for(let U=D+1;U<_.length;U++)A+=_[U],P+=_[U]*U;if(C>0&&A>0&&(E/=C,P/=A,D===Math.round((E+P)/2)))break;D++,assert(D<=_.length-2,"Threshold not found")}return D}function li(_,E){let A,C,P,D,U,G,X,q,Z,K,Q;K=0;for(let ht=0;ht<_.length;ht++)K+=ht*_[ht];K/=E,X=K;do{G=X,A=G+.5|0,C=0,D=0;for(let ht=0;ht<=A;ht++)C+=ht*_[ht],D+=_[ht];q=D===0?0:C/D,P=0,U=0;for(let ht=A+1;ht<_.length;ht++)P+=ht*_[ht],U+=_[ht];Z=U===0?0:P/U,Q=(q-Z)/(Math.log(q)-Math.log(Z)),Q<-Number.EPSILON?X=Q-.5|0:X=Q+.5|0}while(Math.abs(X-G)>.5);return A}function maxEntropy(_,E){const A=new Array(_.length);for(let J=0;J<_.length;J++)A[J]=_[J]/E;const C=new Array(_.length),P=new Array(_.length);C[0]=A[0],P[0]=1-C[0];for(let J=1;J<_.length;J++)C[J]=C[J-1]+A[J],P[J]=1-C[J];let D=0;for(let J=0;J<_.length;J++)if(Math.abs(C[J])>=Number.EPSILON){D=J;break}let U=_.length-1;for(let J=_.length-1;J>=D;J--)if(Math.abs(P[J])>=Number.EPSILON){U=J;break}let G=-1,X,q=Number.MIN_VALUE,Z,K;for(let J=D;J<=U;J++){Z=0;for(let Q=0;Q<=J;Q++)_[Q]!==0&&(Z-=A[Q]/C[J]*Math.log(A[Q]/C[J]));K=0;for(let Q=J+1;Q<_.length;Q++)_[Q]!==0&&(K-=A[Q]/P[J]*Math.log(A[Q]/P[J]));X=Z+K,q<X&&(q=X,G=J)}return G}function mean$1(_,E){let A=0;for(let C=0;C<_.length;C++)A+=C*_[C];return Math.floor(A/E)}function minError(_,E){let A,C=-2,P,D,U,G,X,q,Z,K,J,Q,ht,Et=0;for(let xt=0;xt<_.length;xt++)Et+=xt*_[xt];for(Et/=E,A=Et;A!==C;){const xt=sumA(_,A),gt=sumA(_,_.length-1),bt=sumB(_,A),rt=sumB(_,_.length-1),tt=sumC(_,A),at=sumC(_,_.length-1);if(P=bt/xt,D=(rt-bt)/(gt-xt),U=xt/gt,G=(gt-xt)/gt,X=tt/xt-P*P,q=(at-tt)/(gt-xt)-D*D,Z=1/X-1/q,K=P/X-D/q,J=P*P/X-D*D/q+Math.log10(X*(G*G)/(q*(U*U))),Q=K*K-Z*J,Q<0)return A;C=A,ht=(K+Math.sqrt(Q))/Z,Number.isNaN(ht)?A=C:A=Math.floor(ht)}return A}function sumA(_,E){let A=0;for(let C=0;C<=E;C++)A+=_[C];return A}function sumB(_,E){let A=0;for(let C=0;C<=E;C++)A+=C*_[C];return A}function sumC(_,E){let A=0;for(let C=0;C<=E;C++)A+=C*C*_[C];return A}function minimum(_){if(_.length<2)return 0;let E=0,A=-1,C=-1,P=new Array(_.length);for(let D=0;D<_.length;D++)P[D]=_[D],_[D]>0&&(C=D);for(;!bimodalTest(P);)if(P=smoothed(P),E++,E>1e4)return A;for(let D=1;D<C;D++)if(P[D-1]>P[D]&&P[D+1]>=P[D]){A=D;break}return A}function smoothed(_){const E=new Array(_.length);for(let A=1;A<_.length-1;A++)E[A]=(_[A-1]+_[A]+_[A+1])/3;return E[0]=(_[0]+_[1])/3,E[_.length-1]=(_.at(-2)+_.at(-1))/3,E}function bimodalTest(_){const E=_.length;let A=!1,C=0;for(let P=1;P<E-1;P++)if(_[P-1]<_[P]&&_[P+1]<_[P]&&(C++,C>2))return!1;return C===2&&(A=!0),A}function moments(_,E){let C=0,P=0,D=0,U=0,G=-1;const X=_.length,q=[];for(let xt=0;xt<X;xt++)q.push(_[xt]/E);for(let xt=0;xt<X;xt++)C+=xt*q[xt],P+=xt*xt*q[xt],D+=xt*xt*xt*q[xt];const Z=1*P-C*C,K=(-P*P+C*D)/Z,J=(1*-D+P*C)/Z,Q=.5*(-J-Math.sqrt(J*J-4*K)),ht=.5*(-J+Math.sqrt(J*J-4*K)),Et=(ht-C)/(ht-Q);for(let xt=0;xt<X;xt++)if(U+=q[xt],U>Et){G=xt;break}return G}function otsu(_,E){let A=0,C=0,P=0,D=0,U=0;for(let G=0;G<_.length;G++)U+=G*_[G];for(let G=0;G<_.length;G++){C=C+_[G];const X=E-C;if(C===0||X===0)continue;A=A+G*_[G];const q=(U-A)/X,Z=C*X*(A/C-q)*(A/C-q);Z>=P&&(D=G,P=Z)}return D}function percentile(_){let E=-1;const A=.5,C=new Array(_.length),P=partialSum(_,_.length-1);let D=1;for(let U=0;U<_.length;U++)C[U]=Math.abs(partialSum(_,U)/P-A),C[U]<D&&(D=C[U],E=U);return E}function partialSum(_,E){let A=0;for(let C=0;C<=E;C++)A+=_[C];return A}function renyiEntropy(_,E){let A,C;const P=new Array(_.length),D=new Array(_.length),U=new Array(_.length);let G=0,X=0,q=0,Z=0,K=0,J=0;const ht=1/(1-.5),xt=1/(1-2);for(let at=0;at<_.length;at++)P[at]=_[at]/E;D[0]=P[0],U[0]=1-D[0];for(let at=1;at<_.length;at++)D[at]=D[at-1]+P[at],U[at]=1-D[at];A=0;for(let at=0;at<_.length;at++)if(Math.abs(D[at])>=Number.EPSILON){A=at;break}C=_.length-1;for(let at=_.length-1;at>=A;at--)if(Math.abs(U[at])>=Number.EPSILON){C=at;break}for(let at=A;at<=C;at++){let wt=0,yt=0,lt=0;for(let Ot=0;Ot<=at;Ot++)_[Ot]!==0&&(wt-=P[Ot]/D[at]*Math.log(P[Ot]/D[at])),yt+=Math.sqrt(P[Ot]/D[at]),lt+=P[Ot]*P[Ot]/(D[at]*D[at]);let ct=0,ut=0,dt=0;for(let Ot=at+1;Ot<_.length;Ot++)_[Ot]!==0&&(ct-=P[Ot]/U[at]*Math.log(P[Ot]/U[at])),ut+=Math.sqrt(P[Ot]/U[at]),dt+=P[Ot]*P[Ot]/(U[at]*U[at]);const _t=wt+ct,Ft=ht*(yt*ut>0?Math.log(yt*ut):0),Pt=xt*(lt*dt>0?Math.log(lt*dt):0);_t>Z&&(Z=_t,G=at),Ft>K&&(K=Ft,X=at),Pt>J&&(J=Pt,q=at)}const gt=new Uint32Array([G,X,q]);gt.sort();let bt;Math.abs(gt[0]-gt[1])<=5?Math.abs(gt[1]-gt[2])<=5?bt=[1,2,1]:bt=[0,1,3]:Math.abs(gt[1]-gt[2])<=5?bt=[3,1,0]:bt=[1,2,1];const rt=D[gt[2]]-D[gt[0]];return Math.round(gt[0]*(D[gt[0]]+.25*rt*bt[0])+.25*gt[1]*rt*bt[1]+gt[2]*(U[gt[2]]+.25*rt*bt[2]))}function shanbhag(_,E){const A=new Array(_.length);for(let Q=0;Q<_.length;Q++)A[Q]=_[Q]/E;const C=new Array(_.length),P=new Array(_.length);C[0]=A[0],P[0]=1-C[0];for(let Q=1;Q<_.length;Q++)C[Q]=C[Q-1]+A[Q],P[Q]=1-C[Q];let D=0;for(let Q=0;Q<_.length;Q++)if(Math.abs(C[Q])>=Number.EPSILON){D=Q;break}let U=_.length-1;for(let Q=_.length-1;Q>=D;Q--)if(Math.abs(P[Q])>=Number.EPSILON){U=Q;break}let G=-1,X=Number.MAX_VALUE,q,Z,K,J;for(let Q=D;Q<=U;Q++){K=0,q=.5/C[Q];for(let ht=1;ht<=Q;ht++)K-=A[ht]*Math.log(1-q*C[ht-1]);K*=q,J=0,q=.5/P[Q];for(let ht=Q+1;ht<_.length;ht++)J-=A[ht]*Math.log(1-q*P[ht]);J*=q,Z=Math.abs(K-J),Z<X&&(X=Z,G=Q)}return G}function triangle(_){let E=0,A=0,C=0,P=0;for(let K=0;K<_.length;K++)if(_[K]>0){E=K;break}E>0&&E--;for(let K=_.length-1;K>0;K--)if(_[K]>0){P=K;break}P<_.length-1&&P++;for(let K=0;K<_.length;K++)_[K]>A&&(C=K,A=_[K]);let D=!1;if(C-E<P-C){D=!0;let K=0,J=_.length-1;for(;K<J;){const Q=_[K];_[K]=_[J],_[J]=Q,K++,J--}E=_.length-1-P,C=_.length-1-C}if(E===C)return E;let U,G,X;U=_[C],G=E-C,X=Math.hypot(U,G),U/=X,G/=X,X=U*E+G*_[E];let q=E,Z=0;for(let K=E+1;K<=C;K++){const J=U*K+G*_[K]-X;J>Z&&(q=K,Z=J)}if(q--,D){let K=0,J=_.length-1;for(;K<J;){const Q=_[K];_[K]=_[J],_[J]=Q,K++,J--}return _.length-1-q}else return q}function yen(_,E){const A=new Array(_.length);for(let q=0;q<_.length;q++)A[q]=_[q]/E;const C=new Array(_.length);C[0]=A[0];for(let q=1;q<_.length;q++)C[q]=C[q-1]+A[q];const P=new Array(_.length);P[0]=A[0]*A[0];for(let q=1;q<_.length;q++)P[q]=P[q-1]+A[q]*A[q];const D=new Array(_.length);D[_.length-1]=0;for(let q=_.length-2;q>=0;q--)D[q]=D[q+1]+A[q+1]*A[q+1];let U=-1,G=Number.MIN_VALUE,X;for(let q=0;q<_.length;q++)X=-1*(P[q]*D[q]>0?Math.log(P[q]*D[q]):0)+2*(C[q]*(1-C[q])>0?Math.log(C[q]*(1-C[q])):0),X>G&&(G=X,U=q);return U}function computeThreshold(_,E={}){const{algorithm:A="otsu",slots:C}=E;if(_.channels!==1)throw new TypeError("threshold can only be computed on images with one channel");const P=_.histogram({slots:C}),D=C?2**_.bitDepth/C:1;return M$2(A).with("huang",()=>huang(P)*D).with("intermodes",()=>intermodes(P)*D).with("isodata",()=>isodata(P)*D).with("li",()=>li(P,_.size)*D).with("maxEntropy",()=>maxEntropy(P,_.size)*D).with("mean",()=>mean$1(P,_.size)*D).with("minimum",()=>minimum(P)*D).with("minError",()=>minError(P,_.size)*D).with("moments",()=>moments(P,_.size)*D).with("otsu",()=>otsu(P,_.size)*D).with("percentile",()=>percentile(P)*D).with("renyiEntropy",()=>renyiEntropy(P,_.size)*D).with("shanbhag",()=>shanbhag(P,_.size)*D).with("triangle",()=>triangle(P)*D).with("yen",()=>yen(P,_.size)*D).exhaustive()}function threshold(_,E={}){let A;if("threshold"in E){const P=E.threshold;if(P<0||P>1)throw new RangeError("threshold must be a value between 0 and 1");A=P*_.maxValue}else A=computeThreshold(_,E);const C=imageToOutputMask(_,E);for(let P=0;P<_.size;P++)C.setBitByIndex(P,_.getValueByIndex(P,0)>A?1:0);return C}function luma709(_,E,A){return _*6966+E*23436+A*2366>>15}function luma601(_,E,A){return _*9798+E*19235+A*3735>>15}function max$1(_,E,A){return Math.max(_,E,A)}function min(_,E,A){return Math.min(_,E,A)}function average(_,E,A){return(_+E+A)/3>>0}function minmax(_,E,A){return(Math.max(_,E,A)+Math.min(_,E,A))/2}function red(_){return _}function green(_,E){return E}function blue(_,E,A){return A}function black(_,E,A,C){return Math.min(C.maxValue-_,C.maxValue-E,C.maxValue-A)}function cyan(_,E,A,C){const P=black(_,E,A,C);return(C.maxValue-_-P)/(1-P/C.maxValue)>>0}function magenta(_,E,A,C){const P=black(_,E,A,C);return(C.maxValue-E-P)/(1-P/C.maxValue)>>0}function yellow(_,E,A,C){const P=black(_,E,A,C);return(C.maxValue-A-P)/(1-P/C.maxValue)>>0}function hue(_,E,A,C){const P=min(_,E,A),D=max$1(_,E,A);if(D===P)return 0;let U=0;const G=D-P;return D===_?U=(E-A)/G+(E<A?6:0):D===E?U=(A-_)/G+2:(assert(D===A),U=(_-E)/G+4),U/6*C.maxValue>>0}function saturation(_,E,A,C){const P=min(_,E,A),D=max$1(_,E,A),U=D-P;return D===0?0:U/D*C.maxValue}function lightness(_,E,A){const C=min(_,E,A);return(max$1(_,E,A)+C)/2}const greyAlgorithms=Object.freeze(Object.defineProperty({__proto__:null,average,black,blue,cyan,green,hue,lightness,luma601,luma709,magenta,max:max$1,min,minmax,red,saturation,yellow},Symbol.toStringTag,{value:"Module"})),GreyAlgorithm={LUMA_709:"luma709",LUMA_601:"luma601",MAX:"max",MIN:"min",AVERAGE:"average",MINMAX:"minmax",RED:"red",GREEN:"green",BLUE:"blue",BLACK:"black",CYAN:"cyan",MAGENTA:"magenta",YELLOW:"yellow",HUE:"hue",SATURATION:"saturation",LIGHTNESS:"lightness"};{const _=new Set(Object.values(GreyAlgorithm));for(const E of Object.keys(greyAlgorithms))assert(_.has(E),`Grey algorithm ${E} is missing in the GreyAlgorithm enum`)}function grey(_,E={}){let{keepAlpha:A=!1,mergeAlpha:C=!0}=E;const{algorithm:P="luma709"}=E;checkProcessable(_,{colorModel:["RGB","RGBA"]}),A=A&&_.alpha,C=C&&_.alpha,A&&(C=!1);const U=getOutputImage(_,E,{newParameters:{colorModel:A?"GREYA":"GREY"}});let G;typeof P=="function"?G=P:G=greyAlgorithms[P];const X=getClamp(U);for(let q=0;q<_.size;q++){const Z=_.getValueByIndex(q,0),K=_.getValueByIndex(q,1),J=_.getValueByIndex(q,2);let Q;if(C){const ht=_.getValueByIndex(q,3);Q=X(G(Z,K,J,_)*ht/_.maxValue)}else if(Q=X(G(Z,K,J,_)),A){const ht=_.getValueByIndex(q,3);U.setValueByIndex(q,1,ht)}U.setValueByIndex(q,0,Q)}return U}function copyTo(_,E,A={}){const{origin:C={column:0,row:0}}=A,{column:P,row:D}=C;if(_.colorModel!==E.colorModel)throw new RangeError("source and target must have the same color model");checkPointIsInteger(C,"Origin");let U;E instanceof Image?U=getOutputImage(E,A,{clone:!0}):U=maskToOutputMask(E,A,{clone:!0});for(let G=Math.max(D,0);G<Math.min(_.height+D,E.height);G++)for(let X=Math.max(P,0);X<Math.min(_.width+P,E.width);X++){const q=_.getPixel(X-P,G-D);setBlendedPixel(U,X,G,q)}return U}function crop(_,E={}){const{origin:A={row:0,column:0},width:C=_.width-A.column,height:P=_.height-A.row}=E,{column:D,row:U}=A;if(checkProcessable(_,{bitDepth:[8,16]}),checkPointIsInteger(A,"Origin"),!Number.isInteger(C)||!Number.isInteger(P))throw new RangeError(`Width and height (width:${C}; height:${P}) must be integers`);if(U>_.height-1||D>_.width-1)throw new RangeError(`Origin (row:${U}, column:${D}) out of range (${_.width-1}; ${_.height-1})`);if(C<=0||P<=0)throw new RangeError(`Width and height (width:${C}; height:${P}) must be positive numbers`);if(U<0||D<0)throw new RangeError(`Row and column (row:${U}, column:${D}) must be positive numbers`);if(C>_.width-D||P>_.height-U)throw new RangeError(`Size is out of range (row:${U}, column:${D}, width:${C}, height:${P})`);const G=Image.createFrom(_,{width:C,height:P});for(let X=0;X<P;X++)for(let q=0;q<C;q++)G.setPixel(q,X,_.getPixel(D+q,U+X));return G}function cropAlpha(_,E={}){checkProcessable(_,{alpha:!0});const{threshold:A=_.maxValue}=E,C=findLeft(_,A,_.components);if(C===-1)throw new RangeError(`could not find new dimensions. Threshold may be too high: ${A}`);const P=findTop(_,A,_.components,C),D=findBottom(_,A,_.components,C),U=findRight(_,A,_.components,C,P,D);return _.crop({origin:{column:C,row:P},width:U-C+1,height:D-P+1})}function findLeft(_,E,A){for(let C=0;C<_.width;C++)for(let P=0;P<_.height;P++)if(_.getValue(C,P,A)>=E)return C;return-1}function findTop(_,E,A,C){for(let P=0;P<_.height;P++)for(let D=C;D<_.width;D++)if(_.getValue(D,P,A)>=E)return P;return-1}function findBottom(_,E,A,C){for(let P=_.height-1;P>=0;P--)for(let D=C;D<_.width;D++)if(_.getValue(D,P,A)>=E)return P;return-1}function findRight(_,E,A,C,P,D){for(let U=_.width-1;U>=C;U--)for(let G=P;G<=D;G++)if(_.getValue(U,G,A)>=E)return U;return-1}function getInterpolationFunction(_){return M$2(_).with("nearest",()=>interpolateNearest).with("bilinear",()=>interpolateBilinear).with("bicubic",()=>interpolateBicubic).exhaustive()}function interpolateNearest(_,E,A,C,P){return E=Math.round(E),A=Math.round(A),P(E,A,C,_)}function interpolateBilinear(_,E,A,C,P){const D=Math.floor(E),U=Math.floor(A),G=D+1,X=U+1;if(G<_.width&&X<_.height&&D>=0&&U>=0){const q=_.getValue(D,U,C),Z=_.getValue(G,U,C),K=_.getValue(D,X,C),J=_.getValue(G,X,C),Q=(G-E)*q+(E-D)*Z,ht=(G-E)*K+(E-D)*J;return round((X-A)*Q+(A-U)*ht)}else{const q=P(D,U,C,_),Z=P(G,U,C,_),K=P(D,X,C,_),J=P(G,X,C,_),Q=(G-E)*q+(E-D)*Z,ht=(G-E)*K+(E-D)*J;return round((X-A)*Q+(A-U)*ht)}}function interpolateBicubic(_,E,A,C,P,D){const U=Math.floor(E),G=Math.floor(A);if(U===E&&G===A)return P(U,G,C,_);const X=E-U,q=A-G,Z=P(U-1,G-1,C,_),K=P(U,G-1,C,_),J=P(U+1,G-1,C,_),Q=P(U+2,G-1,C,_),ht=cubic(Z,K,J,Q,X),Et=P(U-1,G,C,_),xt=P(U,G,C,_),gt=P(U+1,G,C,_),bt=P(U+2,G,C,_),rt=cubic(Et,xt,gt,bt,X),tt=P(U-1,G+1,C,_),at=P(U,G+1,C,_),wt=P(U+1,G+1,C,_),yt=P(U+2,G+1,C,_),lt=cubic(tt,at,wt,yt,X),ct=P(U-1,G+2,C,_),ut=P(U,G+2,C,_),dt=P(U+1,G+2,C,_),_t=P(U+2,G+2,C,_),Ft=cubic(ct,ut,dt,_t,X);return round(D(cubic(ht,rt,lt,Ft,q)))}function cubic(_,E,A,C,P){return E+.5*P*(A-_+P*(2*_-5*E+4*A-C+P*(3*(E-A)+C-_)))}function transform(_,E,A={}){const{borderType:C="constant",borderValue:P=0,interpolationType:D="bilinear",fullImage:U}=A;let{width:G=_.width,height:X=_.height}=A;if(!isValidMatrix(E))throw new TypeError(`transformation matrix must be 2x3 or 3x3. Received ${E.length}x${E[1].length}`);if(E.length===2&&E.push([0,0,1]),U){E=E.map(ut=>ut.slice()),E[0][2]=0,E[1][2]=0;const Q=[_.getCoordinates("top-left"),_.getCoordinates("top-right"),_.getCoordinates("bottom-right"),_.getCoordinates("bottom-left")];Q[1].column+=1,Q[2].column+=1,Q[2].row+=1,Q[3].row+=1;const ht=Q.map(ut=>[transformPoint(E[0],E[2],ut.column,ut.row),transformPoint(E[1],E[2],ut.column,ut.row)]),Et=ht.map(ut=>ut[0]),xt=ht.map(ut=>ut[1]),gt=Math.max(...Et),bt=Math.max(...xt),rt=Math.min(...Et),tt=Math.min(...xt),at=[(_.width-1)/2,(_.height-1)/2];G=gt-rt,X=bt-tt;const wt=transformPoint(E[0],E[2],at[0],at[1]),yt=transformPoint(E[1],E[2],at[0],at[1]),lt=(G-1)/2-wt,ct=(X-1)/2-yt;E[0][2]=lt,E[1][2]=ct,G=Math.round(G),X=Math.round(X)}A.inverse||(E=inverse(new Matrix(E)).to2DArray());const q=Image.createFrom(_,{width:G,height:X}),Z=getBorderInterpolation(C,P),K=getClamp(q),J=getInterpolationFunction(D);for(let Q=0;Q<q.height;Q++)for(let ht=0;ht<q.width;ht++){const Et=transformPoint(E[0],E[2],ht,Q),xt=transformPoint(E[1],E[2],ht,Q);for(let gt=0;gt<q.channels;gt++){const bt=J(_,Et,xt,gt,Z,K);q.setValue(ht,Q,gt,bt)}}return q}function transformPoint(_,E,A,C){return(_[0]*A+_[1]*C+_[2])/(E[0]*A+E[1]*C+E[2])}function isValidMatrix(_){return _.length===3&&_[0].length===3&&_[1].length===3&&_[2].length===3||_.length===2&&_[0].length===3&&_[1].length===3}function resize(_,E){const{interpolationType:A="bilinear",borderType:C="replicate",borderValue:P=0}=E,{width:D,height:U,xFactor:G,yFactor:X}=checkOptions(_,E);return transform(_,[[G,0,G/2],[0,X,X/2]],{interpolationType:A,borderType:C,borderValue:P,height:U,width:D})}function checkOptions(_,E){const{width:A,height:C,xFactor:P,yFactor:D,preserveAspectRatio:U=!0}=E;if(A===void 0&&C===void 0&&P===void 0&&D===void 0)throw new TypeError("at least one of the width, height, xFactor or yFactor options must be passed");let G,X;const q=getSize(A,P,_.width,U),Z=getSize(C,D,_.height,U);return q===void 0?(assert(Z!==void 0),G=Math.round(Z*(_.width/_.height))):G=q,Z===void 0?(assert(q!==void 0),X=Math.round(q*(_.height/_.width))):X=Z,{width:G,height:X,xFactor:P??G/_.width,yFactor:D??X/_.height}}function getSize(_,E,A,C){if(_===void 0){if(E!==void 0)return Math.round(A*E);if(!C)return A}else{if(E!==void 0)throw new TypeError("factor and size cannot be passed together");return _}}function rotate(_,E){const A=E%180===0?_.width:_.height,C=E%180===0?_.height:_.width,P=Image.createFrom(_,{width:A,height:C});if(E===90||E===-270)for(let D=0;D<_.width;D++)for(let U=0;U<_.height;U++)for(let G=0;G<_.channels;G++)P.setValue(P.width-U-1,D,G,_.getValue(D,U,G));else if(E===180||E===-180)for(let D=0;D<_.width;D++)for(let U=0;U<_.height;U++)for(let G=0;G<_.channels;G++)P.setValue(P.width-D-1,P.height-U-1,G,_.getValue(D,U,G));else if(E===270||E===-90)for(let D=0;D<_.width;D++)for(let U=0;U<_.height;U++)for(let G=0;G<_.channels;G++)P.setValue(U,P.height-D-1,G,_.getValue(D,U,G));else throw new RangeError(`invalid angle: ${E}`);return P}function transformRotate(_,E,A={}){const{center:C="center",scale:P=1,...D}=A;let U;typeof C=="string"?U=_.getCoordinates(C):U=C;const G=getRotationMatrix(E,U,P);return transform(_,G,D)}function getRotationMatrix(_,E,A){const C=_*Math.PI/180,P=A*Math.cos(C),D=A*Math.sin(C);return[[P,D,(1-P)*E.column-D*E.row],[-D,P,D*E.column+(1-P)*E.row],[0,0,1]]}function rotatePoint(_,E,A){const C=Math.cos(A),P=Math.sin(A),D=_.column*C-_.row*P+(1-C)*E.column+E.row*P,U=_.column*P+_.row*C+(1-C)*E.row-E.column*P;return{column:D,row:U}}function cropRectangle(_,E,A){if(E.length!==4)throw new Error("The points array must contain 4 points");const C=getSmallestAngle(E),P={row:(E[0].row+E[2].row)/2,column:(E[0].column+E[2].column)/2},D=E.map(bt=>rotatePoint(bt,P,C)),[U,G,X]=D,q=Math.max(Math.abs(U.column-G.column),Math.abs(G.column-X.column)),Z=Math.max(Math.abs(U.row-G.row),Math.abs(G.row-X.row)),K=Math.min(Math.ceil(q),Math.ceil(q-1e-10)),J=Math.min(Math.ceil(Z),Math.ceil(Z-1e-10)),Q={row:Math.min(...D.map(bt=>bt.row))-(J-Z)/2,column:Math.min(...D.map(bt=>bt.column))-(K-q)/2},ht=rotatePoint(Q,P,-C),Et=Math.cos(-C),xt=Math.sin(-C),gt=[[Et,-xt,ht.column],[xt,Et,ht.row]];return transform(_,gt,{inverse:!0,width:K,height:J,...A})}function getSmallestAngle(_){let E=-getAngle(_[1],_[0]);E>Math.PI/2?E-=Math.PI:E<-Math.PI/2&&(E+=Math.PI);let A=E;return Math.abs(E)>Math.PI/4&&(A=E>0?-Math.PI/2+E:Math.PI/2+E),A}function paintMaskOnImage(_,E,A={}){const{origin:C={row:0,column:0},color:P=getDefaultColor(_),blend:D=!0}=A,{column:U,row:G}=C;if(P.length!==_.channels)throw new RangeError("the given color is not compatible with the image");checkPointIsInteger(C,"Origin");const X=getOutputImage(_,A,{clone:!0});if(D){checkColorIsNumberArray(P);for(let q=Math.max(G,0);q<Math.min(E.height+G,_.height);q++)for(let Z=Math.max(U,0);Z<Math.min(E.width+U,_.width);Z++)E.getBit(Z-U,q-G)&&setBlendedPixel(X,Z,q,P)}else for(let q=Math.max(G,0);q<Math.min(E.height+G,_.height);q++)for(let Z=Math.max(U,0);Z<Math.min(E.width+U,_.width);Z++)if(E.getBit(Z-U,q-G))for(let K=0;K<_.channels;K++){const J=P[K];typeof J=="number"&&X.setValue(Z,q,K,J)}return X}function checkColorIsNumberArray(_){for(const E of _)if(typeof E!="number")throw new TypeError("cannot have null channels in color if blend is true")}function paintMaskOnMask(_,E,A={}){const{origin:C={row:0,column:0},value:P=1}=A,{column:D,row:U}=C;checkPointIsInteger(C,"Origin");const G=maskToOutputMask(_,A,{clone:!0});for(let X=Math.max(U,0);X<Math.min(E.height+U,_.height);X++)for(let q=Math.max(D,0);q<Math.min(E.width+D,_.width);q++)E.getBit(q-D,X-U)&&G.setBit(q,X,P);return G}function invert(_,E){if(_ instanceof Image){const A=getOutputImage(_,E);_.alpha&&copyAlpha(_,A);const{maxValue:C,size:P}=A;for(let D=0;D<P;D++)for(let U=0;U<_.components;U++)A.setValueByIndex(D,U,C-_.getValueByIndex(D,U));return A}else{const A=maskToOutputMask(_,E);for(let C=0;C<A.size;C++)A.setBitByIndex(C,!_.getBitByIndex(C));return A}}function level(_,E={}){const A=_.minMax();let{inputMin:C=A.min,inputMax:P=A.max,outputMin:D=0,outputMax:U=_.maxValue,gamma:G=1}=E;const{channels:X=new Array(_.components).fill(0).map((K,J)=>J)}=E;validateChannels(X,_),checkProcessable(_,{bitDepth:[8,16]});const q=getOutputImage(_,E,{clone:!0}),Z=getClamp(_);C=getValueArray(C,_.channels),P=getValueArray(P,_.channels),D=getValueArray(D,_.channels),U=getValueArray(U,_.channels),G=getValueArray(G,_.channels);for(let K=0;K<_.height;K++)for(let J=0;J<_.width;J++)for(const Q of X){const ht=_.getValue(J,K,Q),Et=Math.max(Math.min(ht,P[Q]),C[Q]);let xt=Z((Et-C[Q])/(P[Q]-C[Q]));Number.isNaN(xt)&&(xt=0);const gt=Z(xt**(1/G[Q])*(U[Q]-D[Q])+D[Q]);q.setValue(J,K,Q,gt)}return q}function getValueArray(_,E){if(Array.isArray(_)){if(_.length===E)return _;throw new RangeError("array length is not compatible with channel option")}else return new Array(E).fill(_)}function or(_,E,A){const C=maskToOutputMask(_,A);if(_.width!==E.width||_.height!==E.height)throw new RangeError("both masks must have the same size");for(let P=0;P<C.size;P++)_.getBitByIndex(P)||E.getBitByIndex(P)?C.setBitByIndex(P,1):C.setBitByIndex(P,0);return C}function flipX(_){checkProcessable(_,{bitDepth:[8,16]});for(let E=0;E<_.height;E++)for(let A=0;A<Math.floor(_.width/2);A++){const C=A,P=_.width-A-1;for(let D=0;D<_.channels;D++){const U=_.getValue(C,E,D);_.setValue(C,E,D,_.getValue(P,E,D)),_.setValue(P,E,D,U)}}return _}function flipY(_){checkProcessable(_,{bitDepth:[8,16]});for(let E=0;E<Math.floor(_.height/2);E++)for(let A=0;A<_.width;A++){const C=E,P=_.height-E-1;for(let D=0;D<_.channels;D++){const U=_.getValue(A,C,D);_.setValue(A,C,D,_.getValue(A,P,D)),_.setValue(A,P,D,U)}}return _}function flip(_,E={}){const{axis:A="horizontal"}=E,C=getOutputImage(_,E,{clone:!0});return A==="horizontal"?flipX(C):flipY(A==="vertical"?C:flipX(C))}function medianFilter(_,E){const{cellSize:A=3,borderType:C="reflect101",borderValue:P}=E;if(checkProcessable(_,{bitDepth:[8,16]}),A<1)throw new RangeError(`Invalid property "cellSize". Must be greater than 0. Received ${A}.`);if(A%2===0)throw new RangeError(`Invalid property "cellSize". Must be an odd number. Received ${A}.`);const D=getBorderInterpolation(C,P),U=Image.createFrom(_),G=A**2,X=new Uint16Array(G),q=(A-1)/2;for(let Z=0;Z<_.channels;Z++)for(let K=0;K<_.height;K++)for(let J=0;J<_.width;J++){let Q=0;for(let ht=-q;ht<=q;ht++)for(let Et=-q;Et<=q;Et++)X[Q++]=D(J+Et,K+ht,Z,_);U.setValue(J,K,Z,xMedian(X))}return U}function pixelate(_,E){const{cellSize:A,algorithm:C="center"}=E;if(!Number.isInteger(A))throw new TypeError("cellSize must be an integer");if(A<2)throw new RangeError("cellSize must be greater than 1");const P=getOutputImage(_,E),D=getCellValueFunction(C);for(let U=0;U<_.channels;U++)for(let G=0;G<_.width;G+=A)for(let X=0;X<_.height;X+=A){const q=Math.min(A,_.width-G),Z=Math.min(A,_.height-X),K=D(_,U,{width:q,height:Z,origin:{column:G,row:X}});for(let J=G;J<G+q;J++)for(let Q=X;Q<X+Z;Q++)P.setValue(J,Q,U,K)}return P}function getCellCenter(_,E,A){const C={column:Math.floor((A.origin.column+A.origin.column+A.width-1)/2),row:Math.floor((A.origin.row+A.origin.row+A.height-1)/2)};return _.getValue(C.column,C.row,E)}function getCellMean(_,E,A){let C=0;for(let P=A.origin.column;P<A.origin.column+A.width;P++)for(let D=A.origin.row;D<A.origin.row+A.height;D++)C+=_.getValue(P,D,E);return Math.round(C/(A.width*A.height))}function getCellMedian(_,E,A){const C=[];for(let P=A.origin.column;P<A.origin.column+A.width;P++)for(let D=A.origin.row;D<A.origin.row+A.height;D++)C.push(_.getValue(P,D,E));return xMedian(C)}function getCellValueFunction(_){switch(_){case"mean":return getCellMean;case"median":return getCellMedian;case"center":return getCellCenter;default:assertUnreachable(_);break}}function getBorderPoints(_,E={}){const{innerBorders:A=!1,allowCorners:C=!1}=E;A||(_=_.solidFill());const P=[];for(let D=0;D<_.width;D++)_.getBit(D,0)&&P.push({column:D,row:0}),_.getBit(D,_.height-1)&&P.push({column:D,row:_.height-1});for(let D=0;D<_.height;D++)_.getBit(0,D)&&P.push({column:0,row:D}),_.getBit(_.width-1,D)&&P.push({column:_.width-1,row:D});for(let D=1;D<_.height-1;D++)for(let U=1;U<_.width-1;U++)_.getBit(U,D)&&((_.getBit(U-1,D)===0||_.getBit(U,D-1)===0||_.getBit(U+1,D)===0||_.getBit(U,D+1)===0)&&P.push({column:U,row:D}),C&&(_.getBit(U-1,D-1)===0||_.getBit(U-1,D+1)===0||_.getBit(U+1,D-1)===0||_.getBit(U+1,D+1)===0)&&P.push({column:U,row:D}));return P}function getLineLength(_,E){return Math.hypot(_.column-E.column,_.row-E.row)}function getPolygonPerimeter(_){let E=0;for(let A=0;A<_.length;A++)E+=getLineLength(_[(A+1)%_.length],_[A]);return E}function getPolygonArea(_){let E=0;for(let A=0;A<_.length;A++){const C=(A+1)%_.length;E+=_[A].column*_[C].row,E-=_[A].row*_[C].column}return Math.abs(E/2)}function getExtendedBorderPoints(_){const E=_.getBorderPoints({allowCorners:!0,innerBorders:!1}),A=[];for(const C of E)A.push(C,{column:C.column+1,row:C.row},{column:C.column+1,row:C.row+1},{column:C.column,row:C.row+1});return A}function monotoneChainConvexHull(_,E={}){const{sorted:A=!1}=E;A||(_=_.slice(),_.sort(byXThenY));const C=_.length,P=new Array(C*2);let D=0;for(let G=0;G<C;G++){const X=_[G];for(;D>=2&&cw(P[D-2],P[D-1],X)<=0;)D--;P[D++]=X}const U=D+1;for(let G=C-2;G>=0;G--){const X=_[G];for(;D>=U&&cw(P[D-2],P[D-1],X)<=0;)D--;P[D++]=X}return P.slice(0,D-1)}function cw(_,E,A){return(E.row-_.row)*(A.column-_.column)-(E.column-_.column)*(A.row-_.row)}function byXThenY(_,E){return _.column===E.column?_.row-E.row:_.column-E.column}function getConvexHull(_){const E=getExtendedBorderPoints(_);if(E.length===0)return{points:[],surface:0,perimeter:0};const A=monotoneChainConvexHull(E),C=getPolygonPerimeter(A),P=getPolygonArea(A);return{points:A,perimeter:C,surface:P}}function getFeret(_){const E=_.getConvexHull(),A=E.points;if(E.surface===0)return{minDiameter:{length:0,points:[{column:0,row:0},{column:0,row:0}],angle:0,calliperLines:[[{column:0,row:0},{column:0,row:0}],[{column:0,row:0},{column:0,row:0}]]},maxDiameter:{length:0,points:[{column:0,row:0},{column:0,row:0}],angle:0,calliperLines:[[{column:0,row:0},{column:0,row:0}],[{column:0,row:0},{column:0,row:0}]]},aspectRatio:1};let C=Number.POSITIVE_INFINITY,P=0,D=[],U;for(let gt=0;gt<A.length;gt++){const bt=getAngle(A[gt],A[(gt+1)%A.length]),rt=rotate$1(-bt,A);let tt=0,at=[];for(let wt=0;wt<A.length;wt++){const yt=Math.abs(rt[gt].row-rt[wt].row);yt>tt&&(tt=yt,at=[rt[gt],rt[wt]])}if(tt<C){C=tt,P=bt,D=at;const{minIndex:wt,maxIndex:yt}=findPointIndexesOfExtremeColumns(rt);U=getMinLines(P,wt,yt,rt,D)}}const G={points:rotate$1(P,D),length:C,angle:toDegrees(P),calliperLines:U};let X=[],q=0,Z=[];for(let gt=0;gt<A.length-1;gt++)for(let bt=gt+1;bt<A.length;bt++){const rt=(A[gt].column-A[bt].column)**2+(A[gt].row-A[bt].row)**2;rt>q&&(q=rt,X=[A[gt],A[bt]],Z=[gt,bt])}const K=getAngle(X[0],X[1]),J=rotate$1(-K,A),{minIndex:Q,maxIndex:ht}=findPointsIndexesOfExtremeRows(J),Et=getMaxLines(K,Q,ht,J,Z),xt={length:Math.sqrt(q),angle:toDegrees(getAngle(X[0],X[1])),points:X,calliperLines:Et};return{minDiameter:G,maxDiameter:xt,aspectRatio:G.length/xt.length}}function findPointIndexesOfExtremeColumns(_){let E=0,A=0;for(let C=0;C<_.length;C++)_[C].column>_[E].column&&(E=C),_[C].column<_[A].column&&(A=C);return{minIndex:A,maxIndex:E}}function findPointsIndexesOfExtremeRows(_){let E=0,A=0;for(let C=0;C<_.length;C++)_[C].row>_[E].row&&(E=C),_[C].row<_[A].row&&(A=C);return{minIndex:A,maxIndex:E}}function getMinLines(_,E,A,C,P){const D=[{column:C[E].column,row:P[0].row},{column:C[A].column,row:P[0].row}],U=[{column:C[E].column,row:P[1].row},{column:C[A].column,row:P[1].row}];return[rotate$1(_,D),rotate$1(_,U)]}function getMaxLines(_,E,A,C,P){const D=[{column:C[P[0]].column,row:C[E].row},{column:C[P[0]].column,row:C[A].row}],U=[{column:C[P[1]].column,row:C[E].row},{column:C[P[1]].column,row:C[A].row}];return[rotate$1(_,D),rotate$1(_,U)]}const leftFirst=(_,E)=>_.column<=E.column?-1:1,topFirst=(_,E)=>_.row>=E.row?-1:1;function getMbrAngle(_){const E=_.slice();E.sort(leftFirst);const A=E.slice(0,2),C=E.slice(2,4);A.sort(topFirst),C.sort(topFirst);const P=A[0],D=C[0];return-toDegrees(getAngle(P,D))}function getMbrFromPoints(_){if(_.length===0)return{points:[],angle:0,width:0,height:0,surface:0,perimeter:0,aspectRatio:0};if(_.length===1)return{points:[_[0],_[0],_[0],_[0]],perimeter:0,surface:0,angle:0,width:0,height:0,aspectRatio:1};let E=[],A=Number.POSITIVE_INFINITY,C=0,P=[];for(let K=0;K<_.length;K++){const J=getAngle(_[K],_[(K+1)%_.length]);E=rotate$1(-J,_);const Q=E[K].column,ht=E[K].row,Et=E[(K+1)%E.length].column,xt=E[(K+1)%E.length].row;let gt=!0,bt=0,rt=0,tt=0;for(const lt of E){const ct=lt.column,ut=lt.row,dt=(ct-Q)/(Et-Q);gt?(gt=!1,bt=dt,rt=dt):(dt<bt&&(bt=dt),dt>rt&&(rt=dt));const _t=(-(Et-Q)*ut+Et*ht-xt*Q)/(Et-Q);Math.abs(_t)>Math.abs(tt)&&(tt=_t)}const at={column:Q+bt*(Et-Q),row:ht},wt={column:Q+rt*(Et-Q),row:ht},yt=Math.abs(tt*(bt-rt)*(Et-Q));yt<A&&(C=J,A=yt,P=[wt,at,{column:at.column,row:at.row-tt},{column:wt.column,row:wt.row-tt}])}const D=rotate$1(C,P),U=[Math.hypot(P[0].column-P[1].column,P[0].row-P[1].row),Math.hypot(P[0].column-P[3].column,P[0].row-P[3].row)],G=Math.max(...U),X=Math.min(...U),q=getMbrAngle(D),Z=X/G;return{points:D,surface:A,angle:q,width:G,height:X,perimeter:2*G+2*X,aspectRatio:Z}}function getMbr(_){const E=monotoneChainConvexHull(getExtendedBorderPoints(_));return getMbrFromPoints(E)}function checkKernel(_){if(_.length%2===0||_[0].length%2===0)throw new TypeError("the number of rows and columns of the kernel must be odd")}function erode(_,E={}){let A=!1;E.kernel===void 0&&(A=!0);const{kernel:C=[[1,1,1],[1,1,1],[1,1,1]],iterations:P=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(C);let D=!0;if(!A){t:for(const G of C)for(const X of G)if(X!==1){D=!1;break t}}let U=_;for(let G=0;G<P;G++)if(U instanceof Mask)if(D){const X=U.clone();U=erodeMaskOnlyOnes(U,X,C[0].length,C.length)}else{const X=Mask.createFrom(_);U=erodeMask(U,X,C)}else if(D){const X=Image.createFrom(_);U=erodeGreyOnlyOnes(U,X,C[0].length,C.length)}else{const X=Image.createFrom(_);U=erodeGrey(U,X,C)}return U}function erodeGrey(_,E,A){const C=A[0].length,P=A.length,D=(C-1)/2,U=(P-1)/2;for(let G=0;G<_.height;G++)for(let X=0;X<_.width;X++){let q=_.maxValue;for(let Z=0;Z<P;Z++)for(let K=0;K<C;K++){if(A[Z][K]!==1)continue;const J=K-D+X,Q=Z-U+G;if(J<0||Q<0||J>=_.width||Q>=_.height)continue;const ht=_.getValue(J,Q,0);ht<q&&(q=ht)}E.setValue(X,G,0,q)}return E}function erodeGreyOnlyOnes(_,E,A,C){const P=(A-1)/2,D=(C-1)/2,U=[];for(let G=0;G<_.width;G++)U.push(0);for(let G=0;G<_.height;G++){for(let X=0;X<_.width;X++){let q=_.maxValue;for(let Z=Math.max(0,G-D);Z<Math.min(_.height,G+D+1);Z++){const K=_.getValue(X,Z,0);K<q&&(q=K)}U[X]=q}for(let X=0;X<_.width;X++){let q=_.maxValue;for(let Z=Math.max(0,X-P);Z<Math.min(_.width,X+P+1);Z++)U[Z]<q&&(q=U[Z]);E.setValue(X,G,0,q)}}return E}function erodeMask(_,E,A){const C=A[0].length,P=A.length,D=(C-1)/2,U=(P-1)/2;for(let G=0;G<_.height;G++)for(let X=0;X<_.width;X++){let q=1;for(let Z=0;Z<P;Z++)for(let K=0;K<C;K++){if(A[Z][K]!==1)continue;const J=K-D+X,Q=Z-U+G;if(Q<0||J<0||J>=_.width||Q>=_.height)continue;if(_.getBit(J,Q)===0){q=0;break}}q===1&&E.setBit(X,G,1)}return E}function erodeMaskOnlyOnes(_,E,A,C){const P=(A-1)/2,D=(C-1)/2,U=[];for(let G=0;G<_.width;G++)U.push(0);for(let G=0;G<_.height;G++){for(let X=0;X<_.width;X++){U[X]=1;for(let q=Math.max(0,G-D);q<Math.min(_.height,G+D+1);q++)if(_.getBit(X,q)===0){U[X]=0;break}}for(let X=0;X<_.width;X++)if(E.getBit(X,G)!==0){for(let q=Math.max(0,X-P);q<Math.min(_.width,X+P+1);q++)if(U[q]===0){E.setBit(X,G,0);break}}}return E}function dilate(_,E={}){let A=!1;E.kernel===void 0&&(A=!0);const{kernel:C=[[1,1,1],[1,1,1],[1,1,1]],iterations:P=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(C);let D=!0;if(!A){t:for(const G of C)for(const X of G)if(X!==1){D=!1;break t}}let U=_;for(let G=0;G<P;G++)if(U instanceof Mask)if(D){const X=U.clone();U=dilatMaskOnlyOnes(U,X,C[0].length,C.length)}else{const X=Mask.createFrom(U);U=dilateMask(U,X,C)}else if(D){const X=Image.createFrom(U);U=dilateGreyOnlyOnes(U,X,C[0].length,C.length)}else{const X=Image.createFrom(U);U=dilateGrey(U,X,C)}return U}function dilateGrey(_,E,A){const C=A[0].length,P=A.length,D=(C-1)/2,U=(P-1)/2;for(let G=0;G<_.height;G++)for(let X=0;X<_.width;X++){let q=0;for(let Z=0;Z<P;Z++)for(let K=0;K<C;K++){if(A[Z][K]!==1)continue;const J=K-D+X,Q=Z-U+G;if(J<0||Q<0||J>=_.width||Q>=_.height)continue;const ht=_.getValue(J,Q,0);ht>q&&(q=ht)}E.setValue(X,G,0,q)}return E}function dilateGreyOnlyOnes(_,E,A,C){const P=(A-1)/2,D=(C-1)/2,U=[];for(let G=0;G<_.width;G++)U.push(0);for(let G=0;G<_.height;G++){for(let X=0;X<_.width;X++){let q=0;for(let Z=Math.max(0,G-D);Z<Math.min(_.height,G+D+1);Z++){const K=_.getValue(X,Z,0);K>q&&(q=K)}U[X]=q}for(let X=0;X<_.width;X++){let q=0;for(let Z=Math.max(0,X-P);Z<Math.min(_.width,X+P+1);Z++)U[Z]>q&&(q=U[Z]);E.setValue(X,G,0,q)}}return E}function dilateMask(_,E,A){const C=A[0].length,P=A.length,D=(C-1)/2,U=(P-1)/2;for(let G=0;G<_.height;G++)for(let X=0;X<_.width;X++){let q=0;for(let Z=0;Z<P;Z++)for(let K=0;K<C;K++){if(A[Z][K]!==1)continue;const J=K-D+X,Q=Z-U+G;if(Q<0||J<0||J>=_.width||Q>=_.height)continue;if(_.getBit(J,Q)===1){q=1;break}}q===1&&E.setBit(X,G,1)}return E}function dilatMaskOnlyOnes(_,E,A,C){const P=(A-1)/2,D=(C-1)/2,U=[];for(let G=0;G<_.width;G++)U.push(1);for(let G=0;G<_.height;G++){for(let X=0;X<_.width;X++){U[X]=0;for(let q=Math.max(0,G-D);q<Math.min(_.height,G+D+1);q++)if(_.getBit(X,q)===1){U[X]=1;break}}for(let X=0;X<_.width;X++)if(E.getBit(X,G)!==1){for(let q=Math.max(0,X-P);q<Math.min(_.width,X+P+1);q++)if(U[q]===1){E.setBit(X,G,1);break}}}return E}function open(_,E={}){const{kernel:A=[[1,1,1],[1,1,1],[1,1,1]],iterations:C=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(A);let P=_;for(let D=0;D<C;D++)P=P.erode({kernel:A}),P=P.dilate({kernel:A});return P}function close(_,E={}){const{kernel:A=[[1,1,1],[1,1,1],[1,1,1]],iterations:C=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(A);let P=_;for(let D=0;D<C;D++)P=P.dilate({kernel:A}).erode({kernel:A});return P}function topHat(_,E={}){const{kernel:A=[[1,1,1],[1,1,1],[1,1,1]],iterations:C=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(A);let P=_;for(let D=0;D<C;D++){const U=P.open({kernel:A});P=subtract(U,P,{absolute:!0})}return P}function bottomHat(_,E={}){const{kernel:A=[[1,1,1],[1,1,1],[1,1,1]],iterations:C=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(A);let P=_;for(let D=0;D<C;D++){const U=P.close({kernel:A});P=subtract(U,P,{absolute:!0})}return P}function morphologicalGradient(_,E={}){const{kernel:A=[[1,1,1],[1,1,1],[1,1,1]],iterations:C=1}=E;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(A);let P=_;for(let D=0;D<C;D++){const U=P.dilate({kernel:A}),G=P.erode({kernel:A});P=subtract(U,G,{absolute:!0})}return P}function*borderIterator(_){for(let E=0;E<_.width;E++)yield E;for(let E=2;E<_.height;E++)yield E*_.width-1;for(let E=0;E<_.width;E++)yield _.width*_.height-E-1;for(let E=_.height-2;E>=1;E--)yield E*_.width}const MAX_ARRAY=65536,toProcess=new Uint32Array(MAX_ARRAY);function multipleFloodFill(_,E={}){const{startPixels:A=[0],startPixelValue:C=0,newPixelValue:P=1,allowCorners:D=!1}=E,U=maskToOutputMask(_,E,{clone:!0}),G=Mask.createFrom(_);let X=0,q=0;for(const K of A)U.getBitByIndex(K)===C&&(toProcess[q++%MAX_ARRAY]=K,G.setBitByIndex(K,1),U.setBitByIndex(K,P));for(;X<q;){assert(q-X<=MAX_ARRAY);const K=toProcess[X++%MAX_ARRAY];U.setBitByIndex(K,P);const J=K<_.width,Q=K%_.width===0,ht=K%_.width===_.width-1,Et=K>_.size-_.width;if(!Et){const xt=K+_.width;Z(xt)}if(!Q){const xt=K-1;Z(xt)}if(!J){const xt=K-_.width;Z(xt)}if(!ht){const xt=K+1;Z(xt)}if(D){if(!J){if(!Q){const xt=K-_.width-1;Z(xt)}if(!ht){const xt=K-_.width+1;Z(xt)}}if(!Et){if(!Q){const xt=K+_.width-1;Z(xt)}if(!ht){const xt=K+_.width+1;Z(xt)}}}}function Z(K){G.getBitByIndex(K)||U.getBitByIndex(K)===C&&(toProcess[q++%MAX_ARRAY]=K,G.setBitByIndex(K,1))}return U}function clearBorder(_,E={}){const{allowCorners:A=!1,out:C,color:P="white"}=E;return multipleFloodFill(_,{startPixels:borderIterator(_),startPixelValue:P==="white"?1:0,newPixelValue:P==="white"?0:1,allowCorners:A,out:C})}const kernelX=[[-1,0,1],[-2,0,2],[-1,0,1]],kernelY=[[-1,-2,-1],[0,0,0],[1,2,1]];function cannyEdgeDetector(_,E={}){const{hysteresis:A=!0,lowThreshold:C=.04,highThreshold:P=.1,gaussianBlurOptions:D={sigma:1}}=E,U=C*_.maxValue,G=P*_.maxValue;checkProcessable(_,{colorModel:"GREY"});const X=_.width,q=_.height,Z=_.gaussianBlur(D),K=Z.rawDirectConvolution(kernelY),J=Z.rawDirectConvolution(kernelX),Q=new Float64Array(_.size);for(let gt=0;gt<_.size;gt++)Q[gt]=Math.hypot(K[gt],J[gt]);const ht=new Float64Array(_.size),Et=new Float64Array(_.size),xt=imageToOutputMask(_,E);for(let gt=1;gt<X-1;gt++)for(let bt=1;bt<q-1;bt++){const rt=K[getIndex(gt,bt,_,0)],tt=J[getIndex(gt,bt,_,0)],at=getDirection(rt,tt),wt=Q[getIndex(gt,bt,_,0)];(at===0&&wt>=Q[getIndex(gt,bt-1,_,0)]&&wt>=Q[getIndex(gt,bt+1,_,0)]||at===1&&wt>=Q[getIndex(gt-1,bt-1,_,0)]&&wt>=Q[getIndex(gt+1,bt+1,_,0)]||at===2&&wt>=Q[getIndex(gt-1,bt,_,0)]&&wt>=Q[getIndex(gt+1,bt,_,0)]||at===3&&wt>=Q[getIndex(gt-1,bt+1,_,0)]&&wt>=Q[getIndex(gt+1,bt-1,_,0)])&&(ht[getIndex(gt,bt,_,0)]=wt)}for(let gt=0;gt<X*q;++gt){const bt=ht[gt];let rt=0;bt>G&&(rt++,xt.setBitByIndex(gt,1)),bt>U&&rt++,Et[gt]=rt}if(A){let gt=[];for(let bt=1;bt<X-1;++bt)for(let rt=1;rt<q-1;++rt)if(Et[getIndex(bt,rt,_,0)]===1){t:for(let tt=bt-1;tt<bt+2;++tt)for(let at=rt-1;at<rt+2;++at)if(Et[getIndex(tt,at,_,0)]===2){gt.push([bt,rt]),xt.setValue(bt,rt,0,1);break t}}for(;gt.length>0;){const bt=[];for(const rt of gt)for(let tt=-1;tt<2;++tt)for(let at=-1;at<2;++at){if(tt===0&&at===0)continue;const wt=rt[0]+tt,yt=rt[1]+at;Et[getIndex(yt,wt,_,0)]===1&&xt.getValue(yt,wt,0)===0&&(bt.push([wt,yt]),xt.setValue(yt,wt,0,1))}gt=bt}}return xt}function getDirection(_,E){return(Math.round(Math.atan2(E,_)*(4/Math.PI))+4)%4}function floodFill(_,E={}){const{origin:A={row:0,column:0},allowCorners:C=!1,out:P}=E,D=getIndex(A.column,A.row,_);return multipleFloodFill(_,{startPixels:[D],allowCorners:C,out:P})}function solidFill(_,E={}){const{allowCorners:A=!1}=E,C=maskToOutputMask(_,E,{clone:!0}),D=_.invert().clearBorder({allowCorners:A});return C.or(D,{out:C})}function boolToNumber(_){let E;return typeof _=="boolean"?E=_?1:0:E=_,E}class Mask{width;height;size;bitDepth;colorModel;components;channels;alpha;maxValue;origin;data;constructor(E,A,C={}){const{data:P,origin:D={row:0,column:0}}=C;if(E<1||!Number.isInteger(E))throw new RangeError(`width must be an integer and at least 1. Received ${E}`);if(A<1||!Number.isInteger(A))throw new RangeError(`height must be an integer and at least 1. Received ${A}`);this.width=E,this.height=A,this.size=E*A,this.bitDepth=1,this.colorModel="BINARY",this.origin=D;const U=colorModels[this.colorModel];if(this.components=U.components,this.alpha=U.alpha,this.channels=U.channels,this.maxValue=1,P===void 0)this.data=new Uint8Array(this.size);else{const G=this.size*this.channels;if(P.length!==G)throw new RangeError(`incorrect data size: ${P.length}. Expected ${G}`);this.data=P}}static createFrom(E,A={}){const{width:C=E.width,height:P=E.height,origin:D=E.origin}=A;return new Mask(C,P,{origin:D,...A})}getPixel(E,A){const C=[],P=A*this.width+E;return C.push(this.data[P]),C}setPixel(E,A,C){const P=A*this.width+E;this.data[P]=C[0]}setVisiblePixel(E,A,C){E>=0&&E<this.width&&A>=0&&A<this.height&&this.setPixel(E,A,C)}getPixelByIndex(E){return[this.data[E]]}setPixelByIndex(E,A){this.data[E]=A[0]}static fromPoints(E,A,C){const P=new Mask(E,A);for(const D of C)P.setBit(D.column,D.row,1);return P}clone(){return Mask.createFrom(this,{data:this.data.slice()})}getBit(E,A){const C=A*this.width+E;return this.data[C]}setBit(E,A,C){const P=A*this.width+E;this.data[P]=C}getBitByIndex(E){return this.data[E*this.channels]}setBitByIndex(E,A){this.data[E*this.channels]=boolToNumber(A)}getNbNonZeroPixels(){let E=0;for(const A of this.data)A&&E++;return E}getValue(E,A,C){return checkChannel(C),this.getBit(E,A)}setValue(E,A,C,P){checkChannel(C),this.setBit(E,A,P)}getValueByIndex(E,A){return checkChannel(A),this.getBitByIndex(E)}setValueByIndex(E,A,C){checkChannel(A),this.setBitByIndex(E,C)}getValueByPoint(E){return this.getValue(E.column,E.row,0)}setValueByPoint(E,A){this.setValue(E.column,E.row,0,A)}getRawImage(){return{width:this.width,height:this.height,data:this.data}}[Symbol.for("nodejs.util.inspect.custom")](){let E;return this.height>20||this.width>20?E="[...]":E=printData$1(this),`Mask {
  width: ${this.width}
  height: ${this.height}
  data: ${E}
}`}fill(E){const A=boolToNumber(E);return this.data.fill(A),this}convertColor(E){return convertColor(this,E)}invert(E){return invert(this,E)}subtract(E,A){return subtract(this,E,A)}and(E,A){return and(this,E,A)}or(E,A){return or(this,E,A)}getBorderPoints(E){return getBorderPoints(this,E)}getConvexHull(){return getConvexHull(this)}getMbr(){return getMbr(this)}getFeret(){return getFeret(this)}erode(E){return erode(this,E)}dilate(E){return dilate(this,E)}open(E){return open(this,E)}close(E){return close(this,E)}topHat(E){return topHat(this,E)}bottomHat(E){return bottomHat(this,E)}morphologicalGradient(E){return morphologicalGradient(this,E)}clearBorder(E){return clearBorder(this,E)}floodFill(E){return floodFill(this,E)}solidFill(E){return solidFill(this,E)}drawPoints(E,A={}){return drawPoints(this,E,A)}drawLine(E,A,C={}){return drawLineOnMask(this,E,A,C)}drawPolyline(E,A={}){return drawPolylineOnMask(this,E,A)}drawPolygon(E,A={}){return drawPolygonOnMask(this,E,A)}drawRectangle(E={}){return drawRectangle(this,E)}copyTo(E,A={}){return copyTo(this,E,A)}paintMask(E,A){return paintMaskOnMask(this,E,A)}}function printData$1(_){const E=[];for(let A=0;A<_.height;A++){const C=[];for(let P=0;P<_.width;P++)C.push(String(_.getBit(P,A)));E.push(`[${C.join(" ")}]`)}return E.join(`
        `)}function checkChannel(_){if(_!==0)throw new RangeError(`channel value must be 0 on type Mask. Received ${_}`)}function subtract(_,E,A={}){const{absolute:C=!1}=A;_ instanceof Image&&checkProcessable(_,{bitDepth:[1,8,16],components:[1,3],alpha:!1}),validateForComparison(_,E);const P=_.clone();if(P instanceof Image)for(let D=0;D<_.size;D++)for(let U=0;U<_.channels;U++){const G=_.getValueByIndex(D,U)-E.getValueByIndex(D,U);C?G<0?P.setValueByIndex(D,U,-G):P.setValueByIndex(D,U,G):G<0?P.setValueByIndex(D,U,0):P.setValueByIndex(D,U,G)}else if(_ instanceof Mask&&E instanceof Mask)for(let D=0;D<_.size;D++){const U=_.getBitByIndex(D)-E.getBitByIndex(D);C?P.setBitByIndex(D,U?1:0):P.setBitByIndex(D,U>0?1:0)}return P}function add(_,E){_ instanceof Image&&checkProcessable(_,{bitDepth:[8,16],components:[1,3],alpha:!1}),validateForComparison(_,E);const A=_.clone(),C=getClamp(_);for(let P=0;P<_.size;P++)for(let D=0;D<_.channels;D++){const U=_.getValueByIndex(P,D)+E.getValueByIndex(P,D);A.setValueByIndex(P,D,C(U))}return A}function multiply(_,E,A={}){const{channels:C=new Array(_.channels).fill(0).map((D,U)=>U)}=A;validateChannels(C,_);const P=getOutputImage(_,A,{clone:!0});if(C.length===0)return P;for(const D of C)for(let U=0;U<P.height;U++)for(let G=0;G<P.width;G++){const X=P.getValue(G,U,D)*E;P.setClampedValue(G,U,D,X)}return P}function mean(_,E){const A=new Array(_.channels).fill(0),C=E?E.points.length:_.size;if(C===0)throw new RangeError("Array of coordinates is empty.");if(E)for(const P of E.points)for(let D=0;D<_.channels;D++){if(P.column<0||P.column>=_.width||P.row<0||P.row>=_.height)throw new RangeError(`Invalid coordinate: {column: ${P.column}, row: ${P.row}}.`);A[D]+=_.getValueByPoint(P,D)}else for(let P=0;P<_.height;P++)for(let D=0;D<_.width;D++)for(let U=0;U<_.channels;U++)A[U]+=_.getValue(D,P,U);return A.map(P=>P/C)}function histogram(_,E={}){let{channel:A}=E;const{slots:C=2**_.bitDepth}=E;if(!(C!==0&&(C&C-1)===0))throw new RangeError("slots must be a power of 2, for example: 64, 256, 1024");if(typeof A!="number"){if(_.channels!==1)throw new TypeError("channel option is mandatory for multi-channel images");A=0}validateChannel(A,_);const P=new Uint32Array(C);let D=0;const U=Math.log2(C);D=_.bitDepth-U;for(let G=0;G<_.size;G++)P[_.getValueByIndex(G,A)>>D]++;return P}function median(_,E){const A=new Array(_.channels).fill(0);if(E){if(E.points.length===0)throw new RangeError("Array of coordinates is empty.");for(let C=0;C<_.channels;C++){const P=[];for(const D of E.points){if(D.column<0||D.column>=_.width||D.row<0||D.row>=_.height)throw new RangeError(`Invalid coordinate: {column: ${D.column}, row: ${D.row}}.`);P.push(_.getValueByPoint(D,C))}A[C]=quickMedian(P)}}else for(let C=0;C<_.channels;C++){const P=_.getChannel(C);A[C]=quickMedian(P)}return A}function variance(_,E){const A=_.mean(E),C=new Array(_.channels).fill(0);if(E)for(const D of E.points)for(let U=0;U<_.channels;U++)C[U]+=(_.getValue(D.column,D.row,U)-A[U])**2;else for(let D=0;D<_.size;D++)for(let U=0;U<_.channels;U++)C[U]+=(_.getValueByIndex(D,U)-A[U])**2;const P=E?E.points.length*_.channels:_.size*_.channels;return C.map(D=>D/P)}class MultivariateLinearRegression{constructor(E,A,C={}){const{intercept:P=!0,statistics:D=!0}=C;if(this.statistics=D,E===!0)this.weights=A.weights,this.inputs=A.inputs,this.outputs=A.outputs,this.intercept=A.intercept;else{E=new Matrix(E),A=new Matrix(A),P&&E.addColumn(new Array(E.rows).fill(1));let U=E.transpose();const G=U.mmul(E),X=U.mmul(A),q=new SVD(G).inverse(),Z=X.transpose().mmul(q).transpose();if(this.weights=Z.to2DArray(),this.inputs=E.columns,this.outputs=A.columns,P&&this.inputs--,this.intercept=P,D){const K=E.mmul(Z),Q=A.clone().addM(K.neg()).to2DArray().map(ht=>Math.pow(ht[0],2)).reduce((ht,Et)=>ht+Et)/(A.rows-E.columns);this.stdError=Math.sqrt(Q),this.stdErrorMatrix=pseudoInverse(G).mul(Q),this.stdErrors=this.stdErrorMatrix.diagonal().map(ht=>Math.sqrt(ht)),this.tStats=this.weights.map((ht,Et)=>this.stdErrors[Et]===0?0:ht[0]/this.stdErrors[Et])}}}predict(E){if(Array.isArray(E)){if(typeof E[0]=="number")return this._predict(E);if(Array.isArray(E[0])){const A=new Array(E.length);for(let C=0;C<E.length;C++)A[C]=this._predict(E[C]);return A}}else if(Matrix.isMatrix(E)){const A=new Matrix(E.rows,this.outputs);for(let C=0;C<E.rows;C++)A.setRow(C,this._predict(E.getRow(C)));return A}throw new TypeError("x must be a matrix or array of numbers")}_predict(E){const A=new Array(this.outputs);if(this.intercept)for(let C=0;C<this.outputs;C++)A[C]=this.weights[this.inputs][C];else A.fill(0);for(let C=0;C<this.inputs;C++)for(let P=0;P<this.outputs;P++)A[P]+=this.weights[C][P]*E[C];return A}score(){throw new Error("score method is not implemented yet")}toJSON(){return{name:"multivariateLinearRegression",weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map((E,A)=>({label:A===this.weights.length-1?"Intercept":`X Variable ${A+1}`,coefficients:E,standardError:this.stdErrors[A],tStat:this.tStats[A]}))}:void 0}}static load(E){if(E.name!=="multivariateLinearRegression")throw new Error("not a MLR model");return new MultivariateLinearRegression(!0,E)}}var r$1={grad:.9,turn:360,rad:360/(2*Math.PI)},t$1=function(_){return typeof _=="string"?_.length>0:typeof _=="number"},n$1=function(_,E,A){return E===void 0&&(E=0),A===void 0&&(A=Math.pow(10,E)),Math.round(A*_)/A+0},e$1=function(_,E,A){return E===void 0&&(E=0),A===void 0&&(A=1),_>A?A:_>E?_:E},u$1=function(_){return(_=isFinite(_)?_%360:0)>0?_:_+360},a$1=function(_){return{r:e$1(_.r,0,255),g:e$1(_.g,0,255),b:e$1(_.b,0,255),a:e$1(_.a)}},o$1=function(_){return{r:n$1(_.r),g:n$1(_.g),b:n$1(_.b),a:n$1(_.a,3)}},i$2=/^#([0-9a-f]{3,8})$/i,s=function(_){var E=_.toString(16);return E.length<2?"0"+E:E},h$1=function(_){var E=_.r,A=_.g,C=_.b,P=_.a,D=Math.max(E,A,C),U=D-Math.min(E,A,C),G=U?D===E?(A-C)/U:D===A?2+(C-E)/U:4+(E-A)/U:0;return{h:60*(G<0?G+6:G),s:D?U/D*100:0,v:D/255*100,a:P}},b$1=function(_){var E=_.h,A=_.s,C=_.v,P=_.a;E=E/360*6,A/=100,C/=100;var D=Math.floor(E),U=C*(1-A),G=C*(1-(E-D)*A),X=C*(1-(1-E+D)*A),q=D%6;return{r:255*[C,G,U,U,X,C][q],g:255*[X,C,C,G,U,U][q],b:255*[U,U,X,C,C,G][q],a:P}},g=function(_){return{h:u$1(_.h),s:e$1(_.s,0,100),l:e$1(_.l,0,100),a:e$1(_.a)}},d=function(_){return{h:n$1(_.h),s:n$1(_.s),l:n$1(_.l),a:n$1(_.a,3)}},f=function(_){return b$1((A=(E=_).s,{h:E.h,s:(A*=((C=E.l)<50?C:100-C)/100)>0?2*A/(C+A)*100:0,v:C+A,a:E.a}));var E,A,C},c=function(_){return{h:(E=h$1(_)).h,s:(P=(200-(A=E.s))*(C=E.v)/100)>0&&P<200?A*C/100/(P<=100?P:200-P)*100:0,l:P/2,a:E.a};var E,A,C,P},l$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(_){var E=i$2.exec(_);return E?(_=E[1]).length<=4?{r:parseInt(_[0]+_[0],16),g:parseInt(_[1]+_[1],16),b:parseInt(_[2]+_[2],16),a:_.length===4?n$1(parseInt(_[3]+_[3],16)/255,2):1}:_.length===6||_.length===8?{r:parseInt(_.substr(0,2),16),g:parseInt(_.substr(2,2),16),b:parseInt(_.substr(4,2),16),a:_.length===8?n$1(parseInt(_.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(_){var E=v.exec(_)||m.exec(_);return E?E[2]!==E[4]||E[4]!==E[6]?null:a$1({r:Number(E[1])/(E[2]?100/255:1),g:Number(E[3])/(E[4]?100/255:1),b:Number(E[5])/(E[6]?100/255:1),a:E[7]===void 0?1:Number(E[7])/(E[8]?100:1)}):null},"rgb"],[function(_){var E=l$1.exec(_)||p$1.exec(_);if(!E)return null;var A,C,P=g({h:(A=E[1],C=E[2],C===void 0&&(C="deg"),Number(A)*(r$1[C]||1)),s:Number(E[3]),l:Number(E[4]),a:E[5]===void 0?1:Number(E[5])/(E[6]?100:1)});return f(P)},"hsl"]],object:[[function(_){var E=_.r,A=_.g,C=_.b,P=_.a,D=P===void 0?1:P;return t$1(E)&&t$1(A)&&t$1(C)?a$1({r:Number(E),g:Number(A),b:Number(C),a:Number(D)}):null},"rgb"],[function(_){var E=_.h,A=_.s,C=_.l,P=_.a,D=P===void 0?1:P;if(!t$1(E)||!t$1(A)||!t$1(C))return null;var U=g({h:Number(E),s:Number(A),l:Number(C),a:Number(D)});return f(U)},"hsl"],[function(_){var E=_.h,A=_.s,C=_.v,P=_.a,D=P===void 0?1:P;if(!t$1(E)||!t$1(A)||!t$1(C))return null;var U=(function(G){return{h:u$1(G.h),s:e$1(G.s,0,100),v:e$1(G.v,0,100),a:e$1(G.a)}})({h:Number(E),s:Number(A),v:Number(C),a:Number(D)});return b$1(U)},"hsv"]]},N=function(_,E){for(var A=0;A<E.length;A++){var C=E[A][0](_);if(C)return[C,E[A][1]]}return[null,void 0]},x$1=function(_){return typeof _=="string"?N(_.trim(),y.string):typeof _=="object"&&_!==null?N(_,y.object):[null,void 0]},M$1=function(_,E){var A=c(_);return{h:A.h,s:e$1(A.s+100*E,0,100),l:A.l,a:A.a}},H=function(_){return(299*_.r+587*_.g+114*_.b)/1e3/255},$=function(_,E){var A=c(_);return{h:A.h,s:A.s,l:e$1(A.l+100*E,0,100),a:A.a}},j=(function(){function _(E){this.parsed=x$1(E)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return _.prototype.isValid=function(){return this.parsed!==null},_.prototype.brightness=function(){return n$1(H(this.rgba),2)},_.prototype.isDark=function(){return H(this.rgba)<.5},_.prototype.isLight=function(){return H(this.rgba)>=.5},_.prototype.toHex=function(){return E=o$1(this.rgba),A=E.r,C=E.g,P=E.b,U=(D=E.a)<1?s(n$1(255*D)):"","#"+s(A)+s(C)+s(P)+U;var E,A,C,P,D,U},_.prototype.toRgb=function(){return o$1(this.rgba)},_.prototype.toRgbString=function(){return E=o$1(this.rgba),A=E.r,C=E.g,P=E.b,(D=E.a)<1?"rgba("+A+", "+C+", "+P+", "+D+")":"rgb("+A+", "+C+", "+P+")";var E,A,C,P,D},_.prototype.toHsl=function(){return d(c(this.rgba))},_.prototype.toHslString=function(){return E=d(c(this.rgba)),A=E.h,C=E.s,P=E.l,(D=E.a)<1?"hsla("+A+", "+C+"%, "+P+"%, "+D+")":"hsl("+A+", "+C+"%, "+P+"%)";var E,A,C,P,D},_.prototype.toHsv=function(){return E=h$1(this.rgba),{h:n$1(E.h),s:n$1(E.s),v:n$1(E.v),a:n$1(E.a,3)};var E},_.prototype.invert=function(){return w$1({r:255-(E=this.rgba).r,g:255-E.g,b:255-E.b,a:E.a});var E},_.prototype.saturate=function(E){return E===void 0&&(E=.1),w$1(M$1(this.rgba,E))},_.prototype.desaturate=function(E){return E===void 0&&(E=.1),w$1(M$1(this.rgba,-E))},_.prototype.grayscale=function(){return w$1(M$1(this.rgba,-1))},_.prototype.lighten=function(E){return E===void 0&&(E=.1),w$1($(this.rgba,E))},_.prototype.darken=function(E){return E===void 0&&(E=.1),w$1($(this.rgba,-E))},_.prototype.rotate=function(E){return E===void 0&&(E=15),this.hue(this.hue()+E)},_.prototype.alpha=function(E){return typeof E=="number"?w$1({r:(A=this.rgba).r,g:A.g,b:A.b,a:E}):n$1(this.rgba.a,3);var A},_.prototype.hue=function(E){var A=c(this.rgba);return typeof E=="number"?w$1({h:E,s:A.s,l:A.l,a:A.a}):n$1(A.h)},_.prototype.isEqual=function(E){return this.toHex()===w$1(E).toHex()},_})(),w$1=function(_){return _ instanceof j?_:new j(_)},S=[],k=function(_){_.forEach(function(E){S.indexOf(E)<0&&(E(j,y),S.push(E))})},a=function(_){return typeof _=="string"?_.length>0:typeof _=="number"},t=function(_,E,A){return E===void 0&&(E=0),A===void 0&&(A=Math.pow(10,E)),Math.round(A*_)/A+0},o=function(_,E,A){return E===void 0&&(E=0),A===void 0&&(A=1),_>A?A:_>E?_:E},r=function(_){var E=_/255;return E<.04045?E/12.92:Math.pow((E+.055)/1.055,2.4)},h=function(_){return 255*(_>.0031308?1.055*Math.pow(_,1/2.4)-.055:12.92*_)},n=96.422,p=100,M=82.521,u=function(_){var E,A,C={x:.9555766*(E=_).x+-.0230393*E.y+.0631636*E.z,y:-.0282895*E.x+1.0099416*E.y+.0210077*E.z,z:.0122982*E.x+-.020483*E.y+1.3299098*E.z};return A={r:h(.032404542*C.x-.015371385*C.y-.004985314*C.z),g:h(-.00969266*C.x+.018760108*C.y+41556e-8*C.z),b:h(556434e-9*C.x-.002040259*C.y+.010572252*C.z),a:_.a},{r:o(A.r,0,255),g:o(A.g,0,255),b:o(A.b,0,255),a:o(A.a)}},e=function(_){var E=r(_.r),A=r(_.g),C=r(_.b);return(function(P){return{x:o(P.x,0,n),y:o(P.y,0,p),z:o(P.z,0,M),a:o(P.a)}})((function(P){return{x:1.0478112*P.x+.0228866*P.y+-.050127*P.z,y:.0295424*P.x+.9904844*P.y+-.0170491*P.z,z:-.0092345*P.x+.0150436*P.y+.7521316*P.z,a:P.a}})({x:100*(.4124564*E+.3575761*A+.1804375*C),y:100*(.2126729*E+.7151522*A+.072175*C),z:100*(.0193339*E+.119192*A+.9503041*C),a:_.a}))},w=216/24389,b=24389/27,i$1=function(_){var E=_.l,A=_.a,C=_.b,P=_.alpha,D=P===void 0?1:P;if(!a(E)||!a(A)||!a(C))return null;var U=(function(G){return{l:o(G.l,0,400),a:G.a,b:G.b,alpha:o(G.alpha)}})({l:Number(E),a:Number(A),b:Number(C),alpha:Number(D)});return l(U)},l=function(_){var E=(_.l+16)/116,A=_.a/500+E,C=E-_.b/200;return u({x:(Math.pow(A,3)>w?Math.pow(A,3):(116*A-16)/b)*n,y:(_.l>8?Math.pow((_.l+16)/116,3):_.l/b)*p,z:(Math.pow(C,3)>w?Math.pow(C,3):(116*C-16)/b)*M,a:_.alpha})};function labPlugin(_,E){_.prototype.toLab=function(){return C=e(this.rgba),D=C.y/p,U=C.z/M,P=(P=C.x/n)>w?Math.cbrt(P):(b*P+16)/116,A={l:116*(D=D>w?Math.cbrt(D):(b*D+16)/116)-16,a:500*(P-D),b:200*(D-(U=U>w?Math.cbrt(U):(b*U+16)/116)),alpha:C.a},{l:t(A.l,2),a:t(A.a,2),b:t(A.b,2),alpha:t(A.alpha,3)};var A,C,P,D,U},_.prototype.delta=function(A){A===void 0&&(A="#FFF");var C=A instanceof _?A:new _(A),P=(function(D,U){var G=D.l,X=D.a,q=D.b,Z=U.l,K=U.a,J=U.b,Q=180/Math.PI,ht=Math.PI/180,Et=Math.pow(Math.pow(X,2)+Math.pow(q,2),.5),xt=Math.pow(Math.pow(K,2)+Math.pow(J,2),.5),gt=(G+Z)/2,bt=Math.pow((Et+xt)/2,7),rt=.5*(1-Math.pow(bt/(bt+Math.pow(25,7)),.5)),tt=X*(1+rt),at=K*(1+rt),wt=Math.pow(Math.pow(tt,2)+Math.pow(q,2),.5),yt=Math.pow(Math.pow(at,2)+Math.pow(J,2),.5),lt=(wt+yt)/2,ct=tt===0&&q===0?0:Math.atan2(q,tt)*Q,ut=at===0&&J===0?0:Math.atan2(J,at)*Q;ct<0&&(ct+=360),ut<0&&(ut+=360);var dt=ut-ct,_t=Math.abs(ut-ct);_t>180&&ut<=ct?dt+=360:_t>180&&ut>ct&&(dt-=360);var Ft=ct+ut;_t<=180?Ft/=2:Ft=(ct+ut<360?Ft+360:Ft-360)/2;var Pt=1-.17*Math.cos(ht*(Ft-30))+.24*Math.cos(2*ht*Ft)+.32*Math.cos(ht*(3*Ft+6))-.2*Math.cos(ht*(4*Ft-63)),Ot=Z-G,ne=yt-wt,he=2*Math.sin(ht*dt/2)*Math.pow(wt*yt,.5),Xt=1+.015*Math.pow(gt-50,2)/Math.pow(20+Math.pow(gt-50,2),.5),Wt=1+.045*lt,Kt=1+.015*lt*Pt,de=30*Math.exp(-1*Math.pow((Ft-275)/25,2)),Ct=-2*Math.pow(bt/(bt+Math.pow(25,7)),.5)*Math.sin(2*ht*de);return Math.pow(Math.pow(Ot/1/Xt,2)+Math.pow(ne/1/Wt,2)+Math.pow(he/1/Kt,2)+Ct*ne*he/(1*Wt*1*Kt),.5)})(this.toLab(),C.toLab())/100;return o(t(P,3))},E.object.push([i$1,"lab"])}k([labPlugin]);function formatReferenceForMlr(_,E){const A={r:[],g:[],b:[]};for(const C of _)A.r.push([C.r/E]),A.g.push([C.g/E]),A.b.push([C.b/E]);return A}function formatInputForMlr(_,E){const A=[];for(const C of _)A.push(getRegressionVariables(C.r,C.g,C.b,E));return A}function correctColor(_,E,A){if(checkProcessable(_,{colorModel:["RGB","RGBA"]}),E.length!==A.length)throw new RangeError("number of measured colors and reference colors must be the same");const C=formatInputForMlr(E,_.maxValue),P=formatReferenceForMlr(A,_.maxValue),D=new MultivariateLinearRegression(C,P.r),U=new MultivariateLinearRegression(C,P.g),G=new MultivariateLinearRegression(C,P.b),X=Image.createFrom(_);for(let q=0;q<_.height;q++)for(let Z=0;Z<_.width;Z++){const K=_.getPixel(Z,q),J=getRegressionVariables(K[0],K[1],K[2],_.maxValue),Q=getClamp(_),ht=[0,0,0],Et=D.predict(J)[0]*_.maxValue,xt=U.predict(J)[0]*_.maxValue,gt=G.predict(J)[0]*_.maxValue;ht[0]=Q(Et),ht[1]=Q(xt),ht[2]=Q(gt),_.alpha&&(ht[3]=_.getValue(Z,q,3)),X.setPixel(Z,q,ht)}return X}function getRegressionVariables(_,E,A,C){return _/=C,E/=C,A/=C,[_,E,A,_**2,E**2,A**2,_**3,E**3,A**3,_*E,_*A,A*E]}function getMinMax(_){const E=new Array(_.channels).fill(_.maxValue),A=new Array(_.channels).fill(0);for(let C=0;C<_.height;C++)for(let P=0;P<_.width;P++)for(let D=0;D<_.channels;D++){const U=_.getValue(P,C,D);U<E[D]&&(E[D]=U),U>A[D]&&(A[D]=U)}return{min:E,max:A}}class Image{width;height;size;bitDepth;colorModel;components;channels;alpha;maxValue;origin;originalResolution;meta;data;constructor(E,A,C={}){const{bitDepth:P=8,data:D,colorModel:U="RGB",origin:G={row:0,column:0},meta:X,resolution:q}=C;if(E<1||!Number.isInteger(E))throw new RangeError(`width must be an integer and at least 1. Received ${E}`);if(A<1||!Number.isInteger(A))throw new RangeError(`height must be an integer and at least 1. Received ${A}`);this.width=E,this.height=A,this.size=E*A,this.bitDepth=P,this.colorModel=U,this.origin=G,this.meta=X,this.originalResolution=q;const Z=colorModels[U];if(this.components=Z.components,this.alpha=Z.alpha,this.channels=Z.channels,this.maxValue=2**P-1,D===void 0)this.data=createPixelArray(this.size,this.channels,this.alpha,this.bitDepth,this.maxValue);else{if(P===8&&D instanceof Uint16Array)throw new RangeError(`bitDepth is ${P} but data is Uint16Array`);if(P===16&&D instanceof Uint8Array)throw new RangeError(`bitDepth is ${P} but data is Uint8Array`);const K=this.size*this.channels;if(D.length!==K)throw new RangeError(`incorrect data size: ${D.length}. Expected ${K}`);this.data=D}}get normalizedResolution(){if(!this.originalResolution)return;const E=2.54,A=100;switch(this.originalResolution.unit){case"inch":return{x:this.originalResolution.x/E,y:this.originalResolution.y/E};case"centimeter":return{x:this.originalResolution.x,y:this.originalResolution.y};case"meter":return{x:this.originalResolution.x/A,y:this.originalResolution.y/A};case"unknown":return null;default:throw new Error("Unknown resolution unit.")}}static createFrom(E,A={}){const{width:C=E.width,height:P=E.height}=A;let D;return E instanceof Image?D=E.bitDepth:D=8,new Image(C,P,{bitDepth:D,colorModel:E.colorModel,origin:E.origin,...A})}getPixel(E,A){const C=[],P=(A*this.width+E)*this.channels;for(let D=0;D<this.channels;D++)C.push(this.data[P+D]);return C}getColumn(E){const A=[];for(let C=0;C<this.channels;C++){const P=[];for(let D=0;D<this.height;D++)P.push(this.getValue(E,D,C));A.push(P)}return A}getRow(E){const A=[];for(let C=0;C<this.channels;C++){const P=[];for(let D=0;D<this.width;D++)P.push(this.getValue(D,E,C));A.push(P)}return A}setPixel(E,A,C){const P=(A*this.width+E)*this.channels;for(let D=0;D<this.channels;D++)this.data[P+D]=C[D]}setVisiblePixel(E,A,C){E>=0&&E<this.width&&A>=0&&A<this.height&&this.setPixel(E,A,C)}getPixelByIndex(E){const A=[],C=E*this.channels;for(let P=0;P<this.channels;P++)A.push(this.data[C+P]);return A}setPixelByIndex(E,A){const C=E*this.channels;for(let P=0;P<this.channels;P++)this.data[C+P]=A[P]}getValue(E,A,C){return this.data[(A*this.width+E)*this.channels+C]}setValue(E,A,C,P){this.data[(A*this.width+E)*this.channels+C]=P}setClampedValue(E,A,C,P){P<0?P=0:P>this.maxValue&&(P=this.maxValue),this.data[(A*this.width+E)*this.channels+C]=P}getValueByIndex(E,A){return this.data[E*this.channels+A]}setValueByIndex(E,A,C){this.data[E*this.channels+A]=C}setClampedValueByIndex(E,A,C){C<0?C=0:C>this.maxValue&&(C=this.maxValue),this.data[E*this.channels+A]=C}getValueByPoint(E,A){return this.getValue(E.column,E.row,A)}setValueByPoint(E,A,C){this.setValue(E.column,E.row,A,C)}minMax(){return getMinMax(this)}getRawImage(){return{width:this.width,height:this.height,data:this.data,channels:this.channels,bitDepth:this.bitDepth}}[Symbol.for("nodejs.util.inspect.custom")](){let E;return this.height>20||this.width>20?E="[...]":E=printData(this),`Image {
  width: ${this.width}
  height: ${this.height}
  bitDepth: ${this.bitDepth}
  colorModel: ${this.colorModel}
  channels: ${this.channels}
  data: ${E}
}`}fill(E){if(typeof E=="number")return validateValue(E,this),this.data.fill(E),this;if(E.length!==this.channels)throw new RangeError(`the size of value must match the number of channels (${this.channels}). Received ${E.length}`);for(const A of E)validateValue(A,this);for(let A=0;A<this.data.length;A+=this.channels)for(let C=0;C<=this.channels;C++)this.data[A+C]=E[C];return this}fillChannel(E,A){validateChannel(E,this),validateValue(A,this);for(let C=E;C<this.data.length;C+=this.channels)this.data[C]=A;return this}getChannel(E){validateChannel(E,this);const A=new Array(this.size);for(let C=0;C<this.size;C++)A[C]=this.data[E+C*this.channels];return A}fillAlpha(E){if(validateValue(E,this),!this.alpha)throw new TypeError("fillAlpha can only be called if the image has an alpha channel");const A=this.channels-1;return this.fillChannel(A,E)}clone(){return Image.createFrom(this,{data:this.data.slice()})}changeEach(E){for(let A=0;A<this.data.length;A++)this.data[A]=E(this.data[A])}getCoordinates(E,A=!1){return M$2(E).with("center",()=>{const C=(this.width-1)/2,P=(this.height-1)/2;return A?{column:Math.round(C),row:Math.round(P)}:{column:C,row:P}}).with("top-left",()=>({column:0,row:0})).with("top-right",()=>({column:this.width-1,row:0})).with("bottom-left",()=>({column:0,row:this.height-1})).with("bottom-right",()=>({column:this.width-1,row:this.height-1})).exhaustive()}subtract(E,A={}){return subtract(this,E,A)}add(E){return add(this,E)}multiply(E,A={}){return multiply(this,E,A)}divide(E,A={}){return divide(this,E,A)}histogram(E){return histogram(this,E)}mean(E){return mean(this,E)}median(E){return median(this,E)}variance(E){return variance(this,E)}drawPoints(E,A={}){return drawPoints(this,E,A)}drawLine(E,A,C={}){return drawLineOnImage(this,E,A,C)}drawRectangle(E={}){return drawRectangle(this,E)}drawPolyline(E,A={}){return drawPolylineOnImage(this,E,A)}drawPolygon(E,A={}){return drawPolygonOnImage(this,E,A)}drawCircle(E,A,C={}){return drawCircleOnImage(this,E,A,C)}drawMarker(E,A={}){return drawMarker(this,E,A)}drawMarkers(E,A={}){return drawMarkers(this,E,A)}split(){return split(this)}convertColor(E,A){return convertColor(this,E,A)}convertBitDepth(E,A){return convertBitDepth(this,E,A)}grey(E){return grey(this,E)}copyTo(E,A={}){return copyTo(this,E,A)}threshold(E={}){return threshold(this,E)}crop(E){return crop(this,E)}cropRectangle(E,A){return cropRectangle(this,E,A)}cropAlpha(E={}){return cropAlpha(this,E)}extract(E,A){return extract(this,E,A)}paintMask(E,A){return paintMaskOnImage(this,E,A)}blur(E){return blur(this,E)}pixelate(E){return pixelate(this,E)}directConvolution(E,A){return directConvolution(this,E,A)}rawDirectConvolution(E,A){return rawDirectConvolution(this,E,A)}separableConvolution(E,A,C){return separableConvolution(this,E,A,C)}gaussianBlur(E){return gaussianBlur(this,E)}flip(E){return flip(this,E)}invert(E){return invert(this,E)}hypotenuse(E,A){return hypotenuse(this,E,A)}gradientFilter(E){return gradientFilter(this,E)}derivativeFilter(E){return derivativeFilter(this,E)}level(E){return level(this,E)}increaseContrast(E={}){return increaseContrast(this,E)}correctColor(E,A){return correctColor(this,E,A)}medianFilter(E){return medianFilter(this,E)}resize(E){return resize(this,E)}rotate(E){return rotate(this,E)}transform(E,A){return transform(this,E,A)}transformRotate(E,A){return transformRotate(this,E,A)}erode(E){return erode(this,E)}dilate(E){return dilate(this,E)}open(E){return open(this,E)}close(E){return close(this,E)}topHat(E){return topHat(this,E)}bottomHat(E){return bottomHat(this,E)}morphologicalGradient(E){return morphologicalGradient(this,E)}cannyEdgeDetector(E){return cannyEdgeDetector(this,E)}}function createPixelArray(_,E,A,C,P){const D=E*_,U=M$2(C).with(8,()=>new Uint8Array(D)).with(16,()=>new Uint16Array(D)).otherwise(()=>{throw new RangeError(`invalid bitDepth: ${C}`)});if(A)for(let G=E-1;G<D;G+=E)U[G]=P;return U}function printData(_){const E=[],A=_.bitDepth===8?3:5;for(let C=0;C<_.height;C++){const P=[];for(let D=0;D<_.width;D++)for(let U=0;U<_.channels;U++)P.push(String(_.getValue(D,C,U)).padStart(A," "));E.push(`[${P.join(" ")}]`)}return`{
    [
     ${E.join(`
     `)}
    ]
  }`}function copyData(_,E){if(E.width!==_.width||E.height!==_.height||E.colorModel!==_.colorModel)throw new RangeError("images width, height or color model is different");E.data=_.data.slice()}function getOutputImage(_,E={},A={}){const{out:C}=E,{newParameters:P,clone:D}=A;if(C===void 0)return D?_.clone():Image.createFrom(_,P);{if(!(C instanceof Image))throw new TypeError("out must be an Image");const U={width:_.width,height:_.height,bitDepth:_.bitDepth,colorModel:_.colorModel,...P};return checkRequirements(U,C),D&&_!==C&&copyData(_,C),C}}function maskToOutputImage(_,E={}){const{out:A}=E;if(A===void 0)return Image.createFrom(_,{colorModel:"GREY"});{if(!(A instanceof Image))throw new TypeError("out must be an Image");const C={width:_.width,height:_.height,bitDepth:8,colorModel:"GREY"};return checkRequirements(C,A),A}}function imageToOutputMask(_,E={}){const{out:A}=E;if(A===void 0)return Mask.createFrom(_);{if(!(A instanceof Mask))throw new TypeError("out must be a Mask");const C={width:_.width,height:_.height,bitDepth:1,colorModel:"BINARY"};return checkRequirements(C,A),A}}function checkRequirements(_,E){for(const A in _){const C=A;if(E[C]!==_[C])throw new RangeError(`cannot use out image. Its ${A} property must be ${_[C]}. Received ${E[C]}`)}}function maskToOutputMask(_,E={},A={}){const{out:C}=E,{newParameters:P,clone:D}=A;if(C===void 0)return D?_.clone():Mask.createFrom(_,P);{if(!(C instanceof Mask))throw new TypeError("out must be a Mask");const U={width:_.width,height:_.height,bitDepth:1,colorModel:"BINARY"};return checkRequirements(U,C),D&&_!==C&&copyData(_,C),C}}function decode$3(_,E="utf8"){return new TextDecoder(E).decode(_)}const encoder$1=new TextEncoder;function encode(_){return encoder$1.encode(_)}const defaultByteLength=1024*8,hostBigEndian=(()=>{const _=new Uint8Array(4),E=new Uint32Array(_.buffer);return!((E[0]=1)&_[0])})(),typedArrays={int8:globalThis.Int8Array,uint8:globalThis.Uint8Array,int16:globalThis.Int16Array,uint16:globalThis.Uint16Array,int32:globalThis.Int32Array,uint32:globalThis.Uint32Array,uint64:globalThis.BigUint64Array,int64:globalThis.BigInt64Array,float32:globalThis.Float32Array,float64:globalThis.Float64Array};class IOBuffer{buffer;byteLength;byteOffset;length;offset;lastWrittenByte;littleEndian;_data;_mark;_marks;constructor(E=defaultByteLength,A={}){let C=!1;typeof E=="number"?E=new ArrayBuffer(E):(C=!0,this.lastWrittenByte=E.byteLength);const P=A.offset?A.offset>>>0:0,D=E.byteLength-P;let U=P;(ArrayBuffer.isView(E)||E instanceof IOBuffer)&&(E.byteLength!==E.buffer.byteLength&&(U=E.byteOffset+P),E=E.buffer),C?this.lastWrittenByte=D:this.lastWrittenByte=0,this.buffer=E,this.length=D,this.byteLength=D,this.byteOffset=U,this.offset=0,this.littleEndian=!0,this._data=new DataView(this.buffer,U,D),this._mark=0,this._marks=[]}available(E=1){return this.offset+E<=this.length}isLittleEndian(){return this.littleEndian}setLittleEndian(){return this.littleEndian=!0,this}isBigEndian(){return!this.littleEndian}setBigEndian(){return this.littleEndian=!1,this}skip(E=1){return this.offset+=E,this}back(E=1){return this.offset-=E,this}seek(E){return this.offset=E,this}mark(){return this._mark=this.offset,this}reset(){return this.offset=this._mark,this}pushMark(){return this._marks.push(this.offset),this}popMark(){const E=this._marks.pop();if(E===void 0)throw new Error("Mark stack empty");return this.seek(E),this}rewind(){return this.offset=0,this}ensureAvailable(E=1){if(!this.available(E)){const C=(this.offset+E)*2,P=new Uint8Array(C);P.set(new Uint8Array(this.buffer)),this.buffer=P.buffer,this.length=C,this.byteLength=C,this._data=new DataView(this.buffer)}return this}readBoolean(){return this.readUint8()!==0}readInt8(){return this._data.getInt8(this.offset++)}readUint8(){return this._data.getUint8(this.offset++)}readByte(){return this.readUint8()}readBytes(E=1){return this.readArray(E,"uint8")}readArray(E,A){const C=typedArrays[A].BYTES_PER_ELEMENT*E,P=this.byteOffset+this.offset,D=this.buffer.slice(P,P+C);if(this.littleEndian===hostBigEndian&&A!=="uint8"&&A!=="int8"){const G=new Uint8Array(this.buffer.slice(P,P+C));G.reverse();const X=new typedArrays[A](G.buffer);return this.offset+=C,X.reverse(),X}const U=new typedArrays[A](D);return this.offset+=C,U}readInt16(){const E=this._data.getInt16(this.offset,this.littleEndian);return this.offset+=2,E}readUint16(){const E=this._data.getUint16(this.offset,this.littleEndian);return this.offset+=2,E}readInt32(){const E=this._data.getInt32(this.offset,this.littleEndian);return this.offset+=4,E}readUint32(){const E=this._data.getUint32(this.offset,this.littleEndian);return this.offset+=4,E}readFloat32(){const E=this._data.getFloat32(this.offset,this.littleEndian);return this.offset+=4,E}readFloat64(){const E=this._data.getFloat64(this.offset,this.littleEndian);return this.offset+=8,E}readBigInt64(){const E=this._data.getBigInt64(this.offset,this.littleEndian);return this.offset+=8,E}readBigUint64(){const E=this._data.getBigUint64(this.offset,this.littleEndian);return this.offset+=8,E}readChar(){return String.fromCharCode(this.readInt8())}readChars(E=1){let A="";for(let C=0;C<E;C++)A+=this.readChar();return A}readUtf8(E=1){return decode$3(this.readBytes(E))}decodeText(E=1,A="utf8"){return decode$3(this.readBytes(E),A)}writeBoolean(E){return this.writeUint8(E?255:0),this}writeInt8(E){return this.ensureAvailable(1),this._data.setInt8(this.offset++,E),this._updateLastWrittenByte(),this}writeUint8(E){return this.ensureAvailable(1),this._data.setUint8(this.offset++,E),this._updateLastWrittenByte(),this}writeByte(E){return this.writeUint8(E)}writeBytes(E){this.ensureAvailable(E.length);for(let A=0;A<E.length;A++)this._data.setUint8(this.offset++,E[A]);return this._updateLastWrittenByte(),this}writeInt16(E){return this.ensureAvailable(2),this._data.setInt16(this.offset,E,this.littleEndian),this.offset+=2,this._updateLastWrittenByte(),this}writeUint16(E){return this.ensureAvailable(2),this._data.setUint16(this.offset,E,this.littleEndian),this.offset+=2,this._updateLastWrittenByte(),this}writeInt32(E){return this.ensureAvailable(4),this._data.setInt32(this.offset,E,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeUint32(E){return this.ensureAvailable(4),this._data.setUint32(this.offset,E,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeFloat32(E){return this.ensureAvailable(4),this._data.setFloat32(this.offset,E,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeFloat64(E){return this.ensureAvailable(8),this._data.setFloat64(this.offset,E,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeBigInt64(E){return this.ensureAvailable(8),this._data.setBigInt64(this.offset,E,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeBigUint64(E){return this.ensureAvailable(8),this._data.setBigUint64(this.offset,E,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeChar(E){return this.writeUint8(E.charCodeAt(0))}writeChars(E){for(let A=0;A<E.length;A++)this.writeUint8(E.charCodeAt(A));return this}writeUtf8(E){return this.writeBytes(encode(E))}toArray(){return new Uint8Array(this.buffer,this.byteOffset,this.lastWrittenByte)}getWrittenByteLength(){return this.lastWrittenByte-this.byteOffset}_updateLastWrittenByte(){this.offset>this.lastWrittenByte&&(this.lastWrittenByte=this.offset)}}class BMPDecoder{bufferData;pixelDataOffset;width;height;bitsPerPixel;xPixelsPerMeter;yPixelsPerMeter;compression;colorMasks;constructor(E){this.bufferData=new IOBuffer(E);const A=this.bufferData.readBytes(2);if(A[0]!==66&&A[1]!==77)throw new Error("This is not a BMP image or the encoding is not correct.");if(this.pixelDataOffset=this.bufferData.skip(8).readUint32(),this.width=this.bufferData.skip(4).readUint32(),this.height=this.bufferData.readUint32(),this.bitsPerPixel=this.bufferData.seek(28).readUint16(),this.bitsPerPixel!==1&&this.bitsPerPixel!==8&&this.bitsPerPixel!==24&&this.bitsPerPixel!==32)throw new Error(`Invalid number of bits per pixel. Supported number of bits per pixel: 1, 8, 24, 32. Received: ${this.bitsPerPixel}`);if(this.compression=this.bufferData.readUint32(),this.compression!==0&&this.compression!==3)throw new Error("Only BI_RGB and BI_BITFIELDS compression methods are allowed. ");if(this.colorMasks=[this.bufferData.seek(54).readUint32(),this.bufferData.readUint32(),this.bufferData.readUint32()],this.bitsPerPixel===32&&(this.colorMasks[0]!==16711680||this.colorMasks[1]!==65280||this.colorMasks[2]!==255))throw new Error(`Unsupported color masks detected in 32-bit BMP image. Only standard RGBA (ff0000, ff00, ff) masks are supported. Received: ${this.colorMasks[0].toString(16)},${this.colorMasks[1].toString(16)},${this.colorMasks[2].toString(16)}.`);this.bufferData.skip(1),this.xPixelsPerMeter=this.bufferData.seek(38).readInt32(),this.yPixelsPerMeter=this.bufferData.readInt32(),this.bufferData.skip(1)}decode(){this.bufferData.seek(this.pixelDataOffset),this.bufferData.setBigEndian();const E=Math.ceil(this.bitsPerPixel/8),A=E%2===0?E-1:E,C=this.decodePixelData(E,A);return{width:this.width,height:this.height,bitsPerPixel:this.bitsPerPixel,compression:this.compression,colorMasks:this.colorMasks,channels:E,components:A,data:C,yPixelsPerMeter:this.yPixelsPerMeter,xPixelsPerMeter:this.xPixelsPerMeter}}decodePixelData(E,A){const C=new Uint8Array(this.height*this.width*E);return this.bitsPerPixel===1?this.decodeBitDepth1Pixels(C):E===A?this.decodeStandardPixels(C,E):this.decodePixelsWithAlpha(C,E,A),C}decodeBitDepth1Pixels(E){let A=0;for(let C=0;C<this.height;C++)for(let P=0;P<this.width;P++){const D=P%32;D===0&&(A=this.bufferData.readUint32()),A&1<<31-D&&(E[(this.height-C-1)*this.width+P]=1)}}decodeStandardPixels(E,A){const C=this.calculatePadding(A);for(let P=0;P<this.height;P++){const D=(this.height-P-1)*this.width;for(let U=0;U<this.width;U++)for(let G=A-1;G>=0;G--)E[(D+U)*A+G]=this.bufferData.readByte();this.bufferData.skip(C)}}decodePixelsWithAlpha(E,A,C){for(let P=0;P<this.height;P++){const D=(this.height-P-1)*this.width;for(let U=0;U<this.width;U++){const G=(D+U)*A;for(let X=C-1;X>=0;X--)E[G+X]=this.bufferData.readByte();E[G+C]=this.bufferData.readByte()}}}calculatePadding(E){return this.width*E%4===0?0:4-this.width*E%4}}function decode$2(_){return new BMPDecoder(_).decode()}var encoder={exports:{}},hasRequiredEncoder;function requireEncoder(){return hasRequiredEncoder||(hasRequiredEncoder=1,(function(_){function E(C){var P=Math.floor,D=new Array(64),U=new Array(64),G=new Array(64),X=new Array(64),q,Z,K,J,Q=new Array(65535),ht=new Array(65535),Et=new Array(64),xt=new Array(64),gt=[],bt=0,rt=7,tt=new Array(64),at=new Array(64),wt=new Array(64),yt=new Array(256),lt=new Array(2048),ct,ut=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],dt=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],_t=[0,1,2,3,4,5,6,7,8,9,10,11],Ft=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],Pt=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],Ot=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],ne=[0,1,2,3,4,5,6,7,8,9,10,11],he=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],Xt=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function Wt(It){for(var Qt=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],Zt=0;Zt<64;Zt++){var Jt=P((Qt[Zt]*It+50)/100);Jt<1?Jt=1:Jt>255&&(Jt=255),D[ut[Zt]]=Jt}for(var ge=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],me=0;me<64;me++){var Me=P((ge[me]*It+50)/100);Me<1?Me=1:Me>255&&(Me=255),U[ut[me]]=Me}for(var Ut=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],Yt=0,re=0;re<8;re++)for(var Gt=0;Gt<8;Gt++)G[Yt]=1/(D[ut[Yt]]*Ut[re]*Ut[Gt]*8),X[Yt]=1/(U[ut[Yt]]*Ut[re]*Ut[Gt]*8),Yt++}function Kt(It,Qt){for(var Zt=0,Jt=0,ge=new Array,me=1;me<=16;me++){for(var Me=1;Me<=It[me];Me++)ge[Qt[Jt]]=[],ge[Qt[Jt]][0]=Zt,ge[Qt[Jt]][1]=me,Jt++,Zt++;Zt*=2}return ge}function de(){q=Kt(dt,_t),Z=Kt(Ot,ne),K=Kt(Ft,Pt),J=Kt(he,Xt)}function Ct(){for(var It=1,Qt=2,Zt=1;Zt<=15;Zt++){for(var Jt=It;Jt<Qt;Jt++)ht[32767+Jt]=Zt,Q[32767+Jt]=[],Q[32767+Jt][1]=Zt,Q[32767+Jt][0]=Jt;for(var ge=-(Qt-1);ge<=-It;ge++)ht[32767+ge]=Zt,Q[32767+ge]=[],Q[32767+ge][1]=Zt,Q[32767+ge][0]=Qt-1+ge;It<<=1,Qt<<=1}}function te(){for(var It=0;It<256;It++)lt[It]=19595*It,lt[It+256>>0]=38470*It,lt[It+512>>0]=7471*It+32768,lt[It+768>>0]=-11059*It,lt[It+1024>>0]=-21709*It,lt[It+1280>>0]=32768*It+8421375,lt[It+1536>>0]=-27439*It,lt[It+1792>>0]=-5329*It}function jt(It){for(var Qt=It[0],Zt=It[1]-1;Zt>=0;)Qt&1<<Zt&&(bt|=1<<rt),Zt--,rt--,rt<0&&(bt==255?(Mt(255),Mt(0)):Mt(bt),rt=7,bt=0)}function Mt(It){gt.push(It)}function qt(It){Mt(It>>8&255),Mt(It&255)}function oe(It,Qt){var Zt,Jt,ge,me,Me,Ut,Yt,re,Gt=0,xe,Ie=8,fe=64;for(xe=0;xe<Ie;++xe){Zt=It[Gt],Jt=It[Gt+1],ge=It[Gt+2],me=It[Gt+3],Me=It[Gt+4],Ut=It[Gt+5],Yt=It[Gt+6],re=It[Gt+7];var _e=Zt+re,ve=Zt-re,Re=Jt+Yt,Be=Jt-Yt,De=ge+Ut,Le=ge-Ut,Ye=me+Me,Ze=me-Me,ze=_e+Ye,W=_e-Ye,O=Re+De,V=Re-De;It[Gt]=ze+O,It[Gt+4]=ze-O;var B=(V+W)*.707106781;It[Gt+2]=W+B,It[Gt+6]=W-B,ze=Ze+Le,O=Le+Be,V=Be+ve;var z=(ze-V)*.382683433,Y=.5411961*ze+z,nt=1.306562965*V+z,it=O*.707106781,ot=ve+it,st=ve-it;It[Gt+5]=st+Y,It[Gt+3]=st-Y,It[Gt+1]=ot+nt,It[Gt+7]=ot-nt,Gt+=8}for(Gt=0,xe=0;xe<Ie;++xe){Zt=It[Gt],Jt=It[Gt+8],ge=It[Gt+16],me=It[Gt+24],Me=It[Gt+32],Ut=It[Gt+40],Yt=It[Gt+48],re=It[Gt+56];var vt=Zt+re,ft=Zt-re,Rt=Jt+Yt,Bt=Jt-Yt,St=ge+Ut,kt=ge-Ut,Nt=me+Me,pt=me-Me,$t=vt+Nt,Lt=vt-Nt,ie=Rt+St,le=Rt-St;It[Gt]=$t+ie,It[Gt+32]=$t-ie;var Ae=(le+Lt)*.707106781;It[Gt+16]=Lt+Ae,It[Gt+48]=Lt-Ae,$t=pt+kt,ie=kt+Bt,le=Bt+ft;var Ht=($t-le)*.382683433,ee=.5411961*$t+Ht,ke=1.306562965*le+Ht,mt=ie*.707106781,Tt=ft+mt,Vt=ft-mt;It[Gt+40]=Vt+ee,It[Gt+24]=Vt-ee,It[Gt+8]=Tt+ke,It[Gt+56]=Tt-ke,Gt++}var At;for(xe=0;xe<fe;++xe)At=It[xe]*Qt[xe],Et[xe]=At>0?At+.5|0:At-.5|0;return Et}function se(){qt(65504),qt(16),Mt(74),Mt(70),Mt(73),Mt(70),Mt(0),Mt(1),Mt(1),Mt(0),qt(1),qt(1),Mt(0),Mt(0)}function ue(It){if(It){qt(65505),It[0]===69&&It[1]===120&&It[2]===105&&It[3]===102?qt(It.length+2):(qt(It.length+5+2),Mt(69),Mt(120),Mt(105),Mt(102),Mt(0));for(var Qt=0;Qt<It.length;Qt++)Mt(It[Qt])}}function ye(It,Qt){qt(65472),qt(17),Mt(8),qt(Qt),qt(It),Mt(3),Mt(1),Mt(17),Mt(0),Mt(2),Mt(17),Mt(1),Mt(3),Mt(17),Mt(1)}function pe(){qt(65499),qt(132),Mt(0);for(var It=0;It<64;It++)Mt(D[It]);Mt(1);for(var Qt=0;Qt<64;Qt++)Mt(U[Qt])}function Ee(){qt(65476),qt(418),Mt(0);for(var It=0;It<16;It++)Mt(dt[It+1]);for(var Qt=0;Qt<=11;Qt++)Mt(_t[Qt]);Mt(16);for(var Zt=0;Zt<16;Zt++)Mt(Ft[Zt+1]);for(var Jt=0;Jt<=161;Jt++)Mt(Pt[Jt]);Mt(1);for(var ge=0;ge<16;ge++)Mt(Ot[ge+1]);for(var me=0;me<=11;me++)Mt(ne[me]);Mt(17);for(var Me=0;Me<16;Me++)Mt(he[Me+1]);for(var Ut=0;Ut<=161;Ut++)Mt(Xt[Ut])}function we(It){typeof It>"u"||It.constructor!==Array||It.forEach(Qt=>{if(typeof Qt=="string"){qt(65534);var Zt=Qt.length;qt(Zt+2);var Jt;for(Jt=0;Jt<Zt;Jt++)Mt(Qt.charCodeAt(Jt))}})}function zt(){qt(65498),qt(12),Mt(3),Mt(1),Mt(0),Mt(2),Mt(17),Mt(3),Mt(17),Mt(0),Mt(63),Mt(0)}function Dt(It,Qt,Zt,Jt,ge){for(var me=ge[0],Me=ge[240],Ut,Yt=16,re=63,Gt=64,xe=oe(It,Qt),Ie=0;Ie<Gt;++Ie)xt[ut[Ie]]=xe[Ie];var fe=xt[0]-Zt;Zt=xt[0],fe==0?jt(Jt[0]):(Ut=32767+fe,jt(Jt[ht[Ut]]),jt(Q[Ut]));for(var _e=63;_e>0&&xt[_e]==0;_e--);if(_e==0)return jt(me),Zt;for(var ve=1,Re;ve<=_e;){for(var Be=ve;xt[ve]==0&&ve<=_e;++ve);var De=ve-Be;if(De>=Yt){Re=De>>4;for(var Le=1;Le<=Re;++Le)jt(Me);De=De&15}Ut=32767+xt[ve],jt(ge[(De<<4)+ht[Ut]]),jt(Q[Ut]),ve++}return _e!=re&&jt(me),Zt}function be(){for(var It=String.fromCharCode,Qt=0;Qt<256;Qt++)yt[Qt]=It(Qt)}this.encode=function(It,Qt){new Date().getTime(),Qt&&ae(Qt),gt=new Array,bt=0,rt=7,qt(65496),se(),we(It.comments),ue(It.exifBuffer),pe(),ye(It.width,It.height),Ee(),zt();var Zt=0,Jt=0,ge=0;bt=0,rt=7,this.encode.displayName="_encode_";for(var me=It.data,Me=It.width,Ut=It.height,Yt=Me*4,re,Gt=0,xe,Ie,fe,_e,ve,Re,Be,De;Gt<Ut;){for(re=0;re<Yt;){for(_e=Yt*Gt+re,ve=_e,Re=-1,Be=0,De=0;De<64;De++)Be=De>>3,Re=(De&7)*4,ve=_e+Be*Yt+Re,Gt+Be>=Ut&&(ve-=Yt*(Gt+1+Be-Ut)),re+Re>=Yt&&(ve-=re+Re-Yt+4),xe=me[ve++],Ie=me[ve++],fe=me[ve++],tt[De]=(lt[xe]+lt[Ie+256>>0]+lt[fe+512>>0]>>16)-128,at[De]=(lt[xe+768>>0]+lt[Ie+1024>>0]+lt[fe+1280>>0]>>16)-128,wt[De]=(lt[xe+1280>>0]+lt[Ie+1536>>0]+lt[fe+1792>>0]>>16)-128;Zt=Dt(tt,G,Zt,q,K),Jt=Dt(at,X,Jt,Z,J),ge=Dt(wt,X,ge,Z,J),re+=32}Gt+=8}if(rt>=0){var Le=[];Le[1]=rt+1,Le[0]=(1<<rt+1)-1,jt(Le)}return qt(65497),Buffer.from(gt)};function ae(It){if(It<=0&&(It=1),It>100&&(It=100),ct!=It){var Qt=0;It<50?Qt=Math.floor(5e3/It):Qt=Math.floor(200-It*2),Wt(Qt),ct=It}}function ce(){var It=new Date().getTime();C||(C=50),be(),de(),Ct(),te(),ae(C),new Date().getTime()-It}ce()}_.exports=A;function A(C,P){typeof P>"u"&&(P=50);var D=new E(P),U=D.encode(C,P);return{data:U,width:C.width,height:C.height}}})(encoder)),encoder.exports}var decoder={exports:{}},hasRequiredDecoder;function requireDecoder(){return hasRequiredDecoder||(hasRequiredDecoder=1,(function(_){var E=(function(){var P=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),D=4017,U=799,G=3406,X=2276,q=1567,Z=3784,K=5793,J=2896;function Q(){}function ht(at,wt){for(var yt=0,lt=[],ct,ut,dt=16;dt>0&&!at[dt-1];)dt--;lt.push({children:[],index:0});var _t=lt[0],Ft;for(ct=0;ct<dt;ct++){for(ut=0;ut<at[ct];ut++){for(_t=lt.pop(),_t.children[_t.index]=wt[yt];_t.index>0;){if(lt.length===0)throw new Error("Could not recreate Huffman Table");_t=lt.pop()}for(_t.index++,lt.push(_t);lt.length<=ct;)lt.push(Ft={children:[],index:0}),_t.children[_t.index]=Ft.children,_t=Ft;yt++}ct+1<dt&&(lt.push(Ft={children:[],index:0}),_t.children[_t.index]=Ft.children,_t=Ft)}return lt[0].children}function Et(at,wt,yt,lt,ct,ut,dt,_t,Ft,Pt){yt.precision,yt.samplesPerLine,yt.scanLines;var Ot=yt.mcusPerLine,ne=yt.progressive;yt.maxH,yt.maxV;var he=wt,Xt=0,Wt=0;function Kt(){if(Wt>0)return Wt--,Xt>>Wt&1;if(Xt=at[wt++],Xt==255){var Ut=at[wt++];if(Ut)throw new Error("unexpected marker: "+(Xt<<8|Ut).toString(16))}return Wt=7,Xt>>>7}function de(Ut){for(var Yt=Ut,re;(re=Kt())!==null;){if(Yt=Yt[re],typeof Yt=="number")return Yt;if(typeof Yt!="object")throw new Error("invalid huffman sequence")}return null}function Ct(Ut){for(var Yt=0;Ut>0;){var re=Kt();if(re===null)return;Yt=Yt<<1|re,Ut--}return Yt}function te(Ut){var Yt=Ct(Ut);return Yt>=1<<Ut-1?Yt:Yt+(-1<<Ut)+1}function jt(Ut,Yt){var re=de(Ut.huffmanTableDC),Gt=re===0?0:te(re);Yt[0]=Ut.pred+=Gt;for(var xe=1;xe<64;){var Ie=de(Ut.huffmanTableAC),fe=Ie&15,_e=Ie>>4;if(fe===0){if(_e<15)break;xe+=16;continue}xe+=_e;var ve=P[xe];Yt[ve]=te(fe),xe++}}function Mt(Ut,Yt){var re=de(Ut.huffmanTableDC),Gt=re===0?0:te(re)<<Ft;Yt[0]=Ut.pred+=Gt}function qt(Ut,Yt){Yt[0]|=Kt()<<Ft}var oe=0;function se(Ut,Yt){if(oe>0){oe--;return}for(var re=ut,Gt=dt;re<=Gt;){var xe=de(Ut.huffmanTableAC),Ie=xe&15,fe=xe>>4;if(Ie===0){if(fe<15){oe=Ct(fe)+(1<<fe)-1;break}re+=16;continue}re+=fe;var _e=P[re];Yt[_e]=te(Ie)*(1<<Ft),re++}}var ue=0,ye;function pe(Ut,Yt){for(var re=ut,Gt=dt,xe=0;re<=Gt;){var Ie=P[re],fe=Yt[Ie]<0?-1:1;switch(ue){case 0:var _e=de(Ut.huffmanTableAC),ve=_e&15,xe=_e>>4;if(ve===0)xe<15?(oe=Ct(xe)+(1<<xe),ue=4):(xe=16,ue=1);else{if(ve!==1)throw new Error("invalid ACn encoding");ye=te(ve),ue=xe?2:3}continue;case 1:case 2:Yt[Ie]?Yt[Ie]+=(Kt()<<Ft)*fe:(xe--,xe===0&&(ue=ue==2?3:0));break;case 3:Yt[Ie]?Yt[Ie]+=(Kt()<<Ft)*fe:(Yt[Ie]=ye<<Ft,ue=0);break;case 4:Yt[Ie]&&(Yt[Ie]+=(Kt()<<Ft)*fe);break}re++}ue===4&&(oe--,oe===0&&(ue=0))}function Ee(Ut,Yt,re,Gt,xe){var Ie=re/Ot|0,fe=re%Ot,_e=Ie*Ut.v+Gt,ve=fe*Ut.h+xe;Ut.blocks[_e]===void 0&&Pt.tolerantDecoding||Yt(Ut,Ut.blocks[_e][ve])}function we(Ut,Yt,re){var Gt=re/Ut.blocksPerLine|0,xe=re%Ut.blocksPerLine;Ut.blocks[Gt]===void 0&&Pt.tolerantDecoding||Yt(Ut,Ut.blocks[Gt][xe])}var zt=lt.length,Dt,be,ae,ce,It,Qt;ne?ut===0?Qt=_t===0?Mt:qt:Qt=_t===0?se:pe:Qt=jt;var Zt=0,Jt,ge;zt==1?ge=lt[0].blocksPerLine*lt[0].blocksPerColumn:ge=Ot*yt.mcusPerColumn,ct||(ct=ge);for(var me,Me;Zt<ge;){for(be=0;be<zt;be++)lt[be].pred=0;if(oe=0,zt==1)for(Dt=lt[0],It=0;It<ct;It++)we(Dt,Qt,Zt),Zt++;else for(It=0;It<ct;It++){for(be=0;be<zt;be++)for(Dt=lt[be],me=Dt.h,Me=Dt.v,ae=0;ae<Me;ae++)for(ce=0;ce<me;ce++)Ee(Dt,Qt,Zt,ae,ce);if(Zt++,Zt===ge)break}if(Zt===ge)do{if(at[wt]===255&&at[wt+1]!==0)break;wt+=1}while(wt<at.length-2);if(Wt=0,Jt=at[wt]<<8|at[wt+1],Jt<65280)throw new Error("marker was not found");if(Jt>=65488&&Jt<=65495)wt+=2;else break}return wt-he}function xt(at,wt){var yt=[],lt=wt.blocksPerLine,ct=wt.blocksPerColumn,ut=lt<<3,dt=new Int32Array(64),_t=new Uint8Array(64);function Ft(Ct,te,jt){var Mt=wt.quantizationTable,qt,oe,se,ue,ye,pe,Ee,we,zt,Dt=jt,be;for(be=0;be<64;be++)Dt[be]=Ct[be]*Mt[be];for(be=0;be<8;++be){var ae=8*be;if(Dt[1+ae]==0&&Dt[2+ae]==0&&Dt[3+ae]==0&&Dt[4+ae]==0&&Dt[5+ae]==0&&Dt[6+ae]==0&&Dt[7+ae]==0){zt=K*Dt[0+ae]+512>>10,Dt[0+ae]=zt,Dt[1+ae]=zt,Dt[2+ae]=zt,Dt[3+ae]=zt,Dt[4+ae]=zt,Dt[5+ae]=zt,Dt[6+ae]=zt,Dt[7+ae]=zt;continue}qt=K*Dt[0+ae]+128>>8,oe=K*Dt[4+ae]+128>>8,se=Dt[2+ae],ue=Dt[6+ae],ye=J*(Dt[1+ae]-Dt[7+ae])+128>>8,we=J*(Dt[1+ae]+Dt[7+ae])+128>>8,pe=Dt[3+ae]<<4,Ee=Dt[5+ae]<<4,zt=qt-oe+1>>1,qt=qt+oe+1>>1,oe=zt,zt=se*Z+ue*q+128>>8,se=se*q-ue*Z+128>>8,ue=zt,zt=ye-Ee+1>>1,ye=ye+Ee+1>>1,Ee=zt,zt=we+pe+1>>1,pe=we-pe+1>>1,we=zt,zt=qt-ue+1>>1,qt=qt+ue+1>>1,ue=zt,zt=oe-se+1>>1,oe=oe+se+1>>1,se=zt,zt=ye*X+we*G+2048>>12,ye=ye*G-we*X+2048>>12,we=zt,zt=pe*U+Ee*D+2048>>12,pe=pe*D-Ee*U+2048>>12,Ee=zt,Dt[0+ae]=qt+we,Dt[7+ae]=qt-we,Dt[1+ae]=oe+Ee,Dt[6+ae]=oe-Ee,Dt[2+ae]=se+pe,Dt[5+ae]=se-pe,Dt[3+ae]=ue+ye,Dt[4+ae]=ue-ye}for(be=0;be<8;++be){var ce=be;if(Dt[8+ce]==0&&Dt[16+ce]==0&&Dt[24+ce]==0&&Dt[32+ce]==0&&Dt[40+ce]==0&&Dt[48+ce]==0&&Dt[56+ce]==0){zt=K*jt[be+0]+8192>>14,Dt[0+ce]=zt,Dt[8+ce]=zt,Dt[16+ce]=zt,Dt[24+ce]=zt,Dt[32+ce]=zt,Dt[40+ce]=zt,Dt[48+ce]=zt,Dt[56+ce]=zt;continue}qt=K*Dt[0+ce]+2048>>12,oe=K*Dt[32+ce]+2048>>12,se=Dt[16+ce],ue=Dt[48+ce],ye=J*(Dt[8+ce]-Dt[56+ce])+2048>>12,we=J*(Dt[8+ce]+Dt[56+ce])+2048>>12,pe=Dt[24+ce],Ee=Dt[40+ce],zt=qt-oe+1>>1,qt=qt+oe+1>>1,oe=zt,zt=se*Z+ue*q+2048>>12,se=se*q-ue*Z+2048>>12,ue=zt,zt=ye-Ee+1>>1,ye=ye+Ee+1>>1,Ee=zt,zt=we+pe+1>>1,pe=we-pe+1>>1,we=zt,zt=qt-ue+1>>1,qt=qt+ue+1>>1,ue=zt,zt=oe-se+1>>1,oe=oe+se+1>>1,se=zt,zt=ye*X+we*G+2048>>12,ye=ye*G-we*X+2048>>12,we=zt,zt=pe*U+Ee*D+2048>>12,pe=pe*D-Ee*U+2048>>12,Ee=zt,Dt[0+ce]=qt+we,Dt[56+ce]=qt-we,Dt[8+ce]=oe+Ee,Dt[48+ce]=oe-Ee,Dt[16+ce]=se+pe,Dt[40+ce]=se-pe,Dt[24+ce]=ue+ye,Dt[32+ce]=ue-ye}for(be=0;be<64;++be){var It=128+(Dt[be]+8>>4);te[be]=It<0?0:It>255?255:It}}tt(ut*ct*8);for(var Pt,Ot,ne=0;ne<ct;ne++){var he=ne<<3;for(Pt=0;Pt<8;Pt++)yt.push(new Uint8Array(ut));for(var Xt=0;Xt<lt;Xt++){Ft(wt.blocks[ne][Xt],_t,dt);var Wt=0,Kt=Xt<<3;for(Ot=0;Ot<8;Ot++){var de=yt[he+Ot];for(Pt=0;Pt<8;Pt++)de[Kt+Pt]=_t[Wt++]}}}return yt}function gt(at){return at<0?0:at>255?255:at}Q.prototype={load:function(wt){var yt=new XMLHttpRequest;yt.open("GET",wt,!0),yt.responseType="arraybuffer",yt.onload=(function(){var lt=new Uint8Array(yt.response||yt.mozResponseArrayBuffer);this.parse(lt),this.onload&&this.onload()}).bind(this),yt.send(null)},parse:function(wt){var yt=this.opts.maxResolutionInMP*1e3*1e3,lt=0;wt.length;function ct(){var fe=wt[lt]<<8|wt[lt+1];return lt+=2,fe}function ut(){var fe=ct(),_e=wt.subarray(lt,lt+fe-2);return lt+=_e.length,_e}function dt(fe){var _e=1,ve=1,Re,Be;for(Be in fe.components)fe.components.hasOwnProperty(Be)&&(Re=fe.components[Be],_e<Re.h&&(_e=Re.h),ve<Re.v&&(ve=Re.v));var De=Math.ceil(fe.samplesPerLine/8/_e),Le=Math.ceil(fe.scanLines/8/ve);for(Be in fe.components)if(fe.components.hasOwnProperty(Be)){Re=fe.components[Be];var Ye=Math.ceil(Math.ceil(fe.samplesPerLine/8)*Re.h/_e),Ze=Math.ceil(Math.ceil(fe.scanLines/8)*Re.v/ve),ze=De*Re.h,W=Le*Re.v,O=W*ze,V=[];tt(O*256);for(var B=0;B<W;B++){for(var z=[],Y=0;Y<ze;Y++)z.push(new Int32Array(64));V.push(z)}Re.blocksPerLine=Ye,Re.blocksPerColumn=Ze,Re.blocks=V}fe.maxH=_e,fe.maxV=ve,fe.mcusPerLine=De,fe.mcusPerColumn=Le}var _t=null,Ft=null,Pt,Ot,ne=[],he=[],Xt=[],Wt=[],Kt=ct(),de=-1;if(this.comments=[],Kt!=65496)throw new Error("SOI not found");for(Kt=ct();Kt!=65497;){var Ct,te;switch(Kt){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var jt=ut();if(Kt===65534){var Mt=String.fromCharCode.apply(null,jt);this.comments.push(Mt)}Kt===65504&&jt[0]===74&&jt[1]===70&&jt[2]===73&&jt[3]===70&&jt[4]===0&&(_t={version:{major:jt[5],minor:jt[6]},densityUnits:jt[7],xDensity:jt[8]<<8|jt[9],yDensity:jt[10]<<8|jt[11],thumbWidth:jt[12],thumbHeight:jt[13],thumbData:jt.subarray(14,14+3*jt[12]*jt[13])}),Kt===65505&&jt[0]===69&&jt[1]===120&&jt[2]===105&&jt[3]===102&&jt[4]===0&&(this.exifBuffer=jt.subarray(5,jt.length)),Kt===65518&&jt[0]===65&&jt[1]===100&&jt[2]===111&&jt[3]===98&&jt[4]===101&&jt[5]===0&&(Ft={version:jt[6],flags0:jt[7]<<8|jt[8],flags1:jt[9]<<8|jt[10],transformCode:jt[11]});break;case 65499:for(var qt=ct(),oe=qt+lt-2;lt<oe;){var se=wt[lt++];tt(256);var ue=new Int32Array(64);if(se>>4===0)for(te=0;te<64;te++){var ye=P[te];ue[ye]=wt[lt++]}else if(se>>4===1)for(te=0;te<64;te++){var ye=P[te];ue[ye]=ct()}else throw new Error("DQT: invalid table spec");ne[se&15]=ue}break;case 65472:case 65473:case 65474:ct(),Pt={},Pt.extended=Kt===65473,Pt.progressive=Kt===65474,Pt.precision=wt[lt++],Pt.scanLines=ct(),Pt.samplesPerLine=ct(),Pt.components={},Pt.componentsOrder=[];var pe=Pt.scanLines*Pt.samplesPerLine;if(pe>yt){var Ee=Math.ceil((pe-yt)/1e6);throw new Error(`maxResolutionInMP limit exceeded by ${Ee}MP`)}var we=wt[lt++],zt;for(Ct=0;Ct<we;Ct++){zt=wt[lt];var Dt=wt[lt+1]>>4,be=wt[lt+1]&15,ae=wt[lt+2];if(Dt<=0||be<=0)throw new Error("Invalid sampling factor, expected values above 0");Pt.componentsOrder.push(zt),Pt.components[zt]={h:Dt,v:be,quantizationIdx:ae},lt+=3}dt(Pt),he.push(Pt);break;case 65476:var ce=ct();for(Ct=2;Ct<ce;){var It=wt[lt++],Qt=new Uint8Array(16),Zt=0;for(te=0;te<16;te++,lt++)Zt+=Qt[te]=wt[lt];tt(16+Zt);var Jt=new Uint8Array(Zt);for(te=0;te<Zt;te++,lt++)Jt[te]=wt[lt];Ct+=17+Zt,(It>>4===0?Wt:Xt)[It&15]=ht(Qt,Jt)}break;case 65501:ct(),Ot=ct();break;case 65500:ct(),ct();break;case 65498:ct();var ge=wt[lt++],me=[],Me;for(Ct=0;Ct<ge;Ct++){Me=Pt.components[wt[lt++]];var Ut=wt[lt++];Me.huffmanTableDC=Wt[Ut>>4],Me.huffmanTableAC=Xt[Ut&15],me.push(Me)}var Yt=wt[lt++],re=wt[lt++],Gt=wt[lt++],xe=Et(wt,lt,Pt,me,Ot,Yt,re,Gt>>4,Gt&15,this.opts);lt+=xe;break;case 65535:wt[lt]!==255&&lt--;break;default:if(wt[lt-3]==255&&wt[lt-2]>=192&&wt[lt-2]<=254){lt-=3;break}else if(Kt===224||Kt==225){if(de!==-1)throw new Error(`first unknown JPEG marker at offset ${de.toString(16)}, second unknown JPEG marker ${Kt.toString(16)} at offset ${(lt-1).toString(16)}`);de=lt-1;const fe=ct();if(wt[lt+fe-2]===255){lt+=fe-2;break}}throw new Error("unknown JPEG marker "+Kt.toString(16))}Kt=ct()}if(he.length!=1)throw new Error("only single frame JPEGs supported");for(var Ct=0;Ct<he.length;Ct++){var Ie=he[Ct].components;for(var te in Ie)Ie[te].quantizationTable=ne[Ie[te].quantizationIdx],delete Ie[te].quantizationIdx}this.width=Pt.samplesPerLine,this.height=Pt.scanLines,this.jfif=_t,this.adobe=Ft,this.components=[];for(var Ct=0;Ct<Pt.componentsOrder.length;Ct++){var Me=Pt.components[Pt.componentsOrder[Ct]];this.components.push({lines:xt(Pt,Me),scaleX:Me.h/Pt.maxH,scaleY:Me.v/Pt.maxV})}},getData:function(wt,yt){var lt=this.width/wt,ct=this.height/yt,ut,dt,_t,Ft,Pt,Ot,ne,he,Xt,Wt,Kt=0,de,Ct,te,jt,Mt,qt,oe,se,ue,ye,pe,Ee=wt*yt*this.components.length;tt(Ee);var we=new Uint8Array(Ee);switch(this.components.length){case 1:for(ut=this.components[0],Wt=0;Wt<yt;Wt++)for(Pt=ut.lines[0|Wt*ut.scaleY*ct],Xt=0;Xt<wt;Xt++)de=Pt[0|Xt*ut.scaleX*lt],we[Kt++]=de;break;case 2:for(ut=this.components[0],dt=this.components[1],Wt=0;Wt<yt;Wt++)for(Pt=ut.lines[0|Wt*ut.scaleY*ct],Ot=dt.lines[0|Wt*dt.scaleY*ct],Xt=0;Xt<wt;Xt++)de=Pt[0|Xt*ut.scaleX*lt],we[Kt++]=de,de=Ot[0|Xt*dt.scaleX*lt],we[Kt++]=de;break;case 3:for(pe=!0,this.adobe&&this.adobe.transformCode?pe=!0:typeof this.opts.colorTransform<"u"&&(pe=!!this.opts.colorTransform),ut=this.components[0],dt=this.components[1],_t=this.components[2],Wt=0;Wt<yt;Wt++)for(Pt=ut.lines[0|Wt*ut.scaleY*ct],Ot=dt.lines[0|Wt*dt.scaleY*ct],ne=_t.lines[0|Wt*_t.scaleY*ct],Xt=0;Xt<wt;Xt++)pe?(de=Pt[0|Xt*ut.scaleX*lt],Ct=Ot[0|Xt*dt.scaleX*lt],te=ne[0|Xt*_t.scaleX*lt],se=gt(de+1.402*(te-128)),ue=gt(de-.3441363*(Ct-128)-.71413636*(te-128)),ye=gt(de+1.772*(Ct-128))):(se=Pt[0|Xt*ut.scaleX*lt],ue=Ot[0|Xt*dt.scaleX*lt],ye=ne[0|Xt*_t.scaleX*lt]),we[Kt++]=se,we[Kt++]=ue,we[Kt++]=ye;break;case 4:if(!this.adobe)throw new Error("Unsupported color mode (4 components)");for(pe=!1,this.adobe&&this.adobe.transformCode?pe=!0:typeof this.opts.colorTransform<"u"&&(pe=!!this.opts.colorTransform),ut=this.components[0],dt=this.components[1],_t=this.components[2],Ft=this.components[3],Wt=0;Wt<yt;Wt++)for(Pt=ut.lines[0|Wt*ut.scaleY*ct],Ot=dt.lines[0|Wt*dt.scaleY*ct],ne=_t.lines[0|Wt*_t.scaleY*ct],he=Ft.lines[0|Wt*Ft.scaleY*ct],Xt=0;Xt<wt;Xt++)pe?(de=Pt[0|Xt*ut.scaleX*lt],Ct=Ot[0|Xt*dt.scaleX*lt],te=ne[0|Xt*_t.scaleX*lt],jt=he[0|Xt*Ft.scaleX*lt],Mt=255-gt(de+1.402*(te-128)),qt=255-gt(de-.3441363*(Ct-128)-.71413636*(te-128)),oe=255-gt(de+1.772*(Ct-128))):(Mt=Pt[0|Xt*ut.scaleX*lt],qt=Ot[0|Xt*dt.scaleX*lt],oe=ne[0|Xt*_t.scaleX*lt],jt=he[0|Xt*Ft.scaleX*lt]),we[Kt++]=255-Mt,we[Kt++]=255-qt,we[Kt++]=255-oe,we[Kt++]=255-jt;break;default:throw new Error("Unsupported color mode")}return we},copyToImageData:function(wt,yt){var lt=wt.width,ct=wt.height,ut=wt.data,dt=this.getData(lt,ct),_t=0,Ft=0,Pt,Ot,ne,he,Xt,Wt,Kt,de,Ct;switch(this.components.length){case 1:for(Ot=0;Ot<ct;Ot++)for(Pt=0;Pt<lt;Pt++)ne=dt[_t++],ut[Ft++]=ne,ut[Ft++]=ne,ut[Ft++]=ne,yt&&(ut[Ft++]=255);break;case 3:for(Ot=0;Ot<ct;Ot++)for(Pt=0;Pt<lt;Pt++)Kt=dt[_t++],de=dt[_t++],Ct=dt[_t++],ut[Ft++]=Kt,ut[Ft++]=de,ut[Ft++]=Ct,yt&&(ut[Ft++]=255);break;case 4:for(Ot=0;Ot<ct;Ot++)for(Pt=0;Pt<lt;Pt++)Xt=dt[_t++],Wt=dt[_t++],ne=dt[_t++],he=dt[_t++],Kt=255-gt(Xt*(1-he/255)+he),de=255-gt(Wt*(1-he/255)+he),Ct=255-gt(ne*(1-he/255)+he),ut[Ft++]=Kt,ut[Ft++]=de,ut[Ft++]=Ct,yt&&(ut[Ft++]=255);break;default:throw new Error("Unsupported color mode")}}};var bt=0,rt=0;function tt(at=0){var wt=bt+at;if(wt>rt){var yt=Math.ceil((wt-rt)/1024/1024);throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${yt}MB`)}bt=wt}return Q.resetMaxMemoryUsage=function(at){bt=0,rt=at},Q.getBytesAllocated=function(){return bt},Q.requestMemoryAllocation=tt,Q})();_.exports=A;function A(C,P={}){var D={colorTransform:void 0,useTArray:!1,formatAsRGBA:!0,tolerantDecoding:!0,maxResolutionInMP:100,maxMemoryUsageInMB:512},U={...D,...P},G=new Uint8Array(C),X=new E;X.opts=U,E.resetMaxMemoryUsage(U.maxMemoryUsageInMB*1024*1024),X.parse(G);var q=U.formatAsRGBA?4:3,Z=X.width*X.height*q;try{E.requestMemoryAllocation(Z);var K={width:X.width,height:X.height,exifBuffer:X.exifBuffer,data:U.useTArray?new Uint8Array(Z):Buffer.alloc(Z)};X.comments.length>0&&(K.comments=X.comments)}catch(J){throw J instanceof RangeError?new Error("Could not allocate enough memory for the image. Required: "+Z):J instanceof ReferenceError&&J.message==="Buffer is not defined"?new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true"):J}return X.copyToImageData(K,U.formatAsRGBA),K}})(decoder)),decoder.exports}var jpegJs,hasRequiredJpegJs;function requireJpegJs(){if(hasRequiredJpegJs)return jpegJs;hasRequiredJpegJs=1;var _=requireEncoder(),E=requireDecoder();return jpegJs={encode:_,decode:E},jpegJs}var jpegJsExports=requireJpegJs();function zero$1(_){let E=_.length;for(;--E>=0;)_[E]=0}const MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,DIST_CODE_LEN=512,static_ltree=new Array((L_CODES$1+2)*2);zero$1(static_ltree);const static_dtree=new Array(D_CODES$1*2);zero$1(static_dtree);const _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);const _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);const base_length=new Array(LENGTH_CODES$1);zero$1(base_length);const base_dist=new Array(D_CODES$1);zero$1(base_dist);const adler32=(_,E,A,C)=>{let P=_&65535|0,D=_>>>16&65535|0,U=0;for(;A!==0;){U=A>2e3?2e3:A,A-=U;do P=P+E[C++]|0,D=D+P|0;while(--U);P%=65521,D%=65521}return P|D<<16|0};var adler32_1=adler32;const makeTable=()=>{let _,E=[];for(var A=0;A<256;A++){_=A;for(var C=0;C<8;C++)_=_&1?3988292384^_>>>1:_>>>1;E[A]=_}return E},crcTable$1=new Uint32Array(makeTable()),crc32=(_,E,A,C)=>{const P=crcTable$1,D=C+A;_^=-1;for(let U=C;U<D;U++)_=_>>>8^P[(_^E[U])&255];return _^-1};var crc32_1=crc32,messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_DEFLATED:8};const _has=(_,E)=>Object.prototype.hasOwnProperty.call(_,E);var assign=function(_){const E=Array.prototype.slice.call(arguments,1);for(;E.length;){const A=E.shift();if(A){if(typeof A!="object")throw new TypeError(A+"must be non-object");for(const C in A)_has(A,C)&&(_[C]=A[C])}}return _},flattenChunks=_=>{let E=0;for(let C=0,P=_.length;C<P;C++)E+=_[C].length;const A=new Uint8Array(E);for(let C=0,P=0,D=_.length;C<D;C++){let U=_[C];A.set(U,P),P+=U.length}return A},common={assign,flattenChunks};let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let _=0;_<256;_++)_utf8len[_]=_>=252?6:_>=248?5:_>=240?4:_>=224?3:_>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=_=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(_);let E,A,C,P,D,U=_.length,G=0;for(P=0;P<U;P++)A=_.charCodeAt(P),(A&64512)===55296&&P+1<U&&(C=_.charCodeAt(P+1),(C&64512)===56320&&(A=65536+(A-55296<<10)+(C-56320),P++)),G+=A<128?1:A<2048?2:A<65536?3:4;for(E=new Uint8Array(G),D=0,P=0;D<G;P++)A=_.charCodeAt(P),(A&64512)===55296&&P+1<U&&(C=_.charCodeAt(P+1),(C&64512)===56320&&(A=65536+(A-55296<<10)+(C-56320),P++)),A<128?E[D++]=A:A<2048?(E[D++]=192|A>>>6,E[D++]=128|A&63):A<65536?(E[D++]=224|A>>>12,E[D++]=128|A>>>6&63,E[D++]=128|A&63):(E[D++]=240|A>>>18,E[D++]=128|A>>>12&63,E[D++]=128|A>>>6&63,E[D++]=128|A&63);return E};const buf2binstring=(_,E)=>{if(E<65534&&_.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,_.length===E?_:_.subarray(0,E));let A="";for(let C=0;C<E;C++)A+=String.fromCharCode(_[C]);return A};var buf2string=(_,E)=>{const A=E||_.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(_.subarray(0,E));let C,P;const D=new Array(A*2);for(P=0,C=0;C<A;){let U=_[C++];if(U<128){D[P++]=U;continue}let G=_utf8len[U];if(G>4){D[P++]=65533,C+=G-1;continue}for(U&=G===2?31:G===3?15:7;G>1&&C<A;)U=U<<6|_[C++]&63,G--;if(G>1){D[P++]=65533;continue}U<65536?D[P++]=U:(U-=65536,D[P++]=55296|U>>10&1023,D[P++]=56320|U&1023)}return buf2binstring(D,P)},utf8border=(_,E)=>{E=E||_.length,E>_.length&&(E=_.length);let A=E-1;for(;A>=0&&(_[A]&192)===128;)A--;return A<0||A===0?E:A+_utf8len[_[A]]>E?A:E},strings={string2buf,buf2string,utf8border};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream;const BAD$1=16209,TYPE$1=16191;var inffast=function(E,A){let C,P,D,U,G,X,q,Z,K,J,Q,ht,Et,xt,gt,bt,rt,tt,at,wt,yt,lt,ct,ut;const dt=E.state;C=E.next_in,ct=E.input,P=C+(E.avail_in-5),D=E.next_out,ut=E.output,U=D-(A-E.avail_out),G=D+(E.avail_out-257),X=dt.dmax,q=dt.wsize,Z=dt.whave,K=dt.wnext,J=dt.window,Q=dt.hold,ht=dt.bits,Et=dt.lencode,xt=dt.distcode,gt=(1<<dt.lenbits)-1,bt=(1<<dt.distbits)-1;t:do{ht<15&&(Q+=ct[C++]<<ht,ht+=8,Q+=ct[C++]<<ht,ht+=8),rt=Et[Q&gt];e:for(;;){if(tt=rt>>>24,Q>>>=tt,ht-=tt,tt=rt>>>16&255,tt===0)ut[D++]=rt&65535;else if(tt&16){at=rt&65535,tt&=15,tt&&(ht<tt&&(Q+=ct[C++]<<ht,ht+=8),at+=Q&(1<<tt)-1,Q>>>=tt,ht-=tt),ht<15&&(Q+=ct[C++]<<ht,ht+=8,Q+=ct[C++]<<ht,ht+=8),rt=xt[Q&bt];r:for(;;){if(tt=rt>>>24,Q>>>=tt,ht-=tt,tt=rt>>>16&255,tt&16){if(wt=rt&65535,tt&=15,ht<tt&&(Q+=ct[C++]<<ht,ht+=8,ht<tt&&(Q+=ct[C++]<<ht,ht+=8)),wt+=Q&(1<<tt)-1,wt>X){E.msg="invalid distance too far back",dt.mode=BAD$1;break t}if(Q>>>=tt,ht-=tt,tt=D-U,wt>tt){if(tt=wt-tt,tt>Z&&dt.sane){E.msg="invalid distance too far back",dt.mode=BAD$1;break t}if(yt=0,lt=J,K===0){if(yt+=q-tt,tt<at){at-=tt;do ut[D++]=J[yt++];while(--tt);yt=D-wt,lt=ut}}else if(K<tt){if(yt+=q+K-tt,tt-=K,tt<at){at-=tt;do ut[D++]=J[yt++];while(--tt);if(yt=0,K<at){tt=K,at-=tt;do ut[D++]=J[yt++];while(--tt);yt=D-wt,lt=ut}}}else if(yt+=K-tt,tt<at){at-=tt;do ut[D++]=J[yt++];while(--tt);yt=D-wt,lt=ut}for(;at>2;)ut[D++]=lt[yt++],ut[D++]=lt[yt++],ut[D++]=lt[yt++],at-=3;at&&(ut[D++]=lt[yt++],at>1&&(ut[D++]=lt[yt++]))}else{yt=D-wt;do ut[D++]=ut[yt++],ut[D++]=ut[yt++],ut[D++]=ut[yt++],at-=3;while(at>2);at&&(ut[D++]=ut[yt++],at>1&&(ut[D++]=ut[yt++]))}}else if((tt&64)===0){rt=xt[(rt&65535)+(Q&(1<<tt)-1)];continue r}else{E.msg="invalid distance code",dt.mode=BAD$1;break t}break}}else if((tt&64)===0){rt=Et[(rt&65535)+(Q&(1<<tt)-1)];continue e}else if(tt&32){dt.mode=TYPE$1;break t}else{E.msg="invalid literal/length code",dt.mode=BAD$1;break t}break}}while(C<P&&D<G);at=ht>>3,C-=at,ht-=at<<3,Q&=(1<<ht)-1,E.next_in=C,E.next_out=D,E.avail_in=C<P?5+(P-C):5-(C-P),E.avail_out=D<G?257+(G-D):257-(D-G),dt.hold=Q,dt.bits=ht};const MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inflate_table=(_,E,A,C,P,D,U,G)=>{const X=G.bits;let q=0,Z=0,K=0,J=0,Q=0,ht=0,Et=0,xt=0,gt=0,bt=0,rt,tt,at,wt,yt,lt=null,ct;const ut=new Uint16Array(MAXBITS+1),dt=new Uint16Array(MAXBITS+1);let _t=null,Ft,Pt,Ot;for(q=0;q<=MAXBITS;q++)ut[q]=0;for(Z=0;Z<C;Z++)ut[E[A+Z]]++;for(Q=X,J=MAXBITS;J>=1&&ut[J]===0;J--);if(Q>J&&(Q=J),J===0)return P[D++]=1<<24|64<<16|0,P[D++]=1<<24|64<<16|0,G.bits=1,0;for(K=1;K<J&&ut[K]===0;K++);for(Q<K&&(Q=K),xt=1,q=1;q<=MAXBITS;q++)if(xt<<=1,xt-=ut[q],xt<0)return-1;if(xt>0&&(_===CODES$1||J!==1))return-1;for(dt[1]=0,q=1;q<MAXBITS;q++)dt[q+1]=dt[q]+ut[q];for(Z=0;Z<C;Z++)E[A+Z]!==0&&(U[dt[E[A+Z]]++]=Z);if(_===CODES$1?(lt=_t=U,ct=20):_===LENS$1?(lt=lbase,_t=lext,ct=257):(lt=dbase,_t=dext,ct=0),bt=0,Z=0,q=K,yt=D,ht=Q,Et=0,at=-1,gt=1<<Q,wt=gt-1,_===LENS$1&&gt>ENOUGH_LENS$1||_===DISTS$1&&gt>ENOUGH_DISTS$1)return 1;for(;;){Ft=q-Et,U[Z]+1<ct?(Pt=0,Ot=U[Z]):U[Z]>=ct?(Pt=_t[U[Z]-ct],Ot=lt[U[Z]-ct]):(Pt=96,Ot=0),rt=1<<q-Et,tt=1<<ht,K=tt;do tt-=rt,P[yt+(bt>>Et)+tt]=Ft<<24|Pt<<16|Ot|0;while(tt!==0);for(rt=1<<q-1;bt&rt;)rt>>=1;if(rt!==0?(bt&=rt-1,bt+=rt):bt=0,Z++,--ut[q]===0){if(q===J)break;q=E[A+U[Z]]}if(q>Q&&(bt&wt)!==at){for(Et===0&&(Et=Q),yt+=K,ht=q-Et,xt=1<<ht;ht+Et<J&&(xt-=ut[ht+Et],!(xt<=0));)ht++,xt<<=1;if(gt+=1<<ht,_===LENS$1&&gt>ENOUGH_LENS$1||_===DISTS$1&&gt>ENOUGH_DISTS$1)return 1;at=bt&wt,P[at]=Q<<24|ht<<16|yt-D|0}}return bt!==0&&(P[yt+bt]=q-Et<<24|64<<16|0),G.bits=Q,0};var inftrees=inflate_table;const CODES=0,LENS=1,DISTS=2,{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2,HEAD=16180,FLAGS=16181,TIME=16182,OS=16183,EXLEN=16184,EXTRA=16185,NAME=16186,COMMENT=16187,HCRC=16188,DICTID=16189,DICT=16190,TYPE=16191,TYPEDO=16192,STORED=16193,COPY_=16194,COPY=16195,TABLE=16196,LENLENS=16197,CODELENS=16198,LEN_=16199,LEN=16200,LENEXT=16201,DIST=16202,DISTEXT=16203,MATCH=16204,LIT=16205,CHECK=16206,LENGTH=16207,DONE=16208,BAD=16209,MEM=16210,SYNC=16211,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,zswap32=_=>(_>>>24&255)+(_>>>8&65280)+((_&65280)<<8)+((_&255)<<24);function InflateState(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateStateCheck=_=>{if(!_)return 1;const E=_.state;return!E||E.strm!==_||E.mode<HEAD||E.mode>SYNC?1:0},inflateResetKeep=_=>{if(inflateStateCheck(_))return Z_STREAM_ERROR$1;const E=_.state;return _.total_in=_.total_out=E.total=0,_.msg="",E.wrap&&(_.adler=E.wrap&1),E.mode=HEAD,E.last=0,E.havedict=0,E.flags=-1,E.dmax=32768,E.head=null,E.hold=0,E.bits=0,E.lencode=E.lendyn=new Int32Array(ENOUGH_LENS),E.distcode=E.distdyn=new Int32Array(ENOUGH_DISTS),E.sane=1,E.back=-1,Z_OK$1},inflateReset=_=>{if(inflateStateCheck(_))return Z_STREAM_ERROR$1;const E=_.state;return E.wsize=0,E.whave=0,E.wnext=0,inflateResetKeep(_)},inflateReset2=(_,E)=>{let A;if(inflateStateCheck(_))return Z_STREAM_ERROR$1;const C=_.state;return E<0?(A=0,E=-E):(A=(E>>4)+5,E<48&&(E&=15)),E&&(E<8||E>15)?Z_STREAM_ERROR$1:(C.window!==null&&C.wbits!==E&&(C.window=null),C.wrap=A,C.wbits=E,inflateReset(_))},inflateInit2=(_,E)=>{if(!_)return Z_STREAM_ERROR$1;const A=new InflateState;_.state=A,A.strm=_,A.window=null,A.mode=HEAD;const C=inflateReset2(_,E);return C!==Z_OK$1&&(_.state=null),C},inflateInit=_=>inflateInit2(_,DEF_WBITS);let virgin=!0,lenfix,distfix;const fixedtables=_=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let E=0;for(;E<144;)_.lens[E++]=8;for(;E<256;)_.lens[E++]=9;for(;E<280;)_.lens[E++]=7;for(;E<288;)_.lens[E++]=8;for(inftrees(LENS,_.lens,0,288,lenfix,0,_.work,{bits:9}),E=0;E<32;)_.lens[E++]=5;inftrees(DISTS,_.lens,0,32,distfix,0,_.work,{bits:5}),virgin=!1}_.lencode=lenfix,_.lenbits=9,_.distcode=distfix,_.distbits=5},updatewindow=(_,E,A,C)=>{let P;const D=_.state;return D.window===null&&(D.wsize=1<<D.wbits,D.wnext=0,D.whave=0,D.window=new Uint8Array(D.wsize)),C>=D.wsize?(D.window.set(E.subarray(A-D.wsize,A),0),D.wnext=0,D.whave=D.wsize):(P=D.wsize-D.wnext,P>C&&(P=C),D.window.set(E.subarray(A-C,A-C+P),D.wnext),C-=P,C?(D.window.set(E.subarray(A-C,A),0),D.wnext=C,D.whave=D.wsize):(D.wnext+=P,D.wnext===D.wsize&&(D.wnext=0),D.whave<D.wsize&&(D.whave+=P))),0},inflate$2=(_,E)=>{let A,C,P,D,U,G,X,q,Z,K,J,Q,ht,Et,xt=0,gt,bt,rt,tt,at,wt,yt,lt;const ct=new Uint8Array(4);let ut,dt;const _t=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(_)||!_.output||!_.input&&_.avail_in!==0)return Z_STREAM_ERROR$1;A=_.state,A.mode===TYPE&&(A.mode=TYPEDO),U=_.next_out,P=_.output,X=_.avail_out,D=_.next_in,C=_.input,G=_.avail_in,q=A.hold,Z=A.bits,K=G,J=X,lt=Z_OK$1;t:for(;;)switch(A.mode){case HEAD:if(A.wrap===0){A.mode=TYPEDO;break}for(;Z<16;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(A.wrap&2&&q===35615){A.wbits===0&&(A.wbits=15),A.check=0,ct[0]=q&255,ct[1]=q>>>8&255,A.check=crc32_1(A.check,ct,2,0),q=0,Z=0,A.mode=FLAGS;break}if(A.head&&(A.head.done=!1),!(A.wrap&1)||(((q&255)<<8)+(q>>8))%31){_.msg="incorrect header check",A.mode=BAD;break}if((q&15)!==Z_DEFLATED){_.msg="unknown compression method",A.mode=BAD;break}if(q>>>=4,Z-=4,yt=(q&15)+8,A.wbits===0&&(A.wbits=yt),yt>15||yt>A.wbits){_.msg="invalid window size",A.mode=BAD;break}A.dmax=1<<A.wbits,A.flags=0,_.adler=A.check=1,A.mode=q&512?DICTID:TYPE,q=0,Z=0;break;case FLAGS:for(;Z<16;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(A.flags=q,(A.flags&255)!==Z_DEFLATED){_.msg="unknown compression method",A.mode=BAD;break}if(A.flags&57344){_.msg="unknown header flags set",A.mode=BAD;break}A.head&&(A.head.text=q>>8&1),A.flags&512&&A.wrap&4&&(ct[0]=q&255,ct[1]=q>>>8&255,A.check=crc32_1(A.check,ct,2,0)),q=0,Z=0,A.mode=TIME;case TIME:for(;Z<32;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}A.head&&(A.head.time=q),A.flags&512&&A.wrap&4&&(ct[0]=q&255,ct[1]=q>>>8&255,ct[2]=q>>>16&255,ct[3]=q>>>24&255,A.check=crc32_1(A.check,ct,4,0)),q=0,Z=0,A.mode=OS;case OS:for(;Z<16;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}A.head&&(A.head.xflags=q&255,A.head.os=q>>8),A.flags&512&&A.wrap&4&&(ct[0]=q&255,ct[1]=q>>>8&255,A.check=crc32_1(A.check,ct,2,0)),q=0,Z=0,A.mode=EXLEN;case EXLEN:if(A.flags&1024){for(;Z<16;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}A.length=q,A.head&&(A.head.extra_len=q),A.flags&512&&A.wrap&4&&(ct[0]=q&255,ct[1]=q>>>8&255,A.check=crc32_1(A.check,ct,2,0)),q=0,Z=0}else A.head&&(A.head.extra=null);A.mode=EXTRA;case EXTRA:if(A.flags&1024&&(Q=A.length,Q>G&&(Q=G),Q&&(A.head&&(yt=A.head.extra_len-A.length,A.head.extra||(A.head.extra=new Uint8Array(A.head.extra_len)),A.head.extra.set(C.subarray(D,D+Q),yt)),A.flags&512&&A.wrap&4&&(A.check=crc32_1(A.check,C,Q,D)),G-=Q,D+=Q,A.length-=Q),A.length))break t;A.length=0,A.mode=NAME;case NAME:if(A.flags&2048){if(G===0)break t;Q=0;do yt=C[D+Q++],A.head&&yt&&A.length<65536&&(A.head.name+=String.fromCharCode(yt));while(yt&&Q<G);if(A.flags&512&&A.wrap&4&&(A.check=crc32_1(A.check,C,Q,D)),G-=Q,D+=Q,yt)break t}else A.head&&(A.head.name=null);A.length=0,A.mode=COMMENT;case COMMENT:if(A.flags&4096){if(G===0)break t;Q=0;do yt=C[D+Q++],A.head&&yt&&A.length<65536&&(A.head.comment+=String.fromCharCode(yt));while(yt&&Q<G);if(A.flags&512&&A.wrap&4&&(A.check=crc32_1(A.check,C,Q,D)),G-=Q,D+=Q,yt)break t}else A.head&&(A.head.comment=null);A.mode=HCRC;case HCRC:if(A.flags&512){for(;Z<16;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(A.wrap&4&&q!==(A.check&65535)){_.msg="header crc mismatch",A.mode=BAD;break}q=0,Z=0}A.head&&(A.head.hcrc=A.flags>>9&1,A.head.done=!0),_.adler=A.check=0,A.mode=TYPE;break;case DICTID:for(;Z<32;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}_.adler=A.check=zswap32(q),q=0,Z=0,A.mode=DICT;case DICT:if(A.havedict===0)return _.next_out=U,_.avail_out=X,_.next_in=D,_.avail_in=G,A.hold=q,A.bits=Z,Z_NEED_DICT$1;_.adler=A.check=1,A.mode=TYPE;case TYPE:if(E===Z_BLOCK||E===Z_TREES)break t;case TYPEDO:if(A.last){q>>>=Z&7,Z-=Z&7,A.mode=CHECK;break}for(;Z<3;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}switch(A.last=q&1,q>>>=1,Z-=1,q&3){case 0:A.mode=STORED;break;case 1:if(fixedtables(A),A.mode=LEN_,E===Z_TREES){q>>>=2,Z-=2;break t}break;case 2:A.mode=TABLE;break;case 3:_.msg="invalid block type",A.mode=BAD}q>>>=2,Z-=2;break;case STORED:for(q>>>=Z&7,Z-=Z&7;Z<32;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if((q&65535)!==(q>>>16^65535)){_.msg="invalid stored block lengths",A.mode=BAD;break}if(A.length=q&65535,q=0,Z=0,A.mode=COPY_,E===Z_TREES)break t;case COPY_:A.mode=COPY;case COPY:if(Q=A.length,Q){if(Q>G&&(Q=G),Q>X&&(Q=X),Q===0)break t;P.set(C.subarray(D,D+Q),U),G-=Q,D+=Q,X-=Q,U+=Q,A.length-=Q;break}A.mode=TYPE;break;case TABLE:for(;Z<14;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(A.nlen=(q&31)+257,q>>>=5,Z-=5,A.ndist=(q&31)+1,q>>>=5,Z-=5,A.ncode=(q&15)+4,q>>>=4,Z-=4,A.nlen>286||A.ndist>30){_.msg="too many length or distance symbols",A.mode=BAD;break}A.have=0,A.mode=LENLENS;case LENLENS:for(;A.have<A.ncode;){for(;Z<3;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}A.lens[_t[A.have++]]=q&7,q>>>=3,Z-=3}for(;A.have<19;)A.lens[_t[A.have++]]=0;if(A.lencode=A.lendyn,A.lenbits=7,ut={bits:A.lenbits},lt=inftrees(CODES,A.lens,0,19,A.lencode,0,A.work,ut),A.lenbits=ut.bits,lt){_.msg="invalid code lengths set",A.mode=BAD;break}A.have=0,A.mode=CODELENS;case CODELENS:for(;A.have<A.nlen+A.ndist;){for(;xt=A.lencode[q&(1<<A.lenbits)-1],gt=xt>>>24,bt=xt>>>16&255,rt=xt&65535,!(gt<=Z);){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(rt<16)q>>>=gt,Z-=gt,A.lens[A.have++]=rt;else{if(rt===16){for(dt=gt+2;Z<dt;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(q>>>=gt,Z-=gt,A.have===0){_.msg="invalid bit length repeat",A.mode=BAD;break}yt=A.lens[A.have-1],Q=3+(q&3),q>>>=2,Z-=2}else if(rt===17){for(dt=gt+3;Z<dt;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}q>>>=gt,Z-=gt,yt=0,Q=3+(q&7),q>>>=3,Z-=3}else{for(dt=gt+7;Z<dt;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}q>>>=gt,Z-=gt,yt=0,Q=11+(q&127),q>>>=7,Z-=7}if(A.have+Q>A.nlen+A.ndist){_.msg="invalid bit length repeat",A.mode=BAD;break}for(;Q--;)A.lens[A.have++]=yt}}if(A.mode===BAD)break;if(A.lens[256]===0){_.msg="invalid code -- missing end-of-block",A.mode=BAD;break}if(A.lenbits=9,ut={bits:A.lenbits},lt=inftrees(LENS,A.lens,0,A.nlen,A.lencode,0,A.work,ut),A.lenbits=ut.bits,lt){_.msg="invalid literal/lengths set",A.mode=BAD;break}if(A.distbits=6,A.distcode=A.distdyn,ut={bits:A.distbits},lt=inftrees(DISTS,A.lens,A.nlen,A.ndist,A.distcode,0,A.work,ut),A.distbits=ut.bits,lt){_.msg="invalid distances set",A.mode=BAD;break}if(A.mode=LEN_,E===Z_TREES)break t;case LEN_:A.mode=LEN;case LEN:if(G>=6&&X>=258){_.next_out=U,_.avail_out=X,_.next_in=D,_.avail_in=G,A.hold=q,A.bits=Z,inffast(_,J),U=_.next_out,P=_.output,X=_.avail_out,D=_.next_in,C=_.input,G=_.avail_in,q=A.hold,Z=A.bits,A.mode===TYPE&&(A.back=-1);break}for(A.back=0;xt=A.lencode[q&(1<<A.lenbits)-1],gt=xt>>>24,bt=xt>>>16&255,rt=xt&65535,!(gt<=Z);){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(bt&&(bt&240)===0){for(tt=gt,at=bt,wt=rt;xt=A.lencode[wt+((q&(1<<tt+at)-1)>>tt)],gt=xt>>>24,bt=xt>>>16&255,rt=xt&65535,!(tt+gt<=Z);){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}q>>>=tt,Z-=tt,A.back+=tt}if(q>>>=gt,Z-=gt,A.back+=gt,A.length=rt,bt===0){A.mode=LIT;break}if(bt&32){A.back=-1,A.mode=TYPE;break}if(bt&64){_.msg="invalid literal/length code",A.mode=BAD;break}A.extra=bt&15,A.mode=LENEXT;case LENEXT:if(A.extra){for(dt=A.extra;Z<dt;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}A.length+=q&(1<<A.extra)-1,q>>>=A.extra,Z-=A.extra,A.back+=A.extra}A.was=A.length,A.mode=DIST;case DIST:for(;xt=A.distcode[q&(1<<A.distbits)-1],gt=xt>>>24,bt=xt>>>16&255,rt=xt&65535,!(gt<=Z);){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if((bt&240)===0){for(tt=gt,at=bt,wt=rt;xt=A.distcode[wt+((q&(1<<tt+at)-1)>>tt)],gt=xt>>>24,bt=xt>>>16&255,rt=xt&65535,!(tt+gt<=Z);){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}q>>>=tt,Z-=tt,A.back+=tt}if(q>>>=gt,Z-=gt,A.back+=gt,bt&64){_.msg="invalid distance code",A.mode=BAD;break}A.offset=rt,A.extra=bt&15,A.mode=DISTEXT;case DISTEXT:if(A.extra){for(dt=A.extra;Z<dt;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}A.offset+=q&(1<<A.extra)-1,q>>>=A.extra,Z-=A.extra,A.back+=A.extra}if(A.offset>A.dmax){_.msg="invalid distance too far back",A.mode=BAD;break}A.mode=MATCH;case MATCH:if(X===0)break t;if(Q=J-X,A.offset>Q){if(Q=A.offset-Q,Q>A.whave&&A.sane){_.msg="invalid distance too far back",A.mode=BAD;break}Q>A.wnext?(Q-=A.wnext,ht=A.wsize-Q):ht=A.wnext-Q,Q>A.length&&(Q=A.length),Et=A.window}else Et=P,ht=U-A.offset,Q=A.length;Q>X&&(Q=X),X-=Q,A.length-=Q;do P[U++]=Et[ht++];while(--Q);A.length===0&&(A.mode=LEN);break;case LIT:if(X===0)break t;P[U++]=A.length,X--,A.mode=LEN;break;case CHECK:if(A.wrap){for(;Z<32;){if(G===0)break t;G--,q|=C[D++]<<Z,Z+=8}if(J-=X,_.total_out+=J,A.total+=J,A.wrap&4&&J&&(_.adler=A.check=A.flags?crc32_1(A.check,P,J,U-J):adler32_1(A.check,P,J,U-J)),J=X,A.wrap&4&&(A.flags?q:zswap32(q))!==A.check){_.msg="incorrect data check",A.mode=BAD;break}q=0,Z=0}A.mode=LENGTH;case LENGTH:if(A.wrap&&A.flags){for(;Z<32;){if(G===0)break t;G--,q+=C[D++]<<Z,Z+=8}if(A.wrap&4&&q!==(A.total&4294967295)){_.msg="incorrect length check",A.mode=BAD;break}q=0,Z=0}A.mode=DONE;case DONE:lt=Z_STREAM_END$1;break t;case BAD:lt=Z_DATA_ERROR$1;break t;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return _.next_out=U,_.avail_out=X,_.next_in=D,_.avail_in=G,A.hold=q,A.bits=Z,(A.wsize||J!==_.avail_out&&A.mode<BAD&&(A.mode<CHECK||E!==Z_FINISH$1))&&updatewindow(_,_.output,_.next_out,J-_.avail_out),K-=_.avail_in,J-=_.avail_out,_.total_in+=K,_.total_out+=J,A.total+=J,A.wrap&4&&J&&(_.adler=A.check=A.flags?crc32_1(A.check,P,J,_.next_out-J):adler32_1(A.check,P,J,_.next_out-J)),_.data_type=A.bits+(A.last?64:0)+(A.mode===TYPE?128:0)+(A.mode===LEN_||A.mode===COPY_?256:0),(K===0&&J===0||E===Z_FINISH$1)&&lt===Z_OK$1&&(lt=Z_BUF_ERROR),lt},inflateEnd=_=>{if(inflateStateCheck(_))return Z_STREAM_ERROR$1;let E=_.state;return E.window&&(E.window=null),_.state=null,Z_OK$1},inflateGetHeader=(_,E)=>{if(inflateStateCheck(_))return Z_STREAM_ERROR$1;const A=_.state;return(A.wrap&2)===0?Z_STREAM_ERROR$1:(A.head=E,E.done=!1,Z_OK$1)},inflateSetDictionary=(_,E)=>{const A=E.length;let C,P,D;return inflateStateCheck(_)||(C=_.state,C.wrap!==0&&C.mode!==DICT)?Z_STREAM_ERROR$1:C.mode===DICT&&(P=1,P=adler32_1(P,E,A,0),P!==C.check)?Z_DATA_ERROR$1:(D=updatewindow(_,E,A,A),D?(C.mode=MEM,Z_MEM_ERROR$1):(C.havedict=1,Z_OK$1))};var inflateReset_1=inflateReset,inflateReset2_1=inflateReset2,inflateResetKeep_1=inflateResetKeep,inflateInit_1=inflateInit,inflateInit2_1=inflateInit2,inflate_2$1=inflate$2,inflateEnd_1=inflateEnd,inflateGetHeader_1=inflateGetHeader,inflateSetDictionary_1=inflateSetDictionary,inflateInfo="pako inflate (from Nodeca project)",inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var gzheader=GZheader;const toString=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(_){this.options=common.assign({chunkSize:1024*64,windowBits:15,to:""},_||{});const E=this.options;E.raw&&E.windowBits>=0&&E.windowBits<16&&(E.windowBits=-E.windowBits,E.windowBits===0&&(E.windowBits=-15)),E.windowBits>=0&&E.windowBits<16&&!(_&&_.windowBits)&&(E.windowBits+=32),E.windowBits>15&&E.windowBits<48&&(E.windowBits&15)===0&&(E.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let A=inflate_1$2.inflateInit2(this.strm,E.windowBits);if(A!==Z_OK)throw new Error(messages[A]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),E.dictionary&&(typeof E.dictionary=="string"?E.dictionary=strings.string2buf(E.dictionary):toString.call(E.dictionary)==="[object ArrayBuffer]"&&(E.dictionary=new Uint8Array(E.dictionary)),E.raw&&(A=inflate_1$2.inflateSetDictionary(this.strm,E.dictionary),A!==Z_OK)))throw new Error(messages[A])}Inflate$1.prototype.push=function(_,E){const A=this.strm,C=this.options.chunkSize,P=this.options.dictionary;let D,U,G;if(this.ended)return!1;for(E===~~E?U=E:U=E===!0?Z_FINISH:Z_NO_FLUSH,toString.call(_)==="[object ArrayBuffer]"?A.input=new Uint8Array(_):A.input=_,A.next_in=0,A.avail_in=A.input.length;;){for(A.avail_out===0&&(A.output=new Uint8Array(C),A.next_out=0,A.avail_out=C),D=inflate_1$2.inflate(A,U),D===Z_NEED_DICT&&P&&(D=inflate_1$2.inflateSetDictionary(A,P),D===Z_OK?D=inflate_1$2.inflate(A,U):D===Z_DATA_ERROR&&(D=Z_NEED_DICT));A.avail_in>0&&D===Z_STREAM_END&&A.state.wrap>0&&_[A.next_in]!==0;)inflate_1$2.inflateReset(A),D=inflate_1$2.inflate(A,U);switch(D){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(D),this.ended=!0,!1}if(G=A.avail_out,A.next_out&&(A.avail_out===0||D===Z_STREAM_END))if(this.options.to==="string"){let X=strings.utf8border(A.output,A.next_out),q=A.next_out-X,Z=strings.buf2string(A.output,X);A.next_out=q,A.avail_out=C-q,q&&A.output.set(A.output.subarray(X,X+q),0),this.onData(Z)}else this.onData(A.output.length===A.next_out?A.output:A.output.subarray(0,A.next_out));if(!(D===Z_OK&&G===0)){if(D===Z_STREAM_END)return D=inflate_1$2.inflateEnd(this.strm),this.onEnd(D),this.ended=!0,!0;if(A.avail_in===0)break}}return!0};Inflate$1.prototype.onData=function(_){this.chunks.push(_)};Inflate$1.prototype.onEnd=function(_){_===Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=_,this.msg=this.strm.msg};function inflate$1(_,E){const A=new Inflate$1(E);if(A.push(_),A.err)throw A.msg||messages[A.err];return A.result}var Inflate_1$1=Inflate$1,inflate_2=inflate$1,inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2};const{Inflate,inflate}=inflate_1$1;var Inflate_1=Inflate,inflate_1=inflate;const crcTable=[];for(let _=0;_<256;_++){let E=_;for(let A=0;A<8;A++)E&1?E=3988292384^E>>>1:E=E>>>1;crcTable[_]=E}const initialCrc=4294967295;function updateCrc(_,E,A){let C=_;for(let P=0;P<A;P++)C=crcTable[(C^E[P])&255]^C>>>8;return C}function crc(_,E){return(updateCrc(initialCrc,_,E)^initialCrc)>>>0}function checkCrc(_,E,A){const C=_.readUint32(),P=crc(new Uint8Array(_.buffer,_.byteOffset+_.offset-E-4,E),E);if(P!==C)throw new Error(`CRC mismatch for chunk ${A}. Expected ${C}, found ${P}`)}function unfilterNone(_,E,A){for(let C=0;C<A;C++)E[C]=_[C]}function unfilterSub(_,E,A,C){let P=0;for(;P<C;P++)E[P]=_[P];for(;P<A;P++)E[P]=_[P]+E[P-C]&255}function unfilterUp(_,E,A,C){let P=0;if(A.length===0)for(;P<C;P++)E[P]=_[P];else for(;P<C;P++)E[P]=_[P]+A[P]&255}function unfilterAverage(_,E,A,C,P){let D=0;if(A.length===0){for(;D<P;D++)E[D]=_[D];for(;D<C;D++)E[D]=_[D]+(E[D-P]>>1)&255}else{for(;D<P;D++)E[D]=_[D]+(A[D]>>1)&255;for(;D<C;D++)E[D]=_[D]+(E[D-P]+A[D]>>1)&255}}function unfilterPaeth(_,E,A,C,P){let D=0;if(A.length===0){for(;D<P;D++)E[D]=_[D];for(;D<C;D++)E[D]=_[D]+E[D-P]&255}else{for(;D<P;D++)E[D]=_[D]+A[D]&255;for(;D<C;D++)E[D]=_[D]+paethPredictor(E[D-P],A[D],A[D-P])&255}}function paethPredictor(_,E,A){const C=_+E-A,P=Math.abs(C-_),D=Math.abs(C-E),U=Math.abs(C-A);return P<=D&&P<=U?_:D<=U?E:A}function applyUnfilter(_,E,A,C,P,D){switch(_){case 0:unfilterNone(E,A,P);break;case 1:unfilterSub(E,A,P,D);break;case 2:unfilterUp(E,A,C,P);break;case 3:unfilterAverage(E,A,C,P,D);break;case 4:unfilterPaeth(E,A,C,P,D);break;default:throw new Error(`Unsupported filter: ${_}`)}}const uint16$1=new Uint16Array([255]),uint8$1=new Uint8Array(uint16$1.buffer),osIsLittleEndian$1=uint8$1[0]===255;function decodeInterlaceAdam7(_){const{data:E,width:A,height:C,channels:P,depth:D}=_,U=[{x:0,y:0,xStep:8,yStep:8},{x:4,y:0,xStep:8,yStep:8},{x:0,y:4,xStep:4,yStep:8},{x:2,y:0,xStep:4,yStep:4},{x:0,y:2,xStep:2,yStep:4},{x:1,y:0,xStep:2,yStep:2},{x:0,y:1,xStep:1,yStep:2}],G=Math.ceil(D/8)*P,X=new Uint8Array(C*A*G);let q=0;for(let Z=0;Z<7;Z++){const K=U[Z],J=Math.ceil((A-K.x)/K.xStep),Q=Math.ceil((C-K.y)/K.yStep);if(J<=0||Q<=0)continue;const ht=J*G,Et=new Uint8Array(ht);for(let xt=0;xt<Q;xt++){const gt=E[q++],bt=E.subarray(q,q+ht);q+=ht;const rt=new Uint8Array(ht);applyUnfilter(gt,bt,rt,Et,ht,G),Et.set(rt);for(let tt=0;tt<J;tt++){const at=K.x+tt*K.xStep,wt=K.y+xt*K.yStep;if(!(at>=A||wt>=C))for(let yt=0;yt<G;yt++)X[(wt*A+at)*G+yt]=rt[tt*G+yt]}}}if(D===16){const Z=new Uint16Array(X.buffer);if(osIsLittleEndian$1)for(let K=0;K<Z.length;K++)Z[K]=swap16$1(Z[K]);return Z}else return X}function swap16$1(_){return(_&255)<<8|_>>8&255}const uint16=new Uint16Array([255]),uint8=new Uint8Array(uint16.buffer),osIsLittleEndian=uint8[0]===255,empty=new Uint8Array(0);function decodeInterlaceNull(_){const{data:E,width:A,height:C,channels:P,depth:D}=_,U=Math.ceil(D/8)*P,G=Math.ceil(D/8*P*A),X=new Uint8Array(C*G);let q=empty,Z=0,K,J;for(let Q=0;Q<C;Q++){switch(K=E.subarray(Z+1,Z+1+G),J=X.subarray(Q*G,(Q+1)*G),E[Z]){case 0:unfilterNone(K,J,G);break;case 1:unfilterSub(K,J,G,U);break;case 2:unfilterUp(K,J,q,G);break;case 3:unfilterAverage(K,J,q,G,U);break;case 4:unfilterPaeth(K,J,q,G,U);break;default:throw new Error(`Unsupported filter: ${E[Z]}`)}q=J,Z+=G+1}if(D===16){const Q=new Uint16Array(X.buffer);if(osIsLittleEndian)for(let ht=0;ht<Q.length;ht++)Q[ht]=swap16(Q[ht]);return Q}else return X}function swap16(_){return(_&255)<<8|_>>8&255}const pngSignature=Uint8Array.of(137,80,78,71,13,10,26,10);function checkSignature(_){if(!hasPngSignature(_.readBytes(pngSignature.length)))throw new Error("wrong PNG signature")}function hasPngSignature(_){if(_.length<pngSignature.length)return!1;for(let E=0;E<pngSignature.length;E++)if(_[E]!==pngSignature[E])return!1;return!0}const textChunkName="tEXt",NULL=0,latin1Decoder=new TextDecoder("latin1");function validateKeyword(_){if(validateLatin1(_),_.length===0||_.length>79)throw new Error("keyword length must be between 1 and 79")}const latin1Regex=/^[\u0000-\u00FF]*$/;function validateLatin1(_){if(!latin1Regex.test(_))throw new Error("invalid latin1 text")}function decodetEXt(_,E,A){const C=readKeyword(E);_[C]=readLatin1(E,A-C.length-1)}function readKeyword(_){for(_.mark();_.readByte()!==NULL;);const E=_.offset;_.reset();const A=latin1Decoder.decode(_.readBytes(E-_.offset-1));return _.skip(1),validateKeyword(A),A}function readLatin1(_,E){return latin1Decoder.decode(_.readBytes(E))}const ColorType={UNKNOWN:-1,GREYSCALE:0,TRUECOLOUR:2,INDEXED_COLOUR:3,GREYSCALE_ALPHA:4,TRUECOLOUR_ALPHA:6},CompressionMethod={UNKNOWN:-1,DEFLATE:0},FilterMethod={UNKNOWN:-1,ADAPTIVE:0},InterlaceMethod={UNKNOWN:-1,NO_INTERLACE:0,ADAM7:1},DisposeOpType={NONE:0,BACKGROUND:1,PREVIOUS:2},BlendOpType={SOURCE:0,OVER:1};class PngDecoder extends IOBuffer{_checkCrc;_inflator;_png;_apng;_end;_hasPalette;_palette;_hasTransparency;_transparency;_compressionMethod;_filterMethod;_interlaceMethod;_colorType;_isAnimated;_numberOfFrames;_numberOfPlays;_frames;_writingDataChunks;constructor(E,A={}){super(E);const{checkCrc:C=!1}=A;this._checkCrc=C,this._inflator=new Inflate_1,this._png={width:-1,height:-1,channels:-1,data:new Uint8Array(0),depth:1,text:{}},this._apng={width:-1,height:-1,channels:-1,depth:1,numberOfFrames:1,numberOfPlays:0,text:{},frames:[]},this._end=!1,this._hasPalette=!1,this._palette=[],this._hasTransparency=!1,this._transparency=new Uint16Array(0),this._compressionMethod=CompressionMethod.UNKNOWN,this._filterMethod=FilterMethod.UNKNOWN,this._interlaceMethod=InterlaceMethod.UNKNOWN,this._colorType=ColorType.UNKNOWN,this._isAnimated=!1,this._numberOfFrames=1,this._numberOfPlays=0,this._frames=[],this._writingDataChunks=!1,this.setBigEndian()}decode(){for(checkSignature(this);!this._end;){const E=this.readUint32(),A=this.readChars(4);this.decodeChunk(E,A)}return this.decodeImage(),this._png}decodeApng(){for(checkSignature(this);!this._end;){const E=this.readUint32(),A=this.readChars(4);this.decodeApngChunk(E,A)}return this.decodeApngImage(),this._apng}decodeChunk(E,A){const C=this.offset;switch(A){case"IHDR":this.decodeIHDR();break;case"PLTE":this.decodePLTE(E);break;case"IDAT":this.decodeIDAT(E);break;case"IEND":this._end=!0;break;case"tRNS":this.decodetRNS(E);break;case"iCCP":this.decodeiCCP(E);break;case textChunkName:decodetEXt(this._png.text,this,E);break;case"pHYs":this.decodepHYs();break;default:this.skip(E);break}if(this.offset-C!==E)throw new Error(`Length mismatch while decoding chunk ${A}`);this._checkCrc?checkCrc(this,E+4,A):this.skip(4)}decodeApngChunk(E,A){const C=this.offset;switch(A!=="fdAT"&&A!=="IDAT"&&this._writingDataChunks&&this.pushDataToFrame(),A){case"acTL":this.decodeACTL();break;case"fcTL":this.decodeFCTL();break;case"fdAT":this.decodeFDAT(E);break;default:this.decodeChunk(E,A),this.offset=C+E;break}if(this.offset-C!==E)throw new Error(`Length mismatch while decoding chunk ${A}`);this._checkCrc?checkCrc(this,E+4,A):this.skip(4)}decodeIHDR(){const E=this._png;E.width=this.readUint32(),E.height=this.readUint32(),E.depth=checkBitDepth(this.readUint8());const A=this.readUint8();this._colorType=A;let C;switch(A){case ColorType.GREYSCALE:C=1;break;case ColorType.TRUECOLOUR:C=3;break;case ColorType.INDEXED_COLOUR:C=1;break;case ColorType.GREYSCALE_ALPHA:C=2;break;case ColorType.TRUECOLOUR_ALPHA:C=4;break;case ColorType.UNKNOWN:default:throw new Error(`Unknown color type: ${A}`)}if(this._png.channels=C,this._compressionMethod=this.readUint8(),this._compressionMethod!==CompressionMethod.DEFLATE)throw new Error(`Unsupported compression method: ${this._compressionMethod}`);this._filterMethod=this.readUint8(),this._interlaceMethod=this.readUint8()}decodeACTL(){this._numberOfFrames=this.readUint32(),this._numberOfPlays=this.readUint32(),this._isAnimated=!0}decodeFCTL(){const E={sequenceNumber:this.readUint32(),width:this.readUint32(),height:this.readUint32(),xOffset:this.readUint32(),yOffset:this.readUint32(),delayNumber:this.readUint16(),delayDenominator:this.readUint16(),disposeOp:this.readUint8(),blendOp:this.readUint8(),data:new Uint8Array(0)};this._frames.push(E)}decodePLTE(E){if(E%3!==0)throw new RangeError(`PLTE field length must be a multiple of 3. Got ${E}`);const A=E/3;this._hasPalette=!0;const C=[];this._palette=C;for(let P=0;P<A;P++)C.push([this.readUint8(),this.readUint8(),this.readUint8()])}decodeIDAT(E){this._writingDataChunks=!0;const A=E,C=this.offset+this.byteOffset;if(this._inflator.push(new Uint8Array(this.buffer,C,A)),this._inflator.err)throw new Error(`Error while decompressing the data: ${this._inflator.err}`);this.skip(E)}decodeFDAT(E){this._writingDataChunks=!0;let A=E,C=this.offset+this.byteOffset;if(C+=4,A-=4,this._inflator.push(new Uint8Array(this.buffer,C,A)),this._inflator.err)throw new Error(`Error while decompressing the data: ${this._inflator.err}`);this.skip(E)}decodetRNS(E){switch(this._colorType){case ColorType.GREYSCALE:case ColorType.TRUECOLOUR:{if(E%2!==0)throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${E}`);if(E/2>this._png.width*this._png.height)throw new Error(`tRNS chunk contains more alpha values than there are pixels (${E/2} vs ${this._png.width*this._png.height})`);this._hasTransparency=!0,this._transparency=new Uint16Array(E/2);for(let A=0;A<E/2;A++)this._transparency[A]=this.readUint16();break}case ColorType.INDEXED_COLOUR:{if(E>this._palette.length)throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${E} vs ${this._palette.length})`);let A=0;for(;A<E;A++){const C=this.readByte();this._palette[A].push(C)}for(;A<this._palette.length;A++)this._palette[A].push(255);break}case ColorType.UNKNOWN:case ColorType.GREYSCALE_ALPHA:case ColorType.TRUECOLOUR_ALPHA:default:throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`)}}decodeiCCP(E){const A=readKeyword(this),C=this.readUint8();if(C!==CompressionMethod.DEFLATE)throw new Error(`Unsupported iCCP compression method: ${C}`);const P=this.readBytes(E-A.length-2);this._png.iccEmbeddedProfile={name:A,profile:inflate_1(P)}}decodepHYs(){const E=this.readUint32(),A=this.readUint32(),C=this.readByte();this._png.resolution={x:E,y:A,unit:C}}decodeApngImage(){this._apng.width=this._png.width,this._apng.height=this._png.height,this._apng.channels=this._png.channels,this._apng.depth=this._png.depth,this._apng.numberOfFrames=this._numberOfFrames,this._apng.numberOfPlays=this._numberOfPlays,this._apng.text=this._png.text,this._apng.resolution=this._png.resolution;for(let E=0;E<this._numberOfFrames;E++){const A={sequenceNumber:this._frames[E].sequenceNumber,delayNumber:this._frames[E].delayNumber,delayDenominator:this._frames[E].delayDenominator,data:this._apng.depth===8?new Uint8Array(this._apng.width*this._apng.height*this._apng.channels):new Uint16Array(this._apng.width*this._apng.height*this._apng.channels)},C=this._frames.at(E);if(C){if(C.data=decodeInterlaceNull({data:C.data,width:C.width,height:C.height,channels:this._apng.channels,depth:this._apng.depth}),this._hasPalette&&(this._apng.palette=this._palette),this._hasTransparency&&(this._apng.transparency=this._transparency),E===0||C.xOffset===0&&C.yOffset===0&&C.width===this._png.width&&C.height===this._png.height)A.data=C.data;else{const P=this._apng.frames.at(E-1);this.disposeFrame(C,P,A),this.addFrameDataToCanvas(A,C)}this._apng.frames.push(A)}}return this._apng}disposeFrame(E,A,C){switch(E.disposeOp){case DisposeOpType.NONE:break;case DisposeOpType.BACKGROUND:for(let P=0;P<this._png.height;P++)for(let D=0;D<this._png.width;D++){const U=(P*E.width+D)*this._png.channels;for(let G=0;G<this._png.channels;G++)C.data[U+G]=0}break;case DisposeOpType.PREVIOUS:C.data.set(A.data);break;default:throw new Error("Unknown disposeOp")}}addFrameDataToCanvas(E,A){const C=1<<this._png.depth,P=(D,U)=>{const G=((D+A.yOffset)*this._png.width+A.xOffset+U)*this._png.channels,X=(D*A.width+U)*this._png.channels;return{index:G,frameIndex:X}};switch(A.blendOp){case BlendOpType.SOURCE:for(let D=0;D<A.height;D++)for(let U=0;U<A.width;U++){const{index:G,frameIndex:X}=P(D,U);for(let q=0;q<this._png.channels;q++)E.data[G+q]=A.data[X+q]}break;case BlendOpType.OVER:for(let D=0;D<A.height;D++)for(let U=0;U<A.width;U++){const{index:G,frameIndex:X}=P(D,U);for(let q=0;q<this._png.channels;q++){const Z=A.data[X+this._png.channels-1]/C,K=q%(this._png.channels-1)===0?1:A.data[X+q],J=Math.floor(Z*K+(1-Z)*E.data[G+q]);E.data[G+q]+=J}}break;default:throw new Error("Unknown blendOp")}}decodeImage(){if(this._inflator.err)throw new Error(`Error while decompressing the data: ${this._inflator.err}`);const E=this._isAnimated?(this._frames?.at(0)).data:this._inflator.result;if(this._filterMethod!==FilterMethod.ADAPTIVE)throw new Error(`Filter method ${this._filterMethod} not supported`);if(this._interlaceMethod===InterlaceMethod.NO_INTERLACE)this._png.data=decodeInterlaceNull({data:E,width:this._png.width,height:this._png.height,channels:this._png.channels,depth:this._png.depth});else if(this._interlaceMethod===InterlaceMethod.ADAM7)this._png.data=decodeInterlaceAdam7({data:E,width:this._png.width,height:this._png.height,channels:this._png.channels,depth:this._png.depth});else throw new Error(`Interlace method ${this._interlaceMethod} not supported`);this._hasPalette&&(this._png.palette=this._palette),this._hasTransparency&&(this._png.transparency=this._transparency)}pushDataToFrame(){const E=this._inflator.result,A=this._frames.at(-1);A?A.data=E:this._frames.push({sequenceNumber:0,width:this._png.width,height:this._png.height,xOffset:0,yOffset:0,delayNumber:0,delayDenominator:0,disposeOp:DisposeOpType.NONE,blendOp:BlendOpType.SOURCE,data:E}),this._inflator=new Inflate_1,this._writingDataChunks=!1}}function checkBitDepth(_){if(_!==1&&_!==2&&_!==4&&_!==8&&_!==16)throw new Error(`invalid bit depth: ${_}`);return _}function decodePng$1(_,E){return new PngDecoder(_,E).decode()}function writeCanvas(_,E,A={}){_.colorModel!=="RGBA"&&(_=_.convertColor("RGBA")),_.bitDepth!==8&&_ instanceof Image&&(_=_.convertBitDepth(8));const{resizeCanvas:C=!0,dx:P=0,dy:D=0,dirtyX:U=0,dirtyY:G=0,dirtyWidth:X=_.width,dirtyHeight:q=_.height}=A;C&&(E.width=_.width,E.height=_.height);const Z=E.getContext("2d");assert(Z);const K=_.getRawImage().data;Z.putImageData(new ImageData(new Uint8ClampedArray(K.buffer,K.byteOffset,K.byteLength),_.width,_.height),P,D,U,G,X,q)}Uint8Array.from([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]);const base64codes=Uint8Array.from([65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,51,52,53,54,55,56,57,43,47]),base64codes1=new Uint32Array(4096);for(let _=0;_<64;_++)for(let E=0;E<64;E++){const A=_<<2|(E&48)>>4|(E&15)<<8;base64codes1[A]=base64codes[_]|base64codes[E]<<8}const base64codes2=new Uint32Array(4096);for(let _=0;_<64;_++)for(let E=0;E<64;E++){const A=_<<6|E;base64codes2[A]=base64codes[_]<<16|base64codes[E]<<24}var imageType$1={exports:{}},fileType={exports:{}},hasRequiredFileType;function requireFileType(){return hasRequiredFileType||(hasRequiredFileType=1,(function(module){const toBytes=_=>[..._].map(E=>E.charCodeAt(0)),xpiZipFilename=toBytes("META-INF/mozilla.rsa"),oxmlContentTypes=toBytes("[Content_Types].xml"),oxmlRels=toBytes("_rels/.rels");function readUInt64LE(_,E=0){let A=_[E],C=1,P=0;for(;++P<8;)C*=256,A+=_[E+P]*C;return A}const fileType=_=>{if(!(_ instanceof Uint8Array||_ instanceof ArrayBuffer||Buffer.isBuffer(_)))throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof _}\``);const E=_ instanceof Uint8Array?_:new Uint8Array(_);if(!(E&&E.length>1))return null;const A=(P,D)=>{D=Object.assign({offset:0},D);for(let U=0;U<P.length;U++)if(D.mask){if(P[U]!==(D.mask[U]&E[U+D.offset]))return!1}else if(P[U]!==E[U+D.offset])return!1;return!0},C=(P,D)=>A(toBytes(P),D);if(A([255,216,255]))return{ext:"jpg",mime:"image/jpeg"};if(A([137,80,78,71,13,10,26,10]))return{ext:"png",mime:"image/png"};if(A([71,73,70]))return{ext:"gif",mime:"image/gif"};if(A([87,69,66,80],{offset:8}))return{ext:"webp",mime:"image/webp"};if(A([70,76,73,70]))return{ext:"flif",mime:"image/flif"};if((A([73,73,42,0])||A([77,77,0,42]))&&A([67,82],{offset:8}))return{ext:"cr2",mime:"image/x-canon-cr2"};if(A([73,73,42,0])||A([77,77,0,42]))return{ext:"tif",mime:"image/tiff"};if(A([66,77]))return{ext:"bmp",mime:"image/bmp"};if(A([73,73,188]))return{ext:"jxr",mime:"image/vnd.ms-photo"};if(A([56,66,80,83]))return{ext:"psd",mime:"image/vnd.adobe.photoshop"};if(A([80,75,3,4])){if(A([109,105,109,101,116,121,112,101,97,112,112,108,105,99,97,116,105,111,110,47,101,112,117,98,43,122,105,112],{offset:30}))return{ext:"epub",mime:"application/epub+zip"};if(A(xpiZipFilename,{offset:30}))return{ext:"xpi",mime:"application/x-xpinstall"};if(C("mimetypeapplication/vnd.oasis.opendocument.text",{offset:30}))return{ext:"odt",mime:"application/vnd.oasis.opendocument.text"};if(C("mimetypeapplication/vnd.oasis.opendocument.spreadsheet",{offset:30}))return{ext:"ods",mime:"application/vnd.oasis.opendocument.spreadsheet"};if(C("mimetypeapplication/vnd.oasis.opendocument.presentation",{offset:30}))return{ext:"odp",mime:"application/vnd.oasis.opendocument.presentation"};const P=(X,q=0)=>X.findIndex((Z,K,J)=>K>=q&&J[K]===80&&J[K+1]===75&&J[K+2]===3&&J[K+3]===4);let D=0,U=!1,G=null;do{const X=D+30;if(U||(U=A(oxmlContentTypes,{offset:X})||A(oxmlRels,{offset:X})),G||(C("word/",{offset:X})?G={ext:"docx",mime:"application/vnd.openxmlformats-officedocument.wordprocessingml.document"}:C("ppt/",{offset:X})?G={ext:"pptx",mime:"application/vnd.openxmlformats-officedocument.presentationml.presentation"}:C("xl/",{offset:X})&&(G={ext:"xlsx",mime:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"})),U&&G)return G;D=P(E,X)}while(D>=0);if(G)return G}if(A([80,75])&&(E[2]===3||E[2]===5||E[2]===7)&&(E[3]===4||E[3]===6||E[3]===8))return{ext:"zip",mime:"application/zip"};if(A([117,115,116,97,114],{offset:257}))return{ext:"tar",mime:"application/x-tar"};if(A([82,97,114,33,26,7])&&(E[6]===0||E[6]===1))return{ext:"rar",mime:"application/x-rar-compressed"};if(A([31,139,8]))return{ext:"gz",mime:"application/gzip"};if(A([66,90,104]))return{ext:"bz2",mime:"application/x-bzip2"};if(A([55,122,188,175,39,28]))return{ext:"7z",mime:"application/x-7z-compressed"};if(A([120,1]))return{ext:"dmg",mime:"application/x-apple-diskimage"};if(A([51,103,112,53])||A([0,0,0])&&A([102,116,121,112],{offset:4})&&(A([109,112,52,49],{offset:8})||A([109,112,52,50],{offset:8})||A([105,115,111,109],{offset:8})||A([105,115,111,50],{offset:8})||A([109,109,112,52],{offset:8})||A([77,52,86],{offset:8})||A([100,97,115,104],{offset:8})))return{ext:"mp4",mime:"video/mp4"};if(A([77,84,104,100]))return{ext:"mid",mime:"audio/midi"};if(A([26,69,223,163])){const P=E.subarray(4,4100),D=P.findIndex((U,G,X)=>X[G]===66&&X[G+1]===130);if(D!==-1){const U=D+3,G=X=>[...X].every((q,Z)=>P[U+Z]===q.charCodeAt(0));if(G("matroska"))return{ext:"mkv",mime:"video/x-matroska"};if(G("webm"))return{ext:"webm",mime:"video/webm"}}}if(A([0,0,0,20,102,116,121,112,113,116,32,32])||A([102,114,101,101],{offset:4})||A([102,116,121,112,113,116,32,32],{offset:4})||A([109,100,97,116],{offset:4})||A([109,111,111,118],{offset:4})||A([119,105,100,101],{offset:4}))return{ext:"mov",mime:"video/quicktime"};if(A([82,73,70,70])){if(A([65,86,73],{offset:8}))return{ext:"avi",mime:"video/vnd.avi"};if(A([87,65,86,69],{offset:8}))return{ext:"wav",mime:"audio/vnd.wave"};if(A([81,76,67,77],{offset:8}))return{ext:"qcp",mime:"audio/qcelp"}}if(A([48,38,178,117,142,102,207,17,166,217])){let P=30;do{const D=readUInt64LE(E,P+16);if(A([145,7,220,183,183,169,207,17,142,230,0,192,12,32,83,101],{offset:P})){if(A([64,158,105,248,77,91,207,17,168,253,0,128,95,92,68,43],{offset:P+24}))return{ext:"wma",mime:"audio/x-ms-wma"};if(A([192,239,25,188,77,91,207,17,168,253,0,128,95,92,68,43],{offset:P+24}))return{ext:"wmv",mime:"video/x-ms-asf"};break}P+=D}while(P+24<=E.length);return{ext:"asf",mime:"application/vnd.ms-asf"}}if(A([0,0,1,186])||A([0,0,1,179]))return{ext:"mpg",mime:"video/mpeg"};if(A([102,116,121,112,51,103],{offset:4}))return{ext:"3gp",mime:"video/3gpp"};for(let P=0;P<2&&P<E.length-16;P++){if(A([73,68,51],{offset:P})||A([255,226],{offset:P,mask:[255,226]}))return{ext:"mp3",mime:"audio/mpeg"};if(A([255,228],{offset:P,mask:[255,228]}))return{ext:"mp2",mime:"audio/mpeg"};if(A([255,248],{offset:P,mask:[255,252]}))return{ext:"mp2",mime:"audio/mpeg"};if(A([255,240],{offset:P,mask:[255,252]}))return{ext:"mp4",mime:"audio/mpeg"}}if(A([102,116,121,112,77,52,65],{offset:4}))return{ext:"m4a",mime:"audio/mp4"};if(A([79,112,117,115,72,101,97,100],{offset:28}))return{ext:"opus",mime:"audio/opus"};if(A([79,103,103,83]))return A([128,116,104,101,111,114,97],{offset:28})?{ext:"ogv",mime:"video/ogg"}:A([1,118,105,100,101,111,0],{offset:28})?{ext:"ogm",mime:"video/ogg"}:A([127,70,76,65,67],{offset:28})?{ext:"oga",mime:"audio/ogg"}:A([83,112,101,101,120,32,32],{offset:28})?{ext:"spx",mime:"audio/ogg"}:A([1,118,111,114,98,105,115],{offset:28})?{ext:"ogg",mime:"audio/ogg"}:{ext:"ogx",mime:"application/ogg"};if(A([102,76,97,67]))return{ext:"flac",mime:"audio/x-flac"};if(A([77,65,67,32]))return{ext:"ape",mime:"audio/ape"};if(A([119,118,112,107]))return{ext:"wv",mime:"audio/wavpack"};if(A([35,33,65,77,82,10]))return{ext:"amr",mime:"audio/amr"};if(A([37,80,68,70]))return{ext:"pdf",mime:"application/pdf"};if(A([77,90]))return{ext:"exe",mime:"application/x-msdownload"};if((E[0]===67||E[0]===70)&&A([87,83],{offset:1}))return{ext:"swf",mime:"application/x-shockwave-flash"};if(A([123,92,114,116,102]))return{ext:"rtf",mime:"application/rtf"};if(A([0,97,115,109]))return{ext:"wasm",mime:"application/wasm"};if(A([119,79,70,70])&&(A([0,1,0,0],{offset:4})||A([79,84,84,79],{offset:4})))return{ext:"woff",mime:"font/woff"};if(A([119,79,70,50])&&(A([0,1,0,0],{offset:4})||A([79,84,84,79],{offset:4})))return{ext:"woff2",mime:"font/woff2"};if(A([76,80],{offset:34})&&(A([0,0,1],{offset:8})||A([1,0,2],{offset:8})||A([2,0,2],{offset:8})))return{ext:"eot",mime:"application/vnd.ms-fontobject"};if(A([0,1,0,0,0]))return{ext:"ttf",mime:"font/ttf"};if(A([79,84,84,79,0]))return{ext:"otf",mime:"font/otf"};if(A([0,0,1,0]))return{ext:"ico",mime:"image/x-icon"};if(A([0,0,2,0]))return{ext:"cur",mime:"image/x-icon"};if(A([70,76,86,1]))return{ext:"flv",mime:"video/x-flv"};if(A([37,33]))return{ext:"ps",mime:"application/postscript"};if(A([253,55,122,88,90,0]))return{ext:"xz",mime:"application/x-xz"};if(A([83,81,76,105]))return{ext:"sqlite",mime:"application/x-sqlite3"};if(A([78,69,83,26]))return{ext:"nes",mime:"application/x-nintendo-nes-rom"};if(A([67,114,50,52]))return{ext:"crx",mime:"application/x-google-chrome-extension"};if(A([77,83,67,70])||A([73,83,99,40]))return{ext:"cab",mime:"application/vnd.ms-cab-compressed"};if(A([33,60,97,114,99,104,62,10,100,101,98,105,97,110,45,98,105,110,97,114,121]))return{ext:"deb",mime:"application/x-deb"};if(A([33,60,97,114,99,104,62]))return{ext:"ar",mime:"application/x-unix-archive"};if(A([237,171,238,219]))return{ext:"rpm",mime:"application/x-rpm"};if(A([31,160])||A([31,157]))return{ext:"Z",mime:"application/x-compress"};if(A([76,90,73,80]))return{ext:"lz",mime:"application/x-lzip"};if(A([208,207,17,224,161,177,26,225]))return{ext:"msi",mime:"application/x-msi"};if(A([6,14,43,52,2,5,1,1,13,1,2,1,1,2]))return{ext:"mxf",mime:"application/mxf"};if(A([71],{offset:4})&&(A([71],{offset:192})||A([71],{offset:196})))return{ext:"mts",mime:"video/mp2t"};if(A([66,76,69,78,68,69,82]))return{ext:"blend",mime:"application/x-blender"};if(A([66,80,71,251]))return{ext:"bpg",mime:"image/bpg"};if(A([0,0,0,12,106,80,32,32,13,10,135,10])){if(A([106,112,50,32],{offset:20}))return{ext:"jp2",mime:"image/jp2"};if(A([106,112,120,32],{offset:20}))return{ext:"jpx",mime:"image/jpx"};if(A([106,112,109,32],{offset:20}))return{ext:"jpm",mime:"image/jpm"};if(A([109,106,112,50],{offset:20}))return{ext:"mj2",mime:"image/mj2"}}if(A([70,79,82,77]))return{ext:"aif",mime:"audio/aiff"};if(C("<?xml "))return{ext:"xml",mime:"application/xml"};if(A([66,79,79,75,77,79,66,73],{offset:60}))return{ext:"mobi",mime:"application/x-mobipocket-ebook"};if(A([102,116,121,112],{offset:4})){if(A([109,105,102,49],{offset:8}))return{ext:"heic",mime:"image/heif"};if(A([109,115,102,49],{offset:8}))return{ext:"heic",mime:"image/heif-sequence"};if(A([104,101,105,99],{offset:8})||A([104,101,105,120],{offset:8}))return{ext:"heic",mime:"image/heic"};if(A([104,101,118,99],{offset:8})||A([104,101,118,120],{offset:8}))return{ext:"heic",mime:"image/heic-sequence"}}return A([171,75,84,88,32,49,49,187,13,10,26,10])?{ext:"ktx",mime:"image/ktx"}:A([68,73,67,77],{offset:128})?{ext:"dcm",mime:"application/dicom"}:A([77,80,43])?{ext:"mpc",mime:"audio/x-musepack"}:A([77,80,67,75])?{ext:"mpc",mime:"audio/x-musepack"}:A([66,69,71,73,78,58])?{ext:"ics",mime:"text/calendar"}:A([103,108,84,70,2,0,0,0])?{ext:"glb",mime:"model/gltf-binary"}:A([212,195,178,161])||A([161,178,195,212])?{ext:"pcap",mime:"application/vnd.tcpdump.pcap"}:null};module.exports=fileType,module.exports.default=fileType,Object.defineProperty(fileType,"minimumBytes",{value:4100}),module.exports.stream=readableStream=>new Promise((resolve,reject)=>{const stream=eval("require")("stream");readableStream.once("readable",()=>{const _=new stream.PassThrough,E=readableStream.read(module.exports.minimumBytes)||readableStream.read();try{_.fileType=fileType(E)}catch(A){reject(A)}readableStream.unshift(E),stream.pipeline?resolve(stream.pipeline(readableStream,_,()=>{})):resolve(readableStream.pipe(_))})})})(fileType)),fileType.exports}var hasRequiredImageType;function requireImageType(){if(hasRequiredImageType)return imageType$1.exports;hasRequiredImageType=1;const _=requireFileType(),E=new Set(["jpg","png","gif","webp","flif","cr2","tif","bmp","jxr","psd","ico","bpg","jp2","jpm","jpx","heic","cur","dcm"]),A=C=>{const P=_(C);return E.has(P&&P.ext)?P:null};return imageType$1.exports=A,imageType$1.exports.default=A,Object.defineProperty(A,"minimumBytes",{value:_.minimumBytes}),imageType$1.exports}var imageTypeExports=requireImageType();const imageType=getDefaultExportFromCjs(imageTypeExports);function decodeBmp(_){const E=decode$2(_);if(E.bitsPerPixel===1)return new Mask(E.width,E.height,{data:E.data}).convertColor("GREY");{let A;switch(E.channels){case 1:A="GREY";break;case 3:A="RGB";break;default:A="RGBA";break}return new Image(E.width,E.height,{colorModel:A,data:E.data})}}const tagsById$2={33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",36864:"ExifVersion",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBiasValue",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37386:"FocalLength",37396:"SubjectArea",37500:"MakerNote",37510:"UserComment",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",40964:"RelatedSoundFile",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",42240:"Gamma"},tagsByName$2={};for(const _ in tagsById$2)tagsByName$2[tagsById$2[_]]=Number(_);const exif=Object.freeze(Object.defineProperty({__proto__:null,tagsById:tagsById$2,tagsByName:tagsByName$2},Symbol.toStringTag,{value:"Module"})),tagsById$1={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},tagsByName$1={};for(const _ in tagsById$1)tagsByName$1[tagsById$1[_]]=Number(_);const gps=Object.freeze(Object.defineProperty({__proto__:null,tagsById:tagsById$1,tagsByName:tagsByName$1},Symbol.toStringTag,{value:"Module"})),tagsById={254:"NewSubfileType",255:"SubfileType",256:"ImageWidth",257:"ImageLength",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",263:"Threshholding",264:"CellWidth",265:"CellLength",266:"FillOrder",270:"ImageDescription",271:"Make",272:"Model",273:"StripOffsets",274:"Orientation",277:"SamplesPerPixel",278:"RowsPerStrip",279:"StripByteCounts",280:"MinSampleValue",281:"MaxSampleValue",282:"XResolution",283:"YResolution",284:"PlanarConfiguration",288:"FreeOffsets",289:"FreeByteCounts",290:"GrayResponseUnit",291:"GrayResponseCurve",296:"ResolutionUnit",305:"Software",306:"DateTime",315:"Artist",316:"HostComputer",320:"ColorMap",338:"ExtraSamples",33432:"Copyright",269:"DocumentName",285:"PageName",286:"XPosition",287:"YPosition",292:"T4Options",293:"T6Options",297:"PageNumber",301:"TransferFunction",317:"Predictor",318:"WhitePoint",319:"PrimaryChromaticities",321:"HalftoneHints",322:"TileWidth",323:"TileLength",324:"TileOffsets",325:"TileByteCounts",326:"BadFaxLines",327:"CleanFaxData",328:"ConsecutiveBadFaxLines",330:"SubIFDs",332:"InkSet",333:"InkNames",334:"NumberOfInks",336:"DotRange",337:"TargetPrinter",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",342:"TransferRange",343:"ClipPath",344:"XClipPathUnits",345:"YClipPathUnits",346:"Indexed",347:"JPEGTables",351:"OPIProxy",400:"GlobalParametersIFD",401:"ProfileType",402:"FaxProfile",403:"CodingMethods",404:"VersionYear",405:"ModeNumber",433:"Decode",434:"DefaultImageColor",512:"JPEGProc",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",515:"JPEGRestartInterval",517:"JPEGLosslessPredictors",518:"JPEGPointTransforms",519:"JPEGQTables",520:"JPEGDCTables",521:"JPEGACTables",529:"YCbCrCoefficients",530:"YCbCrSubSampling",531:"YCbCrPositioning",532:"ReferenceBlackWhite",559:"StripRowCounts",700:"XMP",32781:"ImageID",34732:"ImageLayer",32932:"WangAnnotatio",33445:"MDFileTag",33446:"MDScalePixel",33447:"MDColorTable",33448:"MDLabName",33449:"MDSampleInfo",33450:"MDPrepDate",33451:"MDPrepTime",33452:"MDFileUnits",33550:"ModelPixelScaleTag",33723:"IPTC",33918:"INGRPacketDataTag",33919:"INGRFlagRegisters",33920:"IrasBTransformationMatrix",33922:"ModelTiepointTag",34264:"ModelTransformationTag",34377:"Photoshop",34665:"ExifIFD",34675:"ICCProfile",34735:"GeoKeyDirectoryTag",34736:"GeoDoubleParamsTag",34737:"GeoAsciiParamsTag",34853:"GPSIFD",34908:"HylaFAXFaxRecvParams",34909:"HylaFAXFaxSubAddress",34910:"HylaFAXFaxRecvTime",37724:"ImageSourceData",40965:"InteroperabilityIFD",42112:"GDAL_METADATA",42113:"GDAL_NODATA",50215:"OceScanjobDescription",50216:"OceApplicationSelector",50217:"OceIdentificationNumber",50218:"OceImageLogicCharacteristics",50706:"DNGVersion",50707:"DNGBackwardVersion",50708:"UniqueCameraModel",50709:"LocalizedCameraModel",50710:"CFAPlaneColor",50711:"CFALayout",50712:"LinearizationTable",50713:"BlackLevelRepeatDim",50714:"BlackLevel",50715:"BlackLevelDeltaH",50716:"BlackLevelDeltaV",50717:"WhiteLevel",50718:"DefaultScale",50719:"DefaultCropOrigin",50720:"DefaultCropSize",50721:"ColorMatrix1",50722:"ColorMatrix2",50723:"CameraCalibration1",50724:"CameraCalibration2",50725:"ReductionMatrix1",50726:"ReductionMatrix2",50727:"AnalogBalance",50728:"AsShotNeutral",50729:"AsShotWhiteXY",50730:"BaselineExposure",50731:"BaselineNoise",50732:"BaselineSharpness",50733:"BayerGreenSplit",50734:"LinearResponseLimit",50735:"CameraSerialNumber",50736:"LensInfo",50737:"ChromaBlurRadius",50738:"AntiAliasStrength",50740:"DNGPrivateData",50741:"MakerNoteSafety",50778:"CalibrationIlluminant1",50779:"CalibrationIlluminant2",50780:"BestQualityScale",50784:"AliasLayerMetadata"},tagsByName={};for(const _ in tagsById)tagsByName[tagsById[_]]=Number(_);const standard=Object.freeze(Object.defineProperty({__proto__:null,tagsById,tagsByName},Symbol.toStringTag,{value:"Module"}));function guessStripByteCounts(_){if(_.compression!==1)throw new Error("missing mandatory StripByteCounts field in compressed image");const E=_.rowsPerStrip*_.width*_.samplesPerPixel*(_.bitsPerSample/8);return new Array(_.stripOffsets.length).fill(E)}function applyHorizontalDifferencing8Bit(_,E,A){let C=0;for(;C<_.length;){for(let P=A;P<E*A;P+=A)for(let D=0;D<A;D++)_[C+P+D]=_[C+P+D]+_[C+P-(A-D)]&255;C+=E*A}}function applyHorizontalDifferencing16Bit(_,E,A){let C=0;for(;C<_.length;){for(let P=A;P<E*A;P+=A)for(let D=0;D<A;D++)_[C+P+D]=_[C+P+D]+_[C+P-(A-D)]&65535;C+=E*A}}const tags={standard,exif,gps};class IFD{kind;data;fields;exif;gps;_hasMap;_map;constructor(E){if(!E)throw new Error("missing kind");this.data=new Uint8Array,this.fields=new Map,this.kind=E,this._hasMap=!1,this._map={}}get(E){if(typeof E=="number")return this.fields.get(E);if(typeof E=="string")return this.fields.get(tags[this.kind].tagsByName[E]);throw new Error("expected a number or string")}get map(){if(!this._hasMap){const E=tags[this.kind].tagsById;for(const A of this.fields.keys())E[A]&&(this._map[E[A]]=this.fields.get(A));this._hasMap=!0}return this._map}}const types=new Map([[1,[1,readByte]],[2,[1,readASCII]],[3,[2,readShort]],[4,[4,readLong]],[5,[8,readRational]],[6,[1,readSByte]],[7,[1,readByte]],[8,[2,readSShort]],[9,[4,readSLong]],[10,[8,readSRational]],[11,[4,readFloat]],[12,[8,readDouble]]]);function getByteLength(_,E){const A=types.get(_);if(!A)throw new Error(`type not found: ${_}`);return A[0]*E}function readData(_,E,A){const C=types.get(E);if(!C)throw new Error(`type not found: ${E}`);return C[1](_,A)}function readByte(_,E){if(E===1)return _.readUint8();const A=new Uint8Array(E);for(let C=0;C<E;C++)A[C]=_.readUint8();return A}function readASCII(_,E){const A=[];let C="";for(let P=0;P<E;P++){const D=String.fromCharCode(_.readUint8());D==="\0"?(A.push(C),C=""):C+=D}return A.length===1?A[0]:A}function readShort(_,E){if(E===1)return _.readUint16();const A=new Uint16Array(E);for(let C=0;C<E;C++)A[C]=_.readUint16();return A}function readLong(_,E){if(E===1)return _.readUint32();const A=new Uint32Array(E);for(let C=0;C<E;C++)A[C]=_.readUint32();return A}function readRational(_,E){if(E===1)return _.readUint32()/_.readUint32();const A=new Array(E);for(let C=0;C<E;C++)A[C]=_.readUint32()/_.readUint32();return A}function readSByte(_,E){if(E===1)return _.readInt8();const A=new Int8Array(E);for(let C=0;C<E;C++)A[C]=_.readInt8();return A}function readSShort(_,E){if(E===1)return _.readInt16();const A=new Int16Array(E);for(let C=0;C<E;C++)A[C]=_.readInt16();return A}function readSLong(_,E){if(E===1)return _.readInt32();const A=new Int32Array(E);for(let C=0;C<E;C++)A[C]=_.readInt32();return A}function readSRational(_,E){if(E===1)return _.readInt32()/_.readInt32();const A=new Array(E);for(let C=0;C<E;C++)A[C]=_.readInt32()/_.readInt32();return A}function readFloat(_,E){if(E===1)return _.readFloat32();const A=new Float32Array(E);for(let C=0;C<E;C++)A[C]=_.readFloat32();return A}function readDouble(_,E){if(E===1)return _.readFloat64();const A=new Float64Array(E);for(let C=0;C<E;C++)A[C]=_.readFloat64();return A}const CLEAR_CODE=256,EOI_CODE=257,TABLE_START=258,MIN_BIT_LENGTH=9;let stringTable=[];function initializeStringTable(){if(stringTable.length===0){for(let E=0;E<256;E++)stringTable.push([E]);const _=[];for(let E=256;E<4096;E++)stringTable.push(_)}}const andTable=[511,1023,2047,4095],bitJumps=[0,0,0,0,0,0,0,0,0,511,1023,2047,4095];class LzwDecoder{stripArray;nextData=0;nextBits=0;bytePointer=0;tableLength=TABLE_START;currentBitLength=MIN_BIT_LENGTH;outData;constructor(E){this.stripArray=new Uint8Array(E.buffer,E.byteOffset,E.byteLength),this.outData=new IOBuffer(E.byteLength),this.initializeTable()}decode(){let E=0,A=0;for(;(E=this.getNextCode())!==EOI_CODE;)if(E===CLEAR_CODE){if(this.initializeTable(),E=this.getNextCode(),E===EOI_CODE)break;this.writeString(this.stringFromCode(E)),A=E}else if(this.isInTable(E))this.writeString(this.stringFromCode(E)),this.addStringToTable(this.stringFromCode(A).concat(this.stringFromCode(E)[0])),A=E;else{const P=this.stringFromCode(A).concat(this.stringFromCode(A)[0]);this.writeString(P),this.addStringToTable(P),A=E}const C=this.outData.toArray();return new DataView(C.buffer,C.byteOffset,C.byteLength)}initializeTable(){initializeStringTable(),this.tableLength=TABLE_START,this.currentBitLength=MIN_BIT_LENGTH}writeString(E){this.outData.writeBytes(E)}stringFromCode(E){return stringTable[E]}isInTable(E){return E<this.tableLength}addStringToTable(E){if(stringTable[this.tableLength++]=E,stringTable.length>4096)throw stringTable=[],new Error("LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).");this.tableLength===bitJumps[this.currentBitLength]&&this.currentBitLength++}getNextCode(){this.nextData=this.nextData<<8|this.stripArray[this.bytePointer++]&255,this.nextBits+=8,this.nextBits<this.currentBitLength&&(this.nextData=this.nextData<<8|this.stripArray[this.bytePointer++]&255,this.nextBits+=8);const E=this.nextData>>this.nextBits-this.currentBitLength&andTable[this.currentBitLength-9];return this.nextBits-=this.currentBitLength,this.bytePointer>this.stripArray.length?257:E}}function decompressLzw(_){return new LzwDecoder(_).decode()}const dateTimeRegex=/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;class TiffIfd extends IFD{constructor(){super("standard")}get size(){return this.width*this.height}get width(){return this.imageWidth}get height(){return this.imageLength}get components(){return this.samplesPerPixel}get date(){const E=new Date,A=dateTimeRegex.exec(this.dateTime);if(A===null)throw new Error(`invalid dateTime: ${this.dateTime}`);return E.setFullYear(Number(A[1]),Number(A[2])-1,Number(A[3])),E.setHours(Number(A[4]),Number(A[5]),Number(A[6])),E}get newSubfileType(){return this.get("NewSubfileType")}get imageWidth(){return this.get("ImageWidth")}get imageLength(){return this.get("ImageLength")}get bitsPerSample(){const E=this.get("BitsPerSample");return E&&typeof E!="number"?E[0]:E}get alpha(){const E=this.extraSamples;return E?E[0]!==0:!1}get associatedAlpha(){const E=this.extraSamples;return E?E[0]===1:!1}get extraSamples(){return alwaysArray(this.get("ExtraSamples"))}get compression(){return this.get("Compression")||1}get type(){return this.get("PhotometricInterpretation")}get fillOrder(){return this.get("FillOrder")||1}get documentName(){return this.get("DocumentName")}get imageDescription(){return this.get("ImageDescription")}get stripOffsets(){return alwaysArray(this.get("StripOffsets"))}get orientation(){return this.get("Orientation")}get samplesPerPixel(){return this.get("SamplesPerPixel")||1}get rowsPerStrip(){return this.get("RowsPerStrip")||2**32-1}get stripByteCounts(){return alwaysArray(this.get("StripByteCounts"))}get minSampleValue(){return this.get("MinSampleValue")||0}get maxSampleValue(){return this.get("MaxSampleValue")||2**this.bitsPerSample-1}get xResolution(){return this.get("XResolution")}get yResolution(){return this.get("YResolution")}get planarConfiguration(){return this.get("PlanarConfiguration")||1}get resolutionUnit(){return this.get("ResolutionUnit")||2}get dateTime(){return this.get("DateTime")}get predictor(){return this.get("Predictor")||1}get sampleFormat(){return alwaysArray(this.get("SampleFormat")||1)[0]}get sMinSampleValue(){return this.get("SMinSampleValue")||this.minSampleValue}get sMaxSampleValue(){return this.get("SMaxSampleValue")||this.maxSampleValue}get palette(){const E=2**this.bitsPerSample,A=this.get("ColorMap");if(!A)return;if(A.length!==3*E)throw new Error(`ColorMap size must be ${E}`);const C=[];for(let P=0;P<E;P++)C.push([A[P],A[P+E],A[P+2*E]]);return C}get tileWidth(){return this.get("TileWidth")}get tileHeight(){return this.get("TileLength")}get tileOffsets(){return alwaysArray(this.get("TileOffsets"))}get tileByteCounts(){return alwaysArray(this.get("TileByteCounts"))}get tiled(){return this.tileWidth!==void 0&&this.tileHeight!==void 0&&this.tileOffsets!==void 0&&this.tileByteCounts!==void 0}}function alwaysArray(_){return typeof _=="number"?[_]:_}var u8=Uint8Array,u16=Uint16Array,i32=Int32Array,fleb=new u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),fdeb=new u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),clim=new u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),freb=function(_,E){for(var A=new u16(31),C=0;C<31;++C)A[C]=E+=1<<_[C-1];for(var P=new i32(A[30]),C=1;C<30;++C)for(var D=A[C];D<A[C+1];++D)P[D]=D-A[C]<<5|C;return{b:A,r:P}},_a=freb(fleb,2),fl=_a.b,revfl=_a.r;fl[28]=258,revfl[258]=28;var _b=freb(fdeb,0),fd=_b.b,rev=new u16(32768);for(var i=0;i<32768;++i){var x=(i&43690)>>1|(i&21845)<<1;x=(x&52428)>>2|(x&13107)<<2,x=(x&61680)>>4|(x&3855)<<4,rev[i]=((x&65280)>>8|(x&255)<<8)>>1}var hMap=(function(_,E,A){for(var C=_.length,P=0,D=new u16(E);P<C;++P)_[P]&&++D[_[P]-1];var U=new u16(E);for(P=1;P<E;++P)U[P]=U[P-1]+D[P-1]<<1;var G;if(A){G=new u16(1<<E);var X=15-E;for(P=0;P<C;++P)if(_[P])for(var q=P<<4|_[P],Z=E-_[P],K=U[_[P]-1]++<<Z,J=K|(1<<Z)-1;K<=J;++K)G[rev[K]>>X]=q}else for(G=new u16(C),P=0;P<C;++P)_[P]&&(G[P]=rev[U[_[P]-1]++]>>15-_[P]);return G}),flt=new u8(288);for(var i=0;i<144;++i)flt[i]=8;for(var i=144;i<256;++i)flt[i]=9;for(var i=256;i<280;++i)flt[i]=7;for(var i=280;i<288;++i)flt[i]=8;var fdt=new u8(32);for(var i=0;i<32;++i)fdt[i]=5;var flrm=hMap(flt,9,1),fdrm=hMap(fdt,5,1),max=function(_){for(var E=_[0],A=1;A<_.length;++A)_[A]>E&&(E=_[A]);return E},bits=function(_,E,A){var C=E/8|0;return(_[C]|_[C+1]<<8)>>(E&7)&A},bits16=function(_,E){var A=E/8|0;return(_[A]|_[A+1]<<8|_[A+2]<<16)>>(E&7)},shft=function(_){return(_+7)/8|0},slc=function(_,E,A){return(A==null||A>_.length)&&(A=_.length),new u8(_.subarray(E,A))},ec=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],err=function(_,E,A){var C=new Error(E||ec[_]);if(C.code=_,Error.captureStackTrace&&Error.captureStackTrace(C,err),!A)throw C;return C},inflt=function(_,E,A,C){var P=_.length,D=0;if(!P||E.f&&!E.l)return A||new u8(0);var U=!A,G=U||E.i!=2,X=E.i;U&&(A=new u8(P*3));var q=function(pe){var Ee=A.length;if(pe>Ee){var we=new u8(Math.max(Ee*2,pe));we.set(A),A=we}},Z=E.f||0,K=E.p||0,J=E.b||0,Q=E.l,ht=E.d,Et=E.m,xt=E.n,gt=P*8;do{if(!Q){Z=bits(_,K,1);var bt=bits(_,K+1,3);if(K+=3,bt)if(bt==1)Q=flrm,ht=fdrm,Et=9,xt=5;else if(bt==2){var wt=bits(_,K,31)+257,yt=bits(_,K+10,15)+4,lt=wt+bits(_,K+5,31)+1;K+=14;for(var ct=new u8(lt),ut=new u8(19),dt=0;dt<yt;++dt)ut[clim[dt]]=bits(_,K+dt*3,7);K+=yt*3;for(var _t=max(ut),Ft=(1<<_t)-1,Pt=hMap(ut,_t,1),dt=0;dt<lt;){var Ot=Pt[bits(_,K,Ft)];K+=Ot&15;var rt=Ot>>4;if(rt<16)ct[dt++]=rt;else{var ne=0,he=0;for(rt==16?(he=3+bits(_,K,3),K+=2,ne=ct[dt-1]):rt==17?(he=3+bits(_,K,7),K+=3):rt==18&&(he=11+bits(_,K,127),K+=7);he--;)ct[dt++]=ne}}var Xt=ct.subarray(0,wt),Wt=ct.subarray(wt);Et=max(Xt),xt=max(Wt),Q=hMap(Xt,Et,1),ht=hMap(Wt,xt,1)}else err(1);else{var rt=shft(K)+4,tt=_[rt-4]|_[rt-3]<<8,at=rt+tt;if(at>P){X&&err(0);break}G&&q(J+tt),A.set(_.subarray(rt,at),J),E.b=J+=tt,E.p=K=at*8,E.f=Z;continue}if(K>gt){X&&err(0);break}}G&&q(J+131072);for(var Kt=(1<<Et)-1,de=(1<<xt)-1,Ct=K;;Ct=K){var ne=Q[bits16(_,K)&Kt],te=ne>>4;if(K+=ne&15,K>gt){X&&err(0);break}if(ne||err(2),te<256)A[J++]=te;else if(te==256){Ct=K,Q=null;break}else{var jt=te-254;if(te>264){var dt=te-257,Mt=fleb[dt];jt=bits(_,K,(1<<Mt)-1)+fl[dt],K+=Mt}var qt=ht[bits16(_,K)&de],oe=qt>>4;qt||err(3),K+=qt&15;var Wt=fd[oe];if(oe>3){var Mt=fdeb[oe];Wt+=bits16(_,K)&(1<<Mt)-1,K+=Mt}if(K>gt){X&&err(0);break}G&&q(J+131072);var se=J+jt;if(J<Wt){var ue=D-Wt,ye=Math.min(Wt,se);for(ue+J<0&&err(3);J<ye;++J)A[J]=C[ue+J]}for(;J<se;++J)A[J]=A[J-Wt]}}E.l=Q,E.p=Ct,E.b=J,E.f=Z,Q&&(Z=1,E.m=Et,E.d=ht,E.n=xt)}while(!Z);return J!=A.length&&U?slc(A,0,J):A.subarray(0,J)},et=new u8(0),gzs=function(_){(_[0]!=31||_[1]!=139||_[2]!=8)&&err(6,"invalid gzip data");var E=_[3],A=10;E&4&&(A+=(_[10]|_[11]<<8)+2);for(var C=(E>>3&1)+(E>>4&1);C>0;C-=!_[A++]);return A+(E&2)},gzl=function(_){var E=_.length;return(_[E-4]|_[E-3]<<8|_[E-2]<<16|_[E-1]<<24)>>>0},zls=function(_,E){return((_[0]&15)!=8||_[0]>>4>7||(_[0]<<8|_[1])%31)&&err(6,"invalid zlib data"),(_[1]>>5&1)==1&&err(6,"invalid zlib data: "+(_[1]&32?"need":"unexpected")+" dictionary"),(_[1]>>3&4)+2};function inflateSync(_,E){return inflt(_,{i:2},E,E)}function gunzipSync(_,E){var A=gzs(_);return A+8>_.length&&err(6,"invalid gzip data"),inflt(_.subarray(A,-8),{i:2},new u8(gzl(_)),E)}function unzlibSync(_,E){return inflt(_.subarray(zls(_),-4),{i:2},E,E)}function decompressSync(_,E){return _[0]==31&&_[1]==139&&_[2]==8?gunzipSync(_,E):(_[0]&15)!=8||_[0]>>4>7||(_[0]<<8|_[1])%31?inflateSync(_,E):unzlibSync(_,E)}var td=typeof TextDecoder<"u"&&new TextDecoder,tds=0;try{td.decode(et,{stream:!0}),tds=1}catch(_){}function decompressZlib(_){const E=new Uint8Array(_.buffer,_.byteOffset,_.byteLength),A=decompressSync(E);return new DataView(A.buffer,A.byteOffset,A.byteLength)}const defaultOptions={ignoreImageData:!1};class TIFFDecoder extends IOBuffer{_nextIFD;constructor(E){super(E),this._nextIFD=0}get isMultiPage(){let E=0;for(this.decodeHeader();this._nextIFD;)if(E++,this.decodeIFD({ignoreImageData:!0},!0),E===2)return!0;if(E===1)return!1;throw unsupported("ifdCount",E)}get pageCount(){let E=0;for(this.decodeHeader();this._nextIFD;)E++,this.decodeIFD({ignoreImageData:!0},!0);if(E>0)return E;throw unsupported("ifdCount",E)}decode(E={}){const{pages:A}=E;checkPages(A);const C=A?Math.max(...A):1/0;E={...defaultOptions,...E};const P=[];this.decodeHeader();let D=0;for(;this._nextIFD;){if(A){if(A.includes(D)?P.push(this.decodeIFD(E,!0)):this.decodeIFD({ignoreImageData:!0},!0),D===C)break}else P.push(this.decodeIFD(E,!0));D++}if(D<C&&C!==1/0)throw new RangeError(`Index ${C} is out of bounds. The stack only contains ${D} images.`);return P}decodeHeader(){const E=this.readUint16();if(E===18761)this.setLittleEndian();else if(E===19789)this.setBigEndian();else throw new Error(`invalid byte order: 0x${E.toString(16)}`);if(this.readUint16()!==42)throw new Error("not a TIFF file");this._nextIFD=this.readUint32()}decodeIFD(E,A){this.seek(this._nextIFD);let C;if(A)C=new TiffIfd;else{if(!E.kind)throw new Error("kind is missing");C=new IFD(E.kind)}const P=this.readUint16();for(let D=0;D<P;D++)this.decodeIFDEntry(C);if(!E.ignoreImageData){if(!(C instanceof TiffIfd))throw new Error("must be a tiff ifd");this.decodeImageData(C)}return this._nextIFD=this.readUint32(),C}decodeIFDEntry(E){const A=this.offset,C=this.readUint16(),P=this.readUint16(),D=this.readUint32();if(P<1||P>12){this.skip(4);return}getByteLength(P,D)>4&&this.seek(this.readUint32());const G=readData(this,P,D);if(E.fields.set(C,G),C===34665||C===34853){const X=this.offset;let q="exif";C===34665?q="exif":C===34853&&(q="gps"),this._nextIFD=G,E[q]=this.decodeIFD({kind:q,ignoreImageData:!0},!1),this.offset=X}this.seek(A),this.skip(12)}decodeImageData(E){const A=E.orientation;if(A&&A!==1)throw unsupported("orientation",A);switch(E.type){case 0:case 1:case 2:case 3:E.tiled?this.readTileData(E):this.readStripData(E);break;default:throw unsupported("image type",E.type)}if(this.applyPredictor(E),this.convertAlpha(E),E.bitsPerSample===1&&this.split1BitData(E),E.type===0){const P=2**E.bitsPerSample-1;for(let D=0;D<E.data.length;D++)E.data[D]=P-E.data[D]}}split1BitData(E){const{imageWidth:A,imageLength:C,samplesPerPixel:P}=E,D=new Uint8Array(C*A*P),U=Math.ceil(A*P/8);let G=0;for(let X=0;X<C;X++){const q=X*U;for(let Z=0;Z<A*P;Z++){const K=q+Math.floor(Z/8),J=7-Z%8,Q=E.data[K]>>J&1;D[G++]=Q}}E.data=D}static uncompress(E,A=1){switch(A){case 1:return E;case 5:return decompressLzw(E);case 8:case 32946:return decompressZlib(E);case 2:throw unsupported("Compression","CCITT Group 3");case 32773:throw unsupported("Compression","PackBits");default:throw unsupported("Compression",A)}}createSampleReader(E,A,C){if(A===8||A===1)return(P,D)=>P.getUint8(D);if(A===16)return(P,D)=>P.getUint16(2*D,C);if(A===32&&E===3)return(P,D)=>P.getFloat32(4*D,C);if(A===64&&E===3)return(P,D)=>P.getFloat64(8*D,C);throw unsupported("bitDepth",A)}readStripData(E){const A=E.width,C=E.height,P=E.bitsPerSample!==1?A*E.samplesPerPixel*C:Math.ceil(A*E.samplesPerPixel/8)*C,D=E.stripOffsets,U=E.stripByteCounts||guessStripByteCounts(E),G=this.isLittleEndian(),X=E.bitsPerSample!==1?A*E.samplesPerPixel*E.rowsPerStrip:Math.ceil(A*E.samplesPerPixel/8)*E.rowsPerStrip,q=this.createSampleReader(E.sampleFormat,E.bitsPerSample,G),Z=getDataArray(P,E.bitsPerSample,E.sampleFormat);let K=0;for(let J=0;J<D.length;J++){const Q=new DataView(this.buffer,this.byteOffset+D[J],U[J]),ht=TIFFDecoder.uncompress(Q,E.compression),Et=Math.min(X,P-K);for(let xt=0;xt<Et;++xt){const gt=q(ht,xt);Z[K+xt]=gt}K+=Et}E.data=Z}readTileData(E){if(!E.tileWidth||!E.tileHeight)return;const A=E.width,C=E.height,P=E.bitsPerSample!==1?A*C*E.samplesPerPixel:Math.ceil(A*E.samplesPerPixel/8)*C,D=E.tileWidth,U=E.tileHeight,G=Math.ceil(A/D),X=Math.ceil(C/U),q=E.tileOffsets,Z=E.tileByteCounts,K=this.isLittleEndian(),J=this.createSampleReader(E.sampleFormat,E.bitsPerSample,K),Q=getDataArray(P,E.bitsPerSample,E.sampleFormat);for(let ht=0;ht<G;++ht)for(let Et=0;Et<X;++Et){const xt=Et*G+ht,gt=new DataView(this.buffer,this.byteOffset+q[xt],Z[xt]),bt=TIFFDecoder.uncompress(gt,E.compression);if(E.bitsPerSample===1){const rt=Math.ceil(A/8),tt=Math.ceil(D/8);for(let at=0;at<U&&Et*U+at<C;at++){const wt=Et*U+at,yt=at*tt,lt=wt*rt+Math.floor(ht*D/8),ct=Math.min(tt,rt-Math.floor(ht*D/8));for(let ut=0;ut<ct;ut++)Q[lt+ut]=J(bt,yt+ut)}}else for(let rt=0;rt<U;rt++)for(let tt=0;tt<D;tt++){const at=ht*D+tt,wt=Et*U+rt;if(at>=A||wt>=C)continue;const yt=rt*D+tt,lt=J(bt,yt),ct=(wt*A+at)*E.samplesPerPixel;Q[ct]=lt}}E.data=Q}applyPredictor(E){const A=E.bitsPerSample;switch(E.predictor){case 1:break;case 2:{if(A===8)applyHorizontalDifferencing8Bit(E.data,E.width,E.components);else if(A===16)applyHorizontalDifferencing16Bit(E.data,E.width,E.components);else throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${A}`);break}default:throw new Error(`invalid predictor: ${E.predictor}`)}}convertAlpha(E){if(E.alpha&&E.associatedAlpha){const{data:A,components:C,maxSampleValue:P}=E;for(let D=0;D<A.length;D+=C){const U=A[D+C-1];for(let G=0;G<C-1;G++)A[D+G]=Math.round(A[D+G]*P/U)}}}}function getDataArray(_,E,A){if(E===8||E===1)return new Uint8Array(_);if(E===16)return new Uint16Array(_);if(E===32&&A===3)return new Float32Array(_);if(E===64&&A===3)return new Float64Array(_);throw unsupported("bit depth / sample format",`${E} / ${A}`)}function unsupported(_,E){return new Error(`Unsupported ${_}: ${E}`)}function checkPages(_){if(_){for(const E of _)if(E<0||!Number.isInteger(E))throw new RangeError(`Index ${E} is invalid. Must be a positive integer.`)}}function decodeTIFF(_,E){return new TIFFDecoder(_).decode(E)}function decode$1(_){const E=new IOBuffer(_),A={};if(E.setBigEndian(),E.readUint16()!==65496)throw new Error("SOI marker not found. Not a valid JPEG file");if(E.readUint16()===65505){E.skip(2);const D=E.readBytes(6);D[0]===69&&D[1]===120&&D[2]===105&&D[3]===102&&D[4]===0&&D[5]===0&&(A.exif=decodeTIFF(new Uint8Array(E.buffer,E.byteOffset+12,E.byteLength-12),{pages:[0],ignoreImageData:!0}))}return A}function getMetadata(_){return{tiff:{fields:_.fields,tags:_.map},exif:_.exif}}function decodeJpeg(_){const E=jpegJsExports.decode(_,{useTArray:!0,maxMemoryUsageInMB:Number.POSITIVE_INFINITY,maxResolutionInMP:Number.POSITIVE_INFINITY}),A=decode$1(_),C=A.exif?.[0]?getMetadata(A.exif[0]):void 0;return new Image(E.width,E.height,{data:E.data,colorModel:"RGBA",meta:C})}function decodePng(_){const E=decodePng$1(_);let A;const C=E.depth;if(E.palette)return loadPalettePng(E);if(C===1)return new Image(E.width,E.height,{data:decodeBinary(E),colorModel:"GREY"});switch(E.channels){case 1:A="GREY";break;case 2:A="GREYA";break;case 3:A="RGB";break;case 4:A="RGBA";break;default:throw new RangeError(`invalid number of channels: ${E.channels}`)}let P;return E.resolution&&(P=E.resolution.unit===1?{x:E.resolution.x,y:E.resolution.y,unit:"meter"}:{x:E.resolution.x,y:E.resolution.y,unit:"unknown"}),new Image(E.width,E.height,{colorModel:A,bitDepth:C,data:E.data,resolution:P})}function loadPalettePng(_){assert(_.palette);const E=_.width*_.height,A=new Uint8Array(E*_.palette[0].length),C=8/_.depth,P=_.depth<8?C:1,D=Number.parseInt("1".repeat(_.depth),2);let U=0;for(let G=0;G<E;G++){const X=Math.floor(G/P);let q=_.data[X];_.depth<8&&(q=q>>>_.depth*(C-1-G%C)&D);const Z=_.palette[q];for(const K of Z)A[U++]=K}return new Image(_.width,_.height,{data:A,colorModel:_.palette[0].length===4?"RGBA":"RGB"})}function decodeBinary(_){const E=_.width*_.height,A=new Uint8Array(E),C=_.data,P=_.width%8,D=Math.ceil(_.width/8);let U=0;for(let G=0;G<C.length&&U<E;G++){const X=C[G],q=G%D===0?8-P:0;for(let Z=7;Z>=q&&U<E;Z--){const K=X>>Z&1;A[U++]=K*255}}return A}function decodeTiff(_){const E=decodeTIFF(_,{pages:[0]});return getImageFromIFD(E[0])}function getImageFromIFD(_){if(_.data instanceof Float32Array||_.data instanceof Float64Array)throw new Error("Float TIFF data is not supported.");const E=getTiffResolution(_);if(_.type===3){const A=_.samplesPerPixel===2,C=A?4:3,P=new Uint16Array(C*_.width*_.height),D=_.palette;let U=0;if(A)for(let G=0;G<_.data.length;G+=_.samplesPerPixel){const X=D[_.data[G]];P[U++]=X[0],P[U++]=X[1],P[U++]=X[2],P[U++]=Math.round(_.data[G+1]/2**_.bitsPerSample*65535)}else for(let G=0;G<_.data.length;G+=_.samplesPerPixel){const X=D[_.data[G]];P[U++]=X[0],P[U++]=X[1],P[U++]=X[2]}return new Image(_.width,_.height,{data:P,colorModel:A?"RGBA":"RGB",bitDepth:16,meta:getMetadata(_),resolution:E})}else return _.type===1||_.type===0?_.bitsPerSample!==1?new Image(_.width,_.height,{data:_.data,bitDepth:_.bitsPerSample,colorModel:_.alpha?"GREYA":"GREY",meta:getMetadata(_),resolution:E}):new Image(_.width,_.height,{data:_.data.map(A=>A*255),bitDepth:8,colorModel:"GREY",meta:getMetadata(_),resolution:E}):new Image(_.width,_.height,{data:_.data,bitDepth:_.bitsPerSample,colorModel:_.alpha?"RGBA":"RGB",meta:getMetadata(_),resolution:E})}function getTiffResolution(_){if(!(!_.xResolution||!_.yResolution))switch(_.resolutionUnit){case 1:return{x:_.xResolution,y:_.yResolution,unit:"unknown"};case 3:return{x:_.xResolution,y:_.yResolution,unit:"centimeter"};default:return{x:_.xResolution,y:_.yResolution,unit:"inch"}}}function decode(_){const E=new Uint8Array(_.buffer,_.byteOffset,_.byteLength),A=imageType(E);return M$2(A).with({mime:"image/png"},()=>decodePng(E)).with({mime:"image/jpeg"},()=>decodeJpeg(E)).with({mime:"image/tiff"},()=>decodeTiff(E)).with({mime:"image/bmp"},()=>decodeBmp(E)).otherwise(()=>{throw new RangeError(`invalid data format: ${A?.mime}`)})}function commonjsRequire(_){throw new Error('Could not dynamically require "'+_+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var priorityQueue={exports:{}},hasRequiredPriorityQueue;function requirePriorityQueue(){return hasRequiredPriorityQueue||(hasRequiredPriorityQueue=1,(function(_,E){(function(A){_.exports=A()})(function(){return(function A(C,P,D){function U(q,Z){if(!P[q]){if(!C[q]){var K=typeof commonjsRequire=="function"&&commonjsRequire;if(!Z&&K)return K(q,!0);if(G)return G(q,!0);var J=new Error("Cannot find module '"+q+"'");throw J.code="MODULE_NOT_FOUND",J}var Q=P[q]={exports:{}};C[q][0].call(Q.exports,function(ht){var Et=C[q][1][ht];return U(Et||ht)},Q,Q.exports,A,C,P,D)}return P[q].exports}for(var G=typeof commonjsRequire=="function"&&commonjsRequire,X=0;X<D.length;X++)U(D[X]);return U})({1:[function(A,C,P){var D,U,G,X,q,Z=function(J,Q){for(var ht in Q)K.call(Q,ht)&&(J[ht]=Q[ht]);function Et(){this.constructor=J}return Et.prototype=Q.prototype,J.prototype=new Et,J.__super__=Q.prototype,J},K={}.hasOwnProperty;D=A("./PriorityQueue/AbstractPriorityQueue"),U=A("./PriorityQueue/ArrayStrategy"),X=A("./PriorityQueue/BinaryHeapStrategy"),G=A("./PriorityQueue/BHeapStrategy"),q=(function(J){Z(Q,J);function Q(ht){ht||(ht={}),ht.strategy||(ht.strategy=X),ht.comparator||(ht.comparator=function(Et,xt){return(Et||0)-(xt||0)}),Q.__super__.constructor.call(this,ht)}return Q})(D),q.ArrayStrategy=U,q.BinaryHeapStrategy=X,q.BHeapStrategy=G,C.exports=q},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(A,C,P){C.exports=(function(){function D(U){var G;if(U?.strategy==null)throw"Must pass options.strategy, a strategy";if(U?.comparator==null)throw"Must pass options.comparator, a comparator";this.priv=new U.strategy(U),this.length=(U!=null&&(G=U.initialValues)!=null?G.length:void 0)||0}return D.prototype.queue=function(U){this.length++,this.priv.queue(U)},D.prototype.dequeue=function(U){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},D.prototype.peek=function(U){if(!this.length)throw"Empty queue";return this.priv.peek()},D.prototype.clear=function(){return this.length=0,this.priv.clear()},D})()},{}],3:[function(A,C,P){var D;D=function(U,G,X){var q,Z,K;for(Z=0,q=U.length;Z<q;)K=Z+q>>>1,X(U[K],G)>=0?Z=K+1:q=K;return Z},C.exports=(function(){function U(G){var X;this.options=G,this.comparator=this.options.comparator,this.data=((X=this.options.initialValues)!=null?X.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return U.prototype.queue=function(G){var X;X=D(this.data,G,this.comparator),this.data.splice(X,0,G)},U.prototype.dequeue=function(){return this.data.pop()},U.prototype.peek=function(){return this.data[this.data.length-1]},U.prototype.clear=function(){this.data.length=0},U})()},{}],4:[function(A,C,P){C.exports=(function(){function D(U){var G,X,q,Z,K,J,Q,ht;for(this.comparator=U?.comparator||function(Et,xt){return Et-xt},this.pageSize=U?.pageSize||512,this.length=0,Q=0;1<<Q<this.pageSize;)Q+=1;if(1<<Q!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=Q,this._emptyMemoryPageTemplate=G=[],X=0,K=this.pageSize;0<=K?X<K:X>K;0<=K?++X:--X)G.push(null);if(this._memory=[],this._mask=this.pageSize-1,U.initialValues)for(J=U.initialValues,q=0,Z=J.length;q<Z;q++)ht=J[q],this.queue(ht)}return D.prototype.queue=function(U){this.length+=1,this._write(this.length,U),this._bubbleUp(this.length,U)},D.prototype.dequeue=function(){var U,G;return U=this._read(1),G=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,G),this._bubbleDown(1,G)),U},D.prototype.peek=function(){return this._read(1)},D.prototype.clear=function(){this.length=0,this._memory.length=0},D.prototype._write=function(U,G){var X;for(X=U>>this._shift;X>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[X][U&this._mask]=G},D.prototype._read=function(U){return this._memory[U>>this._shift][U&this._mask]},D.prototype._bubbleUp=function(U,G){var X,q,Z,K;for(X=this.comparator;U>1&&(q=U&this._mask,U<this.pageSize||q>3?Z=U&~this._mask|q>>1:q<2?(Z=U-this.pageSize>>this._shift,Z+=Z&~(this._mask>>1),Z|=this.pageSize>>1):Z=U-2,K=this._read(Z),!(X(K,G)<0));)this._write(Z,G),this._write(U,K),U=Z},D.prototype._bubbleDown=function(U,G){var X,q,Z,K,J;for(J=this.comparator;U<this.length;)if(U>this._mask&&!(U&this._mask-1)?X=q=U+2:U&this.pageSize>>1?(X=(U&~this._mask)>>1,X|=U&this._mask>>1,X=X+1<<this._shift,q=X+1):(X=U+(U&this._mask),q=X+1),X!==q&&q<=this.length)if(Z=this._read(X),K=this._read(q),J(Z,G)<0&&J(Z,K)<=0)this._write(X,G),this._write(U,Z),U=X;else if(J(K,G)<0)this._write(q,G),this._write(U,K),U=q;else break;else if(X<=this.length)if(Z=this._read(X),J(Z,G)<0)this._write(X,G),this._write(U,Z),U=X;else break;else break},D})()},{}],5:[function(A,C,P){C.exports=(function(){function D(U){var G;this.comparator=U?.comparator||function(X,q){return X-q},this.length=0,this.data=((G=U.initialValues)!=null?G.slice(0):void 0)||[],this._heapify()}return D.prototype._heapify=function(){var U,G,X;if(this.data.length>0)for(U=G=1,X=this.data.length;1<=X?G<X:G>X;U=1<=X?++G:--G)this._bubbleUp(U)},D.prototype.queue=function(U){this.data.push(U),this._bubbleUp(this.data.length-1)},D.prototype.dequeue=function(){var U,G;return G=this.data[0],U=this.data.pop(),this.data.length>0&&(this.data[0]=U,this._bubbleDown(0)),G},D.prototype.peek=function(){return this.data[0]},D.prototype.clear=function(){this.length=0,this.data.length=0},D.prototype._bubbleUp=function(U){for(var G,X;U>0&&(G=U-1>>>1,this.comparator(this.data[U],this.data[G])<0);)X=this.data[G],this.data[G]=this.data[U],this.data[U]=X,U=G},D.prototype._bubbleDown=function(U){var G,X,q,Z,K;for(G=this.data.length-1;X=(U<<1)+1,Z=X+1,q=U,X<=G&&this.comparator(this.data[X],this.data[q])<0&&(q=X),Z<=G&&this.comparator(this.data[Z],this.data[q])<0&&(q=Z),q!==U;)K=this.data[q],this.data[q]=this.data[U],this.data[U]=K,U=q},D})()},{}]},{},[1])(1)})})(priorityQueue)),priorityQueue.exports}requirePriorityQueue();const readImageAsArrayBuffer=_=>new Promise(E=>{const A=new FileReader;A.onload=C=>{E({fileName:_.name.substring(0,_.name.lastIndexOf(".")),file:_,content:C.target.result})},A.readAsArrayBuffer(_)});(async _=>{if(!_)return;const E=document.createElement("input");E.type="file",E.multiple=!0,E.addEventListener("change",async A=>{const P=A.target.files;(await Promise.all(Array.from(P).map(readImageAsArrayBuffer))).map(U=>decode(new DataView(U.content)).grey().threshold()).forEach((U,G)=>{const X=document.createElement("canvas");writeCanvas(U,X),_.appendChild(X)})}),_.appendChild(E)})(document.querySelector("#app"));
